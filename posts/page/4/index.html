<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Tonfeiz&#39;s Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.70.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="Tonfeiz&#39;s Blog" />
      <link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="Tonfeiz&#39;s Blog" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://tonfeiz.github.io/posts/" />
<meta property="og:updated_time" content="2019-06-02T00:00:00+00:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://tonfeiz.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Tonfeiz&#39;s Blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/twelvefactor-2/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Twelve Factor Part Two
Backing services
Build, release and run
processes
四、支持服务(Backing services) backing services应当被视为附加资源
backing services是app通过网络使用的服务，并且这些服务被视为它基本操作的一部分。举例来说，数据存储服务(MySQL等)、消息队列系统(RabbitMQ)和缓存系统(Memcached)都属于这种服务。
backing services包括本地管理的服务和第三方服务。本条的要点就在于，不管哪类服务对app来说都应当没有区别，都被看作附加资源，都可以通过URL或者配置中的locator/credential访问。
对于app来说，一个backing services应当和另一个同样功能的backing services完成无缝替换——不需要更改任何代码。这就是因为把它们看作附加资源而使其变成松耦合带来的好处
五、构建、发行和运行 严格的区分构建和运行阶段
一个codebase通过下面三个阶段被转换为一个部署：
 构建阶段将代码转换成一批可执行文件。构建阶段获取提供者的依赖并编译二进制文件和资源 发行阶段将构建完成的东西和部署当前的配置结合起来。发行阶段完成的东西随时可以在执行环境中运行 运行阶段在执行环境中运行，启动app的一些进程  twelve-factor app严格的区分上面这三个阶段，这样就不能对运行阶段的代码作任何修改，也可以方便的回滚到上一个发行版本。每个发行版本应该有一个独一无二的ID作为标识。任何发行版本都不应该被改动，想要改动则需要新的发行版本
运行时可执行文件应当自动在任何场合(如服务器重启，进程崩溃后重启)自动执行。
六、进程 将app作为一个或多个无状态进程执行
进程应当是无状态的，不共享任何东西。需要持久化的数据应当被存在一个有状态的backing service中，通常是一个数据库
进程的内存空间或者文件系统可以被作为一个简短的，单个的事务(transaction)缓存处理。twelve-factor app从不假设在内存或是磁盘上缓存的东西在未来的请求或是工作中会是有效的——有多种情况会导致它们是失效的或被清除。 、
sticky session将用户的session数据保存在app的进程内存中并期望从相同的访问者来的请求被路由到同样的进程。这是对本准则的违反，不应当被使用。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/twelvefactor-3/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Twelve Factor Part Three
Port binding
Concurrency
Disposability
七、端口号绑定 通过绑定端口号导出服务
应用程序应当是自包含(self-contained)的，并且它不应当依赖运行时服务器的注入。web app通过将HTTP绑定到一个端口号上来将其导出作为服务。
在本地的开发环境，开发者通过像http://localhost:5000/这样的URL访问自己开发的服务。在部署环境中，则通过公共域名和端口访问。
通常这通过使用依赖声明将一个web服务器库添加到app中完成，例如Python的Tornado，Java的Jetty。
注意绑定端口的服务意味着它也可以成为其他app的backing service。
八、并发 通过进程模型达成横向扩展
任何计算机程序都表示为一个或多个计算机程序。Web应用使用了许多不同类型的进程执行形式，例如PHP进程作为Apache的子进程存在，Java由JVM提供一个维护大块系统资源的进程，而并发就由线程内在的管理。不管哪种形式，运行着的进程对于app的开发者来说都只具有最小的可见性。
在twelve-factor app中，进程是一等公民。twelve-factor中的进程从运行守护服务的UNIX进程模型获得强烈的启发。在这种模型下，开发者可通过将每种类型的工作分发一个进程类型来架构自己的app以使它们能处理形色各异的工作负载。
twelve-factor app无共享、水平可分的特性意味着增强并发是一个简单可信任的操作。进程类型和每种类型的进程数量组成的矩阵则是进程信息。
twelve-factor app不能被配置为守护进程也不能写PID文件，而应当依赖操作系统的进程管理器来管理输出流，对崩溃进程作出反应或是处理用户的重启和关闭
九、可弃性(Disposability) 通过快速启动和优雅的关闭来最大化鲁棒性
disposability意味着app可以被一瞬间开启或关闭。这对于伸缩性、代码或配置改变时的快速部署以及生产环境部署的鲁棒性都很重要。
进程应当尽量最小化启动时间，最好只需几秒钟。短暂的启动时间意味着更灵活，更鲁棒(进程管理器可以更快的把进程移动到新的物理机上)
当进程从进程管理器处收到SIGTERM信号时应当优雅的关闭。对于web进程来说，这意味着停止监听端口，让当前的请求结束然后退出。
对于工作进程来说，这意味着把当前的工作返回到工作队列中。
进程应当对由底层硬件导致的突然死亡也鲁棒。一个建议的方法是使用鲁棒的后端队列，例如Beanstalked
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/twelvefactor-4/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Dev/prod parity
Logs
Admin processes
十、开发环境/生产环境相同 保持开发环境、模拟环境和生产环境尽可能相似
历史上，在开发环境和生产环境之间有三道鸿沟，分别位：
 时间：开发者可能在需要花费几天甚至几个月才运行的代码上工作 人事：开发者写代码，运维工程师部署它 工具：开发者使用Nginx，SQLite和OSX而实际生产环境可能是Apache，MySQL和Linux  twelve-factor app需要使上面三者尽可能小来便于持续部署。
以后台服务(backing services)为例，很多语言提供库来简化与其的通信，例如使用适配器使其能适配不同的数据库。有时候开发者会倾向于在本地使用轻量级的数据库而在正式部署时使用重量级的数据库。
twelve-factor app的开发者拒绝在开发环境和生产环境之间使用不同的后台服务。
对不同后台服务的适配仍然是有用的，例如在改变后台服务时。但app的所有部署(开发环境，模拟环境和生产环境)都应当具有相同版本的后台服务
十一、日志 将日志当做事件流对待
日志提供了运行app的行为事件。它是从所有的进程和后台服务中得到的聚合的、按时间顺序排列的流。
一个twelve factor app从不关心输出流的路由或是存储。它不应当写日志文件或者管理它们。每个运行的进程都只是将事件流写入stdout中。
在开发环境中，开发者通过终端的流观察app的行为。在模拟或生产环境中，每个进程的流将被执行环境捕捉，并被路由到一个或多个最终目的地来作为长期文件。这些文件对于app是不可见并不可配置的，完全由执行环境来管理。
app的事件流还可以被送到日志索引和分析系统，例如Splunk，或是一个通用目的的存储系统例如Hadoop/Hive。这些系统能提供更多的功能
管理进程 将管理进程作为一次性的、不是经常开关的进程
开发者经常希望有一个一次性的管理进程，例如：
 运行数据库迁移 运行一个控制台 运行上传到app repo中的一次性脚本  一次性的管理进程应当和app的常规长时运行进程运行在同一个环境下，使用相同的代码库和配置，不需要进行同步措施。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/vimconfigure/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      vim中的配置是十分重要的内容，不同的用户可以根据自己的喜好将vim配置成自己喜爱的样式。本次就根据vim的帮助文档介绍以下vim配置方面的内容。
vimrc文件 vimrc文件中包含了vim在启动时就会执行的命令。对于我们最喜欢的选项和按键映射，可以放到vimrc中
vimrc文件的名字叫做.vimrc，对于Unix操作系统和Macintosh操作系统来说，它的路径名一般是~/.vimrc。
vimrc文件中可以包含所有能在vim中普通模式下&rdquo;:&ldquo;后面执行的命令，最简单的设置选项的指令，其一般格式是
set &lt;options&gt;
想要查看有哪些配置可以输入:options查看或是在帮助中查看。
对于特定的配置，可以输入:help '&lt;option name&gt;'查看。另外，在设置某个选项时在后面加&amp;即可恢复默认设置
为了使vimrc文件起作用需要退出vim再重新启动
下面列举一些设置作为例子说明
set autoindent:自动缩进，使用前一行的缩进作为当前行缩进
if has(&quot;vms&quot;) set nobackup else set backup endif 使得vim在覆写一个文件时保存有该文件的备份，而在VMS系统上则不用，因为VMS系统自带有这个功能。
set history=50:在历史记录中保持50个命令和50种搜索模式
set ruler:允许在右下角显示当前游标的位置
set showcmd:显示普通模式下输入的命令
set incsearch:在输入搜索模式下显示和其匹配的内容
map Q gq:这是一个按键映射，将Q键映射到gq按键上
filetype plugin indent on  文件类型检测：当开始编辑一个文件时，vim将会通过文件扩展名试图发现文件的类型。文件类型可被用于语法高亮等用途 使用文件类型插件文件(filetype plugin files):不同的文件类型有不同的设置。这些公共的有用选项在vim的文件类型插件中 使用缩进文件：不同类型的文件种类使用不同的缩进  简单的映射 按键映射应该是所有编辑器必备的功能了。在vim中很简单，举例来说，在vimrc文件中添加
:map &lt;F5&gt; i{&lt;Esc&gt;ea}&lt;Esc&gt; 上面的这个映射解析为
 &lt;F5&gt; 映射按键是F5键 i{ 转换为插入模式并输入{ &lt;Esc&gt; 退出为普通模式 ea}到单词结尾并输入} &lt;Esc&gt;最后转化为普通模式  这样，一般情况下输入一个单词，按F5键即可在其两端加上大括号
添加插件 vim可通过添加插件来扩展自己的功能。插件其实就是vim在启动时自动加载的vim脚本文件。在plugin文件夹中添加对应文件就可添加插件
有两种插件：
 全局插件：对所有文件都有效 文件类型插件：对特定文件类型才有效  全局插件 全局插件在启动时自动加载，它们提供了大部分通用的功能。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/vimcontinue/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      上周开了vim的坑，因此决心干脆尽量把vim的大部分常用内容都记录下来，便于以后翻阅。
 ^ -&gt; 到本行第一个不是blank字符的位置 g_ -&gt; 到本行最后一个不是blank字符的位置 :e &lt;path/to/file&gt; -&gt; 打开一个文件 :saveas &lt;path/to/file&gt; -&gt; 另存为&lt;path/to/file&gt; :bn和:bp -&gt; 同时打开多个文件时，使用这两个命令切换上一个和下一个文件 . -&gt; 可以重复上一次的命令 N&lt;command&gt; -&gt; 重复某个命令N次 *和# -&gt; 匹配光标当前所在的单词，移动光标到下一个或上一个匹配单词 很多命令可以以下面的形式来干
&lt;start position&gt;&lt;command&gt;&lt;end position&gt;
例如0y$意味着：   0 -&gt; 到行头 y -&gt; 拷贝 $ -&gt; 到本行最后一个字符  gU和gu后跟位置(例如w，e，$等)变换大小写 在当前行上，fa可以到下一个字符为a的位置处，a可变。ta可以到a前的第一个字符，a可变。这两者前可加数字 区域选择 &lt;action&gt;a&lt;object&gt;或&lt;action&gt;i&lt;object&gt;   action可以是任何命令，例如d，y，v等 object可以是w(单词),s(句子),p(段落)，或者是特别字符:&quot;、'、)、}、]
举例来说，字符串(haha (-) (&quot;tfz&quot;)).光标在f位置    vi&rdquo; -&gt; 选择tfz va&rdquo; -&gt; 选择&quot;tfz&quot; vi) -&gt; 选择&quot;tfz&quot; va) -&gt; 选择(&quot;tfz&quot;) v2i) -&gt; 选择haha (-) (&quot;tfz&quot;) v2a) -&gt; 选择(haha (-) (&quot;tfz&quot;))   块操作 &lt;C-v&gt; &lt;move&gt; &lt;motion&gt; [ESC]
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/vimeditcomputerprogrom/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      vim有许多辅助编写计算机程序的命令，可以编译一个进程并直接跳到报错的位置。
一、编译 在vim内部可以编译程序并且跳转到出错的位置。
在vim中输入以下命令，程序“make”将会被执行，结果会被捕获。
:make {arguments} 在vim中会显示出错信息。此时按下&lt;Enter&gt;键，vim会显示对应的文件并跳转到出错的位置。
下面是一些常用命令：
 :cnext将跳转到下个出错位置，:cprevious将跳转到前个出错位置 :cc将显示完整的出错信息 :clist将显示完整的出错列表。 :clist!将显示所有的出错列表，包含链接错误等等 :cfirst将跳到第一个出错位置，clast将跳到最后一个出错位置 :cc 3将跳到第3个出错位置  可以通过设置makeprg选项指定要运行的编译器,通过斜杠指定传递的参数，例如
:set makeprg=nmake\ -f\ project.mak
二、C风格的文本缩进 对于C或者C风格的程序例如Java或者C++，可以通过设置cindent选项来控制缩进。一般来说四个空格是合适的。
set cindent shiftwidth=4
可以通过=操作符来对齐缩进。最简单的命令是==，该命令会将当前行的缩进对齐。=操作符可以在可视化模式下使用。一个很有用的命令是=a{，这个命令会将当前{}所在的区域全部缩进对齐。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/vimtricks/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      这篇文章介绍了一些vim中的小技巧。
替换单词 替换命令可以将一个单词替换为另一个单词，例如:%s/four/4/g
然而，对于thirtyfour来说显然不用替换，此时可以使用&rdquo;\&lt;&quot;标志，转化为:%s/\&lt;four/4/g
显然，对于fourteen来说，也是不对。可以使用&rdquo;\&gt;&quot;标志，则转化为::%s/\&lt;four\&gt;/4/g
如果正在编程，可能希望替换注释中的“four”，这可以使用:%s/\&lt;four\&gt;4/gc
将&quot;Last, First&quot;转化为&quot;First Last&rdquo; 假设你有许多单词，其形式为
Doe, John Smith, Peter 你想将它们变为
John Doe Peter Smith 这可以通过一个命令完成：:%s/\([^,]*\),\(.*\)/\2 \1/
解释如下：
The first part between \( \) matches &quot;Last&quot;	\( \) match anything but a comma	[^,] any number of times	* matches &quot;, &quot; literally	, The second part between \( \) matches &quot;First&quot;	\( \) any character	. any number of times	* &ldquo;\2&quot;和&rdquo;\1&quot;叫做backreferences，可以指代前面用&rdquo;\( \)&ldquo;包围的文本
逆转行的顺序 命令为:global/^/m 0
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/vimtutor/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      虽然一直在使用vim编辑器，但其实一直没有练习过。借着ARTS中T的名头，就稍微学习一下vimtutor并将其中的总结放在这。
一  使用h，j，k，l作为vim中光标的移动键(比上下左右要有效率的多)。 使用:q!(quit!)强制退出当前正在编辑的文件 使用x删除当前光标停留处的文字 使用i(insert)在当前光标位置处插入内容 使用A(Append)在当前最后一行处添加内容  二  使用dw(delete word)来删除当前光标处的一个单词 使用d$删除当前位置到行末的所有内容 许多改变文本的命令都由一个operator和motion组成，例如d代表删除operator，而motion可以有如下选择：  w：直到下一个单词的起始位置，不包括该起始位置 e: 直到当前单词的结束位置，包括该结束位置 $: 直到当前行的结尾，包括最后一个单词
如果只按上述motion则可以让光标按motion移动   在motion前面可以使用数字进行对多个motion的操作 使用0到一行的起始位置处 使用dd删除一整行数据 使用u来撤销上一个操作，U来修复一整行的操作，CTRL-R来撤销撤销操作  三  使用p(put或paste)来放置vim寄存器中的文本数据(可通过dd，d，yy等操作得到) 使用r(replace)来替换当前光标处的文本 使用c(change)+motion来改变文版，注意按c之后会进入插入模式  四  使用CTRL-G命令显示当前文件名以及总行数、当前行数 使用G(Go)到当前文件底端，gg到当前文件顶端,[number]G到[number]行 使用/[text]搜索和[text]一样的文本，n是前进，N是后退 使用%来匹配各种括号 使用:s(substitute)来替进行各种替换  五  使用:!来执行外部的shell命令，例如:!ls就可以列举目录 使用:w(write) FILENAME来将当前已经写完的内容写入某个文件 使用v(visual)进入可视化模式，选择部分内容并利用:w来将这些内容写入某个文件 使用:r(read) FILENAME来将目标文件的内容读入当前正在编辑的文件中(不一定是文件内容，某个命令的输出也可以，感觉和管道或是重定向很像)  六  使用o来在当前行下面插入一行，使用O来在当前行上面插入一行 使用a来在当前光标的下一个位置插入文本 使用R来批量替换文本 使用y来复制，p来粘贴。  总结 对我来说，这个教程比较有用的是2.3,4.4和5.5。以后还要多多练习，对这些基本操作更加熟练
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/vimvundle/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      vim有非常之多的插件，因此需要一个插件管理器来管理这些插件。而Vundle就是这一利器。
Vundle是vim bundle的缩写。它能自动跟踪.vimrc中的插件，安装、更新、卸载插件。Vundle自动管理插件的运行时目录并会在安装和更新后自动重新生成帮助tag。
Vundle的安装设置  首先输入git clone https://github.com/VundleVim/Vundle.vim.git ~/vim/bundle/Vundle.vim 将下列内容保存到~/.vimrc中  set nocompatible &quot; be iMproved, required filetype off &quot; required &quot; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() &quot; alternatively, pass a path where Vundle should install plugins &quot;call vundle#begin('~/some/path/here') &quot; let Vundle manage Vundle, required Plugin 'VundleVim/Vundle.vim' &quot; The following are examples of different formats supported. &quot; Keep Plugin commands between vundle#begin/end. &quot; plugin on GitHub repo Plugin 'tpope/vim-fugitive' &quot; plugin from http://vim-scripts.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/pattern-servicemesh/" class="link black dim">
        ARTS Week Eleven Pattern Service Mesh.md
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      原文是Pattern: Service Mesh
本文的主要思想是，Service Mesh的诞生其实和TCP/IP网络栈的诞生很相似，都遵循下面的过程：
发现问题 -&gt; 将解决方案纳入代码 -&gt; 抽取共通问题 -&gt; 将解决方案抽出代码放在外部共同具备的区域
作者举了TCP/IP中流控的例子来说明这一问题。最开始电脑和电脑之间的通讯没有流控，这时人们发现如果不进行流控，接收消息的机器有可能会收到过量的信息(可能由于该机器在处理其他事务没空接收信息，而另一侧机器不知道这一点一直发送，还有很多情况会导致该现象)。
为了解决该问题，人们把处理流控的代码和业务代码放在一起。然而很快人们发现，处理流控的代码其实是共通的，所有的机器都需要处理这一点，因此最后，处理流控的代码就被放入网络栈中，而网络栈是所有网络通信的机器必须经过的一层。
接下来作者引出了分布式架构中的例子。作者举了服务发现和熔断的例子。最开始，为了解决这两个问题，相关代码也被放入业务逻辑中。后来，人们将代码抽取出来，用库的形式调用。然而，用库处理有下面的问题：
 需要花时间将库和生态中的组件胶合起来 库通常是在特定的平台下编写的(例如JVM、某种特定语言等) 对库的管理、维护很困难，例如不同版本的库兼容性不同等  最后，诞生了sidecar模式。sidecar模式其实就是对于每个服务，都有一个代理(称作sidecar)和它共同启动。该sidecar就负责处理一些共通的问题，例如上面的服务发现。服务之间均通过sidecar进行互相通信——当然，它们不知道sidecar的存在。
对所有的服务都启动sidecar，则所有的服务及其sidecar就构成了Service Mesh。这里引用William Morgan的一段话说明Service Mesh：
 A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item">
    <a href="/posts/page/3/" class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/2/">2</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/3/">3</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/posts/page/4/">4</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/5/">5</a></li>
    
    
    <li class="page-item">
    <a href="/posts/page/5/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/posts/page/5/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://tonfeiz.github.io/" >
    &copy;  Tonfeiz's Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
