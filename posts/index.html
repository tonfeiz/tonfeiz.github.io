<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Tonfeiz&#39;s Blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="generator" content="Hugo 0.70.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    
    
      <link href="/dist/css/app.1cb140d8ba31d5b2f1114537dd04802a.css" rel="stylesheet">
    

    

    
      
    

    
    
      <link href="/posts/index.xml" rel="alternate" type="application/rss+xml" title="Tonfeiz&#39;s Blog" />
      <link href="/posts/index.xml" rel="feed" type="application/rss+xml" title="Tonfeiz&#39;s Blog" />
      
    
    
    <meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://tonfeiz.github.io/posts/" />
<meta property="og:updated_time" content="2020-05-15T23:58:29+08:00" />
<meta itemprop="name" content="Posts">
<meta itemprop="description" content=""><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>

  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="http://tonfeiz.github.io/" class="f3 fw2 hover-white no-underline white-90 dib">
      Tonfeiz&#39;s Blog
    </a>
    <div class="flex-l items-center">
      

      
      














    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Posts
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="pa3 pa4-ns nested-copy-line-height nested-img">
    <section class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray"></section>
    <section class="flex-ns flex-wrap justify-around mt5">
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/my-first-post/" class="link black dim">
        My First Post
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      adsfdaf
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-10-arts-weekone-leetcode941/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Given an array A of integers, return true if and only if it is a valid mountain array.
Recall that A is a mountain array if and only if:
 A.length &gt;= 3 There exists some i with 0 &lt; i &lt; A.length - 1 such that:  A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] A[i] &gt; A[i+1] &gt; ... &gt; A[B.length - 1]     这是一道简单题，题意就是判断一个数组是否存在且只存在一个山顶，其实就是判断是否数组是先升后降的，并且不存在相等元素。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-11-arts-weekone-twelve-factor%E4%B8%80/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Twelve-Factor指的是构建Saas的应用程序应当满足的12个特性。
这些应用程序具备的特点包括：
 使用声明式方法(declarative formats)来自动化设置，以此最小化新的成员加入工程的时间和花费 与底层的操作系统之间有明确的协议，以此最大化不同执行环境之间的可移植性 适合于部署在现代云平台上，避免了服务器和系统管理员的需要 最小化开发环境(development)和生产环境(production)之间的分歧，为了最大化灵活性使用持续部署 能够在不显著改变工具、架构或者开发实践的基础上自由扩展  上面有一些名词是我暂时还不太理解的，这里做个简单的解释。
 声明式方法：倾向于直接告诉计算机做什么，而不是告诉计算机怎么做的方法。具体可见declarative programming 持续部署：和持续部署相关的概念还有持续集成和持续交付。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。(引自知乎yumminhuang) 生产环境、开发环境：软件应用开发的几个环境包括：开发环境(development)，集成环境(integration)、测试环境(testing)、QA验证、模拟环境(staging)、生产环境(production)  本是打算一次性把这12个特性都叙述一遍，但发现其中涉及到许多自己不知道的东西，因此决定还是分批来，本周先仔细看3个特性。
一、基准代码(codebase) 这一特性用一句话说就是，只有一个用版本控制系统跟踪的代码库，但可以有许多部署(deploy)
在中心化的版本管理系统中，一个codebase就是单个的代码库。在去中心化的版本管理系统中，一个codebase就是共享一个根提交(root commit)的代码库
需要注意的是，在codebase和app之间永远是一对一的关系，如果有多个codebase，那就不是一个app，而是一个分布式系统，其中的每个组件都应当是一个满足twelve-factor的app。
然而，一个app可以有多个部署。例如在生产环境中的部署，在每个开发环境上的部署等。
不同部署的codebase是相同的，但是每个活跃的部署可以是不同的版本。
二、依赖 这一特性用一句话说就是，显示的声明依赖并隔离它们
这一章读的还不太懂，可能是自身还缺乏关于微服务方面的知识的原因。
一个满足这一特性的app绝不会依赖于隐式的系统级别的库。它会使用依赖清单来显式声明自己所依赖的所有依赖项，并且会在执行期间使用依赖隔离工具来防止外界系统的隐式依赖泄漏进来(leak in)。对Ruby来说，依赖清单就是Gemfile，依赖隔离工具就是bundle exec。对Python来说，依赖清单就是pip，依赖隔离工具就是virtualenv。
这么做的一个优势就是对于新来的开发者来说，他只需要安装语言运行时环境以及依赖管理工具就可以进行app的开发。
twelve-factor app也不会隐式的依赖任何系统工具，即便这些工具在大部分操作系统上都存在，例如curl。
三、配置 将配置存在环境中
一个app的配置是在不同的部署中不同的东西。有些app将这些配置直接硬编码到代码中，这是违反twelve-factor的。配置应该从代码中严格的分离开来。当然对于内在的配置，即在不同部署中相同的配置，可以直接硬编码。
一种配置方法是使用配置文件。配置文件不应当被放入版本控制系统中，但这一点容易被忽略，而且大多配置文件往往基于特定的语言或是框架。
twelve-factor app将配置存在环境变量中。注意，使用组合的环境变量会使app失去可扩展性(组合的环境变量存疑)，最好还是将每个环境变量单独使用。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-12-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      关于写博客，其实早就想写了。写博客的好处也从各种渠道都听说过，奈何实在是懒。现在由于看到了ARTS，觉得挺有用的，也想养成长期主动学习的习惯，因此就把博客搞起来，作为这个计划的集合地，当然其它想写的时候也会随便写一些文章。
搭建博客的教程网上有很多，随便找一个基本上就能搭建完成。我也是拼拼凑凑搭出来的，现在也还只是个雏形。这里还是做个记录，毕竟别人的经验始终是别人的，自己写出来的才是自己的。
一、利用github pages托管网站 搭建自己的博客首先得有自己的网站，要有自己的网站首先得有服务器主机来维护它，作为非土豪人士，自己买服务器托管网站这种事是干不出来的。因此，可以使用github pages来托管自己的网站。
github pages是一个静态站点服务，主要就用来直接从github repo生成网站。因为之前一直也用github，因此一些基本操作也是轻车熟路了，使用它也是基于这个考虑。
github pages也有一些缺陷，这里简单的列举几点：
 它是静态站点服务，不支持服务端代码，例如PHP，Ruby或者Python github pages所在的repo最好不要超过1GB 发布的github pages网站不能超过1GB github pages站点的软带宽每个月不超过100GB  对于一般的个人博客网站来说，这些限制应该问题不大。
接下去说说具体的流程。
 在github上创建一个repo，这个repo的名字必须是username.github.io,其中username就是你在github上的用户名 选择一个文件夹作为github repo的存放地，例如就在$HOME目录下，在终端下输入下面的命令：
git clone https://github.com/username/username.github.io 进入上面的文件夹，创建一个index.html文件。命令如下：
cd username.github.io
echo &quot;Hello World&quot; &gt; index.html 将改变上传到github端。命令如下：
git add -all
git commit -m &quot;Initial commit&quot;
git push -u origin master  至此，网站就可以查看了。可以在浏览器中输入
https://username.github.io
查看自己的网站
二、利用jkeyll编辑自己的博客 有了github pages托管网站之后，接下去就是要将网站变成博客形式了。虽然之前稍微学过一点前端的知识，但要自己从头搭建还是有些困难。在github pages上发现大力推荐的一个静态网页和博客生成框架jekyll，可以直接把markdown格式的文件转化成网页，因此干脆就入坑jekyll了。
目前我也只是过了两遍jekyll的教程，具体使用还需要摸索，这里就简单的讲一下基础的内容。如果想要详细了解，还是得去jekyll官网
jekyll首先需要安装Ruby的运行环境，在Linux Ubuntu环境下是很简单的，输入下面的命令： sudo apt-get install ruby-full build-essential zlib1g-dev 接着设置一下环境变量
echo '# Install Ruby Gems to ~/gems' &gt;&gt; ~/.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-14-arts-weekone-vimtutor%E6%80%BB%E7%BB%93/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      虽然一直在使用vim编辑器，但其实一直没有练习过。借着ARTS中T的名头，就稍微学习一下vimtutor并将其中的总结放在这。
一  使用h，j，k，l作为vim中光标的移动键(比上下左右要有效率的多)。 使用:q!(quit!)强制退出当前正在编辑的文件 使用x删除当前光标停留处的文字 使用i(insert)在当前光标位置处插入内容 使用A(Append)在当前最后一行处添加内容  二  使用dw(delete word)来删除当前光标处的一个单词 使用d$删除当前位置到行末的所有内容 许多改变文本的命令都由一个operator和motion组成，例如d代表删除operator，而motion可以有如下选择：  w：直到下一个单词的起始位置，不包括该起始位置 e: 直到当前单词的结束位置，包括该结束位置 $: 直到当前行的结尾，包括最后一个单词
如果只按上述motion则可以让光标按motion移动   在motion前面可以使用数字进行对多个motion的操作 使用0到一行的起始位置处 使用dd删除一整行数据 使用u来撤销上一个操作，U来修复一整行的操作，CTRL-R来撤销撤销操作  三  使用p(put或paste)来放置vim寄存器中的文本数据(可通过dd，d，yy等操作得到) 使用r(replace)来替换当前光标处的文本 使用c(change)+motion来改变文版，注意按c之后会进入插入模式  四  使用CTRL-G命令显示当前文件名以及总行数、当前行数 使用G(Go)到当前文件底端，gg到当前文件顶端,[number]G到[number]行 使用/[text]搜索和[text]一样的文本，n是前进，N是后退 使用%来匹配各种括号 使用:s(substitute)来替进行各种替换  五  使用:!来执行外部的shell命令，例如:!ls就可以列举目录 使用:w(write) FILENAME来将当前已经写完的内容写入某个文件 使用v(visual)进入可视化模式，选择部分内容并利用:w来将这些内容写入某个文件 使用:r(read) FILENAME来将目标文件的内容读入当前正在编辑的文件中(不一定是文件内容，某个命令的输出也可以，感觉和管道或是重定向很像)  六  使用o来在当前行下面插入一行，使用O来在当前行上面插入一行 使用a来在当前光标的下一个位置插入文本 使用R来批量替换文本 使用y来复制，p来粘贴。  总结 对我来说，这个教程比较有用的是2.3,4.4和5.5。以后还要多多练习，对这些基本操作更加熟练
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-15-arts-weektwo-leetcode704-binarysearch/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.
You may assume that all elements in nums are unique. n will be in the range [1, 10000]. The value of each element in nums will be in the range [-9999, 9999].
 这题其实就是一个简单的二分搜索，数组中的元素都是唯一的，且数值也不大，难怪会被分到简单题里
二分搜索很有名，要实现一个完全正确的二分搜索是很困难的，但这题的要求并不高。基本思想就是每次寻找中间元素并根据中间元素与目标元素的大小判断下一个搜索范围应该在哪一侧
二分搜索时，左侧和右侧的范围应当界定明确。在下面的代码中，采用的范围是C++中的通用范围，即[left, right)。因此，循环的推出条件就是两者相等。当缩小范围时，要根据上面的关系选择是中间元素还是中间元素的两侧元素
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-15-arts-weektwo-twelve-factor%E4%BA%8C/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Twelve Factor Part Two
Backing services
Build, release and run
processes
四、支持服务(Backing services) backing services应当被视为附加资源
backing services是app通过网络使用的服务，并且这些服务被视为它基本操作的一部分。举例来说，数据存储服务(MySQL等)、消息队列系统(RabbitMQ)和缓存系统(Memcached)都属于这种服务。
backing services包括本地管理的服务和第三方服务。本条的要点就在于，不管哪类服务对app来说都应当没有区别，都被看作附加资源，都可以通过URL或者配置中的locator/credential访问。
对于app来说，一个backing services应当和另一个同样功能的backing services完成无缝替换——不需要更改任何代码。这就是因为把它们看作附加资源而使其变成松耦合带来的好处
五、构建、发行和运行 严格的区分构建和运行阶段
一个codebase通过下面三个阶段被转换为一个部署：
 构建阶段将代码转换成一批可执行文件。构建阶段获取提供者的依赖并编译二进制文件和资源 发行阶段将构建完成的东西和部署当前的配置结合起来。发行阶段完成的东西随时可以在执行环境中运行 运行阶段在执行环境中运行，启动app的一些进程  twelve-factor app严格的区分上面这三个阶段，这样就不能对运行阶段的代码作任何修改，也可以方便的回滚到上一个发行版本。每个发行版本应该有一个独一无二的ID作为标识。任何发行版本都不应该被改动，想要改动则需要新的发行版本
运行时可执行文件应当自动在任何场合(如服务器重启，进程崩溃后重启)自动执行。
六、进程 将app作为一个或多个无状态进程执行
进程应当是无状态的，不共享任何东西。需要持久化的数据应当被存在一个有状态的backing service中，通常是一个数据库
进程的内存空间或者文件系统可以被作为一个简短的，单个的事务(transaction)缓存处理。twelve-factor app从不假设在内存或是磁盘上缓存的东西在未来的请求或是工作中会是有效的——有多种情况会导致它们是失效的或被清除。 、
sticky session将用户的session数据保存在app的进程内存中并期望从相同的访问者来的请求被路由到同样的进程。这是对本准则的违反，不应当被使用。
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-16-arts-weektwo-vim%E8%BF%9B%E9%98%B6/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      上周开了vim的坑，因此决心干脆尽量把vim的大部分常用内容都记录下来，便于以后翻阅。
 ^ -&gt; 到本行第一个不是blank字符的位置 g_ -&gt; 到本行最后一个不是blank字符的位置 :e &lt;path/to/file&gt; -&gt; 打开一个文件 :saveas &lt;path/to/file&gt; -&gt; 另存为&lt;path/to/file&gt; :bn和:bp -&gt; 同时打开多个文件时，使用这两个命令切换上一个和下一个文件 . -&gt; 可以重复上一次的命令 N&lt;command&gt; -&gt; 重复某个命令N次 *和# -&gt; 匹配光标当前所在的单词，移动光标到下一个或上一个匹配单词 很多命令可以以下面的形式来干
&lt;start position&gt;&lt;command&gt;&lt;end position&gt;
例如0y$意味着：   0 -&gt; 到行头 y -&gt; 拷贝 $ -&gt; 到本行最后一个字符  gU和gu后跟位置(例如w，e，$等)变换大小写 在当前行上，fa可以到下一个字符为a的位置处，a可变。ta可以到a前的第一个字符，a可变。这两者前可加数字 区域选择 &lt;action&gt;a&lt;object&gt;或&lt;action&gt;i&lt;object&gt;   action可以是任何命令，例如d，y，v等 object可以是w(单词),s(句子),p(段落)，或者是特别字符:&quot;、'、)、}、]
举例来说，字符串(haha (-) (&quot;tfz&quot;)).光标在f位置    vi&rdquo; -&gt; 选择tfz va&rdquo; -&gt; 选择&quot;tfz&quot; vi) -&gt; 选择&quot;tfz&quot; va) -&gt; 选择(&quot;tfz&quot;) v2i) -&gt; 选择haha (-) (&quot;tfz&quot;) v2a) -&gt; 选择(haha (-) (&quot;tfz&quot;))   块操作 &lt;C-v&gt; &lt;move&gt; &lt;motion&gt; [ESC]
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-23-arts-weekthree-leetcode1022-sumroottoleaf/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Given a binary tree, each node has value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.
Return the sum of these numbers.
    </div>
  </div>
</div>
</div>
      
        <div class="relative w-100 w-30-l mb4 bg-white"><div class="relative w-100 mb4 bg-white nested-copy-line-height">
  <div class="bg-white mb3 pa4 gray overflow-hidden">
    <span class="f6 db">Posts</span>
    <h1 class="f3 near-black">
      <a href="http://tonfeiz.github.io/posts/2019-04-23-arts-weekthree-twelve-factor%E4%B8%89/" class="link black dim">
        
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      Twelve Factor Part Three
Port binding
Concurrency
Disposability
七、端口号绑定 通过绑定端口号导出服务
应用程序应当是自包含(self-contained)的，并且它不应当依赖运行时服务器的注入。web app通过将HTTP绑定到一个端口号上来将其导出作为服务。
在本地的开发环境，开发者通过像http://localhost:5000/这样的URL访问自己开发的服务。在部署环境中，则通过公共域名和端口访问。
通常这通过使用依赖声明将一个web服务器库添加到app中完成，例如Python的Tornado，Java的Jetty。
注意绑定端口的服务意味着它也可以成为其他app的backing service。
八、并发 通过进程模型达成横向扩展
任何计算机程序都表示为一个或多个计算机程序。Web应用使用了许多不同类型的进程执行形式，例如PHP进程作为Apache的子进程存在，Java由JVM提供一个维护大块系统资源的进程，而并发就由线程内在的管理。不管哪种形式，运行着的进程对于app的开发者来说都只具有最小的可见性。
在twelve-factor app中，进程是一等公民。twelve-factor中的进程从运行守护服务的UNIX进程模型获得强烈的启发。在这种模型下，开发者可通过将每种类型的工作分发一个进程类型来架构自己的app以使它们能处理形色各异的工作负载。
twelve-factor app无共享、水平可分的特性意味着增强并发是一个简单可信任的操作。进程类型和每种类型的进程数量组成的矩阵则是进程信息。
twelve-factor app不能被配置为守护进程也不能写PID文件，而应当依赖操作系统的进程管理器来管理输出流，对崩溃进程作出反应或是处理用户的重启和关闭
九、可弃性(Disposability) 通过快速启动和优雅的关闭来最大化鲁棒性
disposability意味着app可以被一瞬间开启或关闭。这对于伸缩性、代码或配置改变时的快速部署以及生产环境部署的鲁棒性都很重要。
进程应当尽量最小化启动时间，最好只需几秒钟。短暂的启动时间意味着更灵活，更鲁棒(进程管理器可以更快的把进程移动到新的物理机上)
当进程从进程管理器处收到SIGTERM信号时应当优雅的关闭。对于web进程来说，这意味着停止监听端口，让当前的请求结束然后退出。
对于工作进程来说，这意味着把当前的工作返回到工作队列中。
进程应当对由底层硬件导致的突然死亡也鲁棒。一个建议的方法是使用鲁棒的后端队列，例如Beanstalked
    </div>
  </div>
</div>
</div>
      
    </section>

<ul class="pagination">
    
    <li class="page-item">
        <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
    </li>
    
    <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
    </li>
    
    
    
    
    
    
    
        
        
    
    
    <li class="page-item active"><a class="page-link" href="/posts/">1</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/2/">2</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/3/">3</a></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item disabled"><span aria-hidden="true">&nbsp;&hellip;&nbsp;</span></li>
    
    
    
    
    
    
        
        
    
    
    <li class="page-item"><a class="page-link" href="/posts/page/5/">5</a></li>
    
    
    <li class="page-item">
    <a href="/posts/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
    </li>
    
    <li class="page-item">
        <a href="/posts/page/5/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
    </li>
    
</ul>

</article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://tonfeiz.github.io/" >
    &copy;  Tonfeiz's Blog 2020 
  </a>
    <div>













</div>
  </div>
</footer>

    

  <script src="/dist/js/app.3fc0f988d21662902933.js"></script>


  </body>
</html>
