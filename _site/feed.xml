<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-05-19T18:16:46+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tonfeiz’s Blog</title><subtitle></subtitle><author><name>Tonfeiz</name></author><entry><title type="html">计算机技术历史 语言(语言)</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E8%AF%AD%E8%A8%80)/" rel="alternate" type="text/html" title="计算机技术历史 语言(语言)" /><published>2019-05-19T00:00:00+08:00</published><updated>2019-05-19T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E8%AF%AD%E8%A8%80)</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E8%AF%AD%E8%A8%80)/">&lt;p&gt;本次介绍一下虽然没有名气，但是深远的影响了后面的大部分程序设计语言的一个语言-Algol编程语言。&lt;/p&gt;

&lt;p&gt;ALGOL语言诞生在20世纪50年代末。目前大多数现代语言的语法其实都是类似类Algol的。它是最有影响力的四种高级语言之一：FORTRAN，Lisp和COBOL。它被设计来改善FORTRAN暴露的问题并且最后导致了许多编程语言的诞生——PL/I，BCPL，B，Pascal和C。&lt;/p&gt;

&lt;p&gt;Algol引入了代码块的概念和&lt;code class=&quot;highlighter-rouge&quot;&gt;begin...end&lt;/code&gt;对。它也是第一个支持嵌套函数定义的编程语言。此外，它是第一个详细关注(?)正式语言定义的编程语言。并且也是它引入了BNF范式。&lt;/p&gt;

&lt;p&gt;ALGOL 60有两种参数传递方式：按值传递和按名字传递。按名字传递对引用传递有深远的影响。按名字传递指的是当参数传递给函数时，它是在函数内部出现该参数的地方直接替换。这样的话，如果函数内部没有用到该参数，它就不会被求值。如果函数内部出现了多次，每次它都会被重新求值。&lt;/p&gt;

&lt;p&gt;然而，ALGOL 60没有定义I/O设施。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">本次介绍一下虽然没有名气，但是深远的影响了后面的大部分程序设计语言的一个语言-Algol编程语言。</summary></entry><entry><title type="html">Arts Weeksix Leetcode674 Lcis</title><link href="http://localhost:4000/ARTS-WeekSix-Leetcode674-LCIS/" rel="alternate" type="text/html" title="Arts Weeksix Leetcode674 Lcis" /><published>2019-05-17T00:00:00+08:00</published><updated>2019-05-17T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekSix-Leetcode674-LCIS</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekSix-Leetcode674-LCIS/">&lt;p&gt;Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题其实就是找数组中的最长连续递增子序列。想法也很简单，设置一个startIndex，当发现序列不是递增时，则子序列的长度是当前的Index减去startIndex，同时将startIndex设置为当前位置(这里注意可能有off-by-one)。遍历整个序列，找到最长的序列即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func findLengthOfLCIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    lengthMax := 1
    startIndex := 0
    
    arrayLength := len(nums)
    for i := 0; i &amp;lt; arrayLength - 1; i++ {
        if nums[i + 1] &amp;lt;= nums[i] {
            if i +  1 - startIndex &amp;gt; lengthMax {
                lengthMax = i + 1 - startIndex
            }
            startIndex = i + 1
        }
    }
    
    if startIndex != arrayLength - 1 &amp;amp;&amp;amp; arrayLength - startIndex &amp;gt; lengthMax {
        lengthMax = arrayLength - startIndex
    }
    
    return lengthMax
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</summary></entry><entry><title type="html">Arts Weeksix Vim Tricks</title><link href="http://localhost:4000/ARTS-WeekSix-vim-tricks/" rel="alternate" type="text/html" title="Arts Weeksix Vim Tricks" /><published>2019-05-17T00:00:00+08:00</published><updated>2019-05-17T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekSix-vim-tricks</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekSix-vim-tricks/">&lt;p&gt;这篇文章介绍了一些vim中的小技巧。&lt;/p&gt;

&lt;h2 id=&quot;替换单词&quot;&gt;替换单词&lt;/h2&gt;
&lt;p&gt;替换命令可以将一个单词替换为另一个单词，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/four/4/g&lt;/code&gt;&lt;br /&gt;
然而，对于&lt;code class=&quot;highlighter-rouge&quot;&gt;thirtyfour&lt;/code&gt;来说显然不用替换，此时可以使用”\&amp;lt;”标志，转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\&amp;lt;four/4/g&lt;/code&gt;&lt;br /&gt;
显然，对于&lt;code class=&quot;highlighter-rouge&quot;&gt;fourteen&lt;/code&gt;来说，也是不对。可以使用”\&amp;gt;”标志，则转化为:&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\&amp;lt;four\&amp;gt;/4/g&lt;/code&gt;&lt;br /&gt;
如果正在编程，可能希望替换注释中的“four”，这可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\&amp;lt;four\&amp;gt;4/gc&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;将last-first转化为first-last&quot;&gt;将”Last, First”转化为”First Last”&lt;/h2&gt;
&lt;p&gt;假设你有许多单词，其形式为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Doe, John
Smith, Peter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;你想将它们变为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;John Doe
Peter Smith
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这可以通过一个命令完成：&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\([^,]*\),\(.*\)/\2 \1/&lt;/code&gt;&lt;br /&gt;
解释如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The first part between \( \) matches &quot;Last&quot;	\(     \)
match anything but a comma			  [^,]
any number of times				      *
matches &quot;, &quot; literally					 ,
The second part between \( \) matches &quot;First&quot;		   \(  \)
any character					     .
any number of times					      *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;“\2”和”\1”叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;backreferences&lt;/code&gt;，可以指代前面用”\( \)”包围的文本&lt;/p&gt;

&lt;h2 id=&quot;逆转行的顺序&quot;&gt;逆转行的顺序&lt;/h2&gt;
&lt;p&gt;命令为&lt;code class=&quot;highlighter-rouge&quot;&gt;:global/^/m 0&lt;/code&gt;&lt;br /&gt;
它的意思是，对于特定的一行，&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;到达行开始，&lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;移动整行，移动位置是第0行，也就是第一行之前。而&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;命令不会被改变的顺序影响，因此所有的行依次进行上面的命令，则逆转了文件所有行的顺序&lt;/p&gt;

&lt;h2 id=&quot;数单词&quot;&gt;数单词&lt;/h2&gt;
&lt;p&gt;命令为&lt;code class=&quot;highlighter-rouge&quot;&gt;g CTRL-G&lt;/code&gt;，注意&lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt;的后面没有空格。也可以在可视模式下选择部分内容再使用上面的命令&lt;/p&gt;

&lt;h2 id=&quot;无用的空格&quot;&gt;无用的空格&lt;/h2&gt;
&lt;p&gt;有时候有些空格在行的最后没有用且很丑，为了删除这些空格，可以使用这条命令&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\s\+$//&lt;/code&gt;。这句话的意思是将一个或多个&lt;code class=&quot;highlighter-rouge&quot;&gt;(\+)&lt;/code&gt;在结尾&lt;code class=&quot;highlighter-rouge&quot;&gt;($)&lt;/code&gt;处的空格&lt;code class=&quot;highlighter-rouge&quot;&gt;(\s)&lt;/code&gt;替换成空白&lt;code class=&quot;highlighter-rouge&quot;&gt;(//)&lt;/code&gt;。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">这篇文章介绍了一些vim中的小技巧。</summary></entry><entry><title type="html">Arts Weeksix Threerules</title><link href="http://localhost:4000/ARTS-weekSix-ThreeRules/" rel="alternate" type="text/html" title="Arts Weeksix Threerules" /><published>2019-05-16T00:00:00+08:00</published><updated>2019-05-16T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-weekSix-ThreeRules</id><content type="html" xml:base="http://localhost:4000/ARTS-weekSix-ThreeRules/">&lt;p&gt;这篇文章讲述了Instagram构建可伸缩云应用架构的三个原则。&lt;/p&gt;

&lt;h2 id=&quot;三使用被证实的稳定的技术&quot;&gt;三、使用被证实的稳定的技术&lt;/h2&gt;
&lt;p&gt;Instagram会观察周围的最具实力的专家们都在使用哪些技术，然后争取使用和他们一致的技术。&lt;/p&gt;

&lt;p&gt;例如，观察周围的这些公司，就会发现它们都在从旧时代的，微缩整体的架构转换到如今的微服务架构。微服务架构更偏向于简化的选择正确的工具。&lt;/p&gt;

&lt;h2 id=&quot;二不要重新发明轮子&quot;&gt;二、不要重新发明轮子&lt;/h2&gt;
&lt;p&gt;云提供商和基础数据库决策以及向DevOps的持续转变正在变得常见。科技应当帮助你建造接下来的事情，而不是让你确保处理用户的下一波浪潮。&lt;/p&gt;

&lt;p&gt;使用已有的东西，不管那是库、社区或是已知的内在知识。&lt;/p&gt;

&lt;h2 id=&quot;一保持简单&quot;&gt;一、保持简单&lt;/h2&gt;
&lt;p&gt;每个决策都可能使得代码变得更复杂。因此，要确保每个决策都尽量谨慎以使得程序保持简单、简洁&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">这篇文章讲述了Instagram构建可伸缩云应用架构的三个原则。</summary></entry><entry><title type="html">Arts Weekfive Avoid Over Engineering</title><link href="http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering/" rel="alternate" type="text/html" title="Arts Weekfive Avoid Over Engineering" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering/">&lt;p&gt;商业需求是在不断变化的，因此过度设计往往得不偿失。注意：下面的一些内容不是不要做，而是要适当，不要过度。&lt;/p&gt;

&lt;p&gt;以下是一些误解&lt;/p&gt;
&lt;h2 id=&quot;1-工程比商业更聪明&quot;&gt;1. 工程比商业更聪明&lt;/h2&gt;
&lt;p&gt;工程师们往往认为自己掌控一切，但事实上商业需求永远技高一筹。在第1000个问题被解决后，它们还能冒出第1001个需求来。&lt;/p&gt;

&lt;p&gt;商业需求是发散的，而不是收敛的&lt;/p&gt;

&lt;h2 id=&quot;2-重用商业功能模块&quot;&gt;2. 重用商业功能模块&lt;/h2&gt;
&lt;p&gt;当商业抛出越来越多的功能，我们有时候会将逻辑组合起来，尽量泛化它们。然而商业需求只会发散而不会收敛，这就使得共享的逻辑变得庞大。反之，我们应该将每个动作和逻辑分离开来，只有很少的共享逻辑。&lt;/p&gt;

&lt;p&gt;在横向分离之前先尝试纵向分裂商业功能。多隔离动作而少组合动作。&lt;/p&gt;

&lt;h2 id=&quot;3-所有的事情都是关于泛型&quot;&gt;3. 所有的事情都是关于泛型&lt;/h2&gt;
&lt;p&gt;有些时候工程师会执着于完美的抽象而忽略了真正的问题。其实答案非常简单。&lt;/p&gt;

&lt;p&gt;今天最好的设计是它能怎么样被取消(undesigned)。写的代码要易于删除，而不是易于扩展。&lt;/p&gt;

&lt;p&gt;重复比错误的抽象要好。重复次数多了，抽象就显现出来了。&lt;/p&gt;

&lt;h2 id=&quot;4-臃肿的包裹器&quot;&gt;4. 臃肿的包裹器&lt;/h2&gt;
&lt;p&gt;在使用每个外部库之前都写一个包裹器是不对的。这会使得包裹器变得臃肿。另一方面，包裹器往往和底层的库紧密的耦合，底层库变了包裹器也变了。&lt;/p&gt;

&lt;p&gt;现在许多外部库的API已经足够优秀了，因此不要总想着写包裹器。包裹器是一个异常情况，而不是正常情况。&lt;/p&gt;

&lt;h2 id=&quot;5-像使用工具一样使用质量&quot;&gt;5. 像使用工具一样使用质量&lt;/h2&gt;
&lt;p&gt;盲目的应用质量概念（例如将所有变量改成”private final”,为所有的类写接口等）并不会使代码奇迹般的变好。&lt;/p&gt;

&lt;p&gt;记住要总是往后退一步然后看看总体的风景。&lt;/p&gt;

&lt;p&gt;有些代码完全符合各种原则和概念，但是从整体来看却很糟糕。&lt;/p&gt;

&lt;h3 id=&quot;51-三明治层&quot;&gt;5.1 三明治层&lt;/h3&gt;
&lt;p&gt;例如，将一个简洁的，紧密相连的动作划分层10或20层三明治层，每一层都与外界无关。在过去使用继承来完成，即A扩展出B扩展出C……。现在想要完成这件事并且符合SOLID原则，则需要对每个类构建接口，并且把一个类依次注入到下一个类中，明显变得更麻烦了。&lt;/p&gt;

&lt;p&gt;像SOLID这样的概念是由于继承和其他OOP概念的滥用才产生的。大多数工程师不知道这些东西为什么诞生，只是跟随着就用。&lt;/p&gt;

&lt;p&gt;脑海中的概念应当会转换，而不能被盲目的像工具一样使用。&lt;/p&gt;

&lt;h2 id=&quot;6-过度使用综合征&quot;&gt;6. 过度使用综合征&lt;/h2&gt;
&lt;p&gt;一些过度使用综合征的例子：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;发现了泛型，于是一个简单的”HelloWorldPrinter”变成了”HelloWorldPrinter&amp;lt;String, Writer&amp;gt;”&lt;/li&gt;
  &lt;li&gt;发现了策略模式，于是每个”if”都是一个策略&lt;/li&gt;
  &lt;li&gt;发现了怎么写DSL，于是到处使用DSL&lt;/li&gt;
  &lt;li&gt;发现了Mocks，于是对每个测试的对象都使用mock&lt;/li&gt;
  &lt;li&gt;元编程太棒了，到处都使用元编程&lt;/li&gt;
  &lt;li&gt;枚举/扩展方法/Traits等等太棒了，到处都使用它…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-x-ity&quot;&gt;7. &amp;lt;X&amp;gt;-ity&lt;/h2&gt;
&lt;p&gt;…性。例如可配置性，安全性，扩展性，维护性，伸缩性等等。这些性质当然是好的，但不要对每个性能都担忧会发生意外。仔细的考虑使用场景，再对这些性能作优化。&lt;/p&gt;

&lt;h2 id=&quot;8-内部发明&quot;&gt;8. 内部”发明”&lt;/h2&gt;
&lt;p&gt;内部的库、框架和工具最近很流行，但并不一定是好的。&lt;/p&gt;

&lt;p&gt;一些被错过的事情：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于某个问题领域有很深的了解是很难的，需要很多的技能。&lt;/li&gt;
  &lt;li&gt;让“发明”持续运行需要很多努力。即使是很小的库的维护也需要诸多时间&lt;/li&gt;
  &lt;li&gt;和对现有框架作出贡献相比，创造一个”发明”往往需要更多的时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重用，fork，贡献，重新考虑&lt;/p&gt;

&lt;h2 id=&quot;9-维持现状&quot;&gt;9. 维持现状&lt;/h2&gt;
&lt;p&gt;一旦一件事情被完成了，每个人都开始基于它构建东西。没人质疑现状。工作着的代码被认为是正确的。每个人都改变自己来适应这个库。&lt;/p&gt;

&lt;p&gt;这样是不对的。一个健康的系统是会搅动、翻腾的。很长时间不提交的代码一定是有问题的。&lt;/p&gt;

&lt;p&gt;重构是每个故事的一部分。没有代码是不可触碰的。&lt;/p&gt;

&lt;h2 id=&quot;10-差的估计&quot;&gt;10. 差的估计&lt;/h2&gt;
&lt;p&gt;我们经常发现非常优秀的团队或是程序员写出糟糕的代码。这是因为质量需要时间而不仅仅是技术。聪明的程序员往往会高估自己的实力于是只能匆忙写出较差的代码。因此，谨慎估计完成日期。&lt;/p&gt;

&lt;p&gt;差的估计在代码开始写之前就破坏了质量。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章主要是关于过度设计的。作者列举了10个过度设计的例子，其中有些由于我还没有接触实际的生产代码还不清楚，但大部分内容还是很有帮助的。&lt;/p&gt;

&lt;p&gt;第1点是文章的核心，我在很多其他地方也见到过类似的内容，即需求是一直变化的，不要妄想自己写出完美的代码。&lt;/p&gt;

&lt;p&gt;第3点对我来说比较重要，因为我之前总想着把变化封装起来，看了第3点之后明白了，一定要适度，过度抽象只会弄巧成拙。&lt;/p&gt;

&lt;p&gt;第9点也点醒了我。之前一直以为较好的库意味着很少对它作改动，每个人都用的舒心，然而其实不是这样的。即便是很好的库也一定会有问题存在，人们不动它可能是因为人们去习惯它。我们应当时刻注意自己写的内容，当很长时间没有翻新时则更要警惕。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">商业需求是在不断变化的，因此过度设计往往得不偿失。注意：下面的一些内容不是不要做，而是要适当，不要过度。</summary></entry><entry><title type="html">Arts Weekfive Vim编辑计算机程序</title><link href="http://localhost:4000/ARTS-WeekFive-vim%E7%BC%96%E8%BE%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/" rel="alternate" type="text/html" title="Arts Weekfive Vim编辑计算机程序" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFive-vim%E7%BC%96%E8%BE%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFive-vim%E7%BC%96%E8%BE%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/">&lt;p&gt;vim有许多辅助编写计算机程序的命令，可以编译一个进程并直接跳到报错的位置。&lt;/p&gt;

&lt;h2 id=&quot;一编译&quot;&gt;一、编译&lt;/h2&gt;
&lt;p&gt;在vim内部可以编译程序并且跳转到出错的位置。&lt;/p&gt;

&lt;p&gt;在vim中输入以下命令，程序“make”将会被执行，结果会被捕获。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:make {arguments}&lt;/code&gt;
在vim中会显示出错信息。此时按下&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt;键，vim会显示对应的文件并跳转到出错的位置。&lt;/p&gt;

&lt;p&gt;下面是一些常用命令：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cnext&lt;/code&gt;将跳转到下个出错位置，&lt;code class=&quot;highlighter-rouge&quot;&gt;:cprevious&lt;/code&gt;将跳转到前个出错位置&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cc&lt;/code&gt;将显示完整的出错信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:clist&lt;/code&gt;将显示完整的出错列表。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:clist!&lt;/code&gt;将显示所有的出错列表，包含链接错误等等&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cfirst&lt;/code&gt;将跳到第一个出错位置，&lt;code class=&quot;highlighter-rouge&quot;&gt;clast&lt;/code&gt;将跳到最后一个出错位置&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cc 3&lt;/code&gt;将跳到第3个出错位置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;makeprg&lt;/code&gt;选项指定要运行的编译器,通过斜杠指定传递的参数，例如&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:set makeprg=nmake\ -f\ project.mak&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;二c风格的文本缩进&quot;&gt;二、C风格的文本缩进&lt;/h2&gt;
&lt;p&gt;对于C或者C风格的程序例如Java或者C++，可以通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;cindent&lt;/code&gt;选项来控制缩进。一般来说四个空格是合适的。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set cindent shiftwidth=4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;操作符来对齐缩进。最简单的命令是&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;，该命令会将当前行的缩进对齐。&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;操作符可以在可视化模式下使用。一个很有用的命令是&lt;code class=&quot;highlighter-rouge&quot;&gt;=a{&lt;/code&gt;，这个命令会将当前&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;所在的区域全部缩进对齐。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">vim有许多辅助编写计算机程序的命令，可以编译一个进程并直接跳到报错的位置。</summary></entry><entry><title type="html">计算机技术历史 语言(二)</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%BA%8C)/" rel="alternate" type="text/html" title="计算机技术历史 语言(二)" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%BA%8C)</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%BA%8C)/">&lt;p&gt;在汇编语言之后，诞生了最早的程序设计语言，FORTRAN。&lt;/p&gt;

&lt;h2 id=&quot;fortran语言&quot;&gt;FORTRAN语言&lt;/h2&gt;
&lt;p&gt;FORTAN源自于英语：Formula Translation，即公式翻译。从这里就可以看出，FORTRAN语言的主要用处是科学和工程计算方面。&lt;/p&gt;

&lt;p&gt;汇编语言的缺点在上次已经讲过，难以维护，入门门槛高，要维护各种寄存器等等。在1951年，IBM的John Backus针对这些缺点开始开发FORTRAN语言。&lt;/p&gt;

&lt;p&gt;1954年，FORTRAN I发布。1957年，第一个FORTRAN编译器在IBM704计算机上实现，并首次成功运行了FORTRAN程序。&lt;/p&gt;

&lt;p&gt;由于我也不会FORTRAN语言，因此我只能搜集一些资料，简单的介绍一下FORTRAN语言。&lt;/p&gt;

&lt;p&gt;FORTRAN语言的最大特性是接近数学公式的自然描述，在计算机里具有很高的执行效率。另外，它可以直接对矩阵和复数进行运算，类似于MATLAB。很多大型的数值运算计算机针对Fortran做了优化。&lt;/p&gt;

&lt;p&gt;相对于汇编语言，FORTRAN由于其语法的简洁性使得其入门门槛较低，可维护性也有所提高。然而，由于早期程序设计的局限性，FORTRAN的缺点也是有一大堆。FORTRAN中，某些字母开头的变量默认是某种类型，这就给命名增添了负担。早期的FORTRAN代码往往到处使用GOTO，使得程序的控制流混乱。FORTRAN的数值溢出等等也是坑。此外，虽然相比于汇编程序，FORTRAN的易读性和可维护性提高了，但相比于现代程序设计语言如C++、Java等，仍然有不少的差距。FORTRAN代码往往比较冗长，初看时会不知所以。&lt;/p&gt;

&lt;p&gt;注：上文所说的主要是FORTRAN语言的早期版本，后来FORTRAN也加入了一些现代编程语言的特性，但和原始FORTRAN诞生原因关系不大，因此就不再详细叙述。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/FORTRAN&quot;&gt;百度百科&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/28683874&quot;&gt;和 C++ 相比，用 Fortran 编程是怎样的体验？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Tonfeiz</name></author><summary type="html">在汇编语言之后，诞生了最早的程序设计语言，FORTRAN。</summary></entry><entry><title type="html">Arts Weekfive Leetcode856 Scoreofparentheses</title><link href="http://localhost:4000/ARTS-WeekFive-Leetcode856-ScoreOfParentheses/" rel="alternate" type="text/html" title="Arts Weekfive Leetcode856 Scoreofparentheses" /><published>2019-05-06T00:00:00+08:00</published><updated>2019-05-06T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFive-Leetcode856-ScoreOfParentheses</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFive-Leetcode856-ScoreOfParentheses/">&lt;p&gt;Given a balanced parentheses string S, compute the score of the string based on the following rule:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() has score 1
AB has score A + B, where A and B are balanced parentheses strings.
(A) has score 2 * A, where A is a balanced parentheses string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: &quot;()&quot;
Output: 1

Input: &quot;(())&quot;
Output: 2

Input: &quot;()()&quot;
Output: 2

Input: &quot;(()(()))&quot;
Output: 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;这是一道mdeium题，题意是对于一个完全匹配的括号串，()表示1,AB表示A+B,(A)表示A*2，其中A、B都是某个括号表达式，求给定括号串的值。&lt;/p&gt;

&lt;p&gt;这道题还是想了有一点时间，最开始是想用栈，但是感觉怎么用都不太对，后面才开始想用递归的方法。&lt;/p&gt;

&lt;p&gt;递归的核心其实就是把问题的规模变小，并且要有一个最终的停止条件。对一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;来说，假设其输入是字符串以及起始位置&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;(范围为&lt;code class=&quot;highlighter-rouge&quot;&gt;[start, end)&lt;/code&gt;)，显然终止条件有:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;end - start &amp;lt; 2&lt;/code&gt;, 此时值为0&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s[start]s[end - 1] == &quot;()&quot;&lt;/code&gt;,此时值为1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不是上面这两种情况，则需要找到当前左括号匹配的右括号，如果该右括号不在&lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;处，那么说明后面还有字符串，则需要将两者代表的值相加。否则说明需要将内部的值扩大两倍并缩小范围。哪种情况都需要继续递归。&lt;/p&gt;

&lt;p&gt;递归版的代码见下，用栈的方法留作练习&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func scoreOfParentheses(S string) int {
    return eval(S, 0, len(S))
}

func eval(s string, start, end int) int {
    if end - start &amp;lt; 2 {
        return 0
    }
    
    if end - start == 2 &amp;amp;&amp;amp;s[start] == '(' &amp;amp;&amp;amp; s[end - 1] == ')' {
        return 1
    }
    
    parenthes_num := 1
    i := start + 1
    for ; i &amp;lt; end; i++ {
        if parenthes_num == 0 {
            break;
        }
        if(s[i] == '(') {
            parenthes_num++;
        } else {
            parenthes_num--;
        }
    }
    
    if i == end {
        return 2 * eval(s, start + 1, end - 1)
    }
    return eval(s, start, i) + eval(s, i, end)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given a balanced parentheses string S, compute the score of the string based on the following rule:</summary></entry><entry><title type="html">计算机技术历史 语言(一)</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%80)/" rel="alternate" type="text/html" title="计算机技术历史 语言(一)" /><published>2019-05-03T00:00:00+08:00</published><updated>2019-05-03T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%80)</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%80)/">&lt;p&gt;前段时间想去了解一下计算机技术的发展历史，但是搜了一下没有发现很系统的讲述这方面内容的书或者博客，因此就想自己来调查了解一下，也挺有意思的。&lt;/p&gt;

&lt;p&gt;为什么要关注计算机技术的历史呢？除了兴趣之外，还有一个重要原因是想从历史获取计算机技术发展的主脉络。现在计算机技术发展日新月异，新技术曾出不穷，但不是所有的技术都能留下来，也有些技术是不必要学。想要判断这些东西，就必须得到以往的技术有所了解，找出其中的规律。&lt;/p&gt;

&lt;p&gt;由于计算机技术实在太多了，因此不可能全部涉及。此外，硬件方面的技术门槛较高，我可能也看不懂。基于此，主要还是关注软件技术。&lt;/p&gt;

&lt;p&gt;首先，先从编程语言开始。&lt;/p&gt;

&lt;h2 id=&quot;机器语言&quot;&gt;机器语言&lt;/h2&gt;
&lt;p&gt;机器语言是最早的编程语言，也可以叫做机器码。大约在第一台计算机诞生时，即20世纪50年代左右，机器语言是主要编程语言。&lt;/p&gt;

&lt;p&gt;我们普通人也常常听到计算机其实就是一连串0和1这样的话，0和1其实就是机器语言。计算机接收这些0和1，将0和1组成的串变成硬件上的高低电平，再由高低电平控制机器完成实际动作。由0和1组成的串的集合又叫做指令集，每个计算机厂家的硬件不同，其指令集也不同。&lt;/p&gt;

&lt;p&gt;机器语言的优点就是快，缺点就是不是写给人看的。写机器语言的人必须对于硬件厂家给出的指令集有深厚的了解，才能较好的驾驭机器语言。可是不同的厂家，甚至相同厂家下面的不同型号计算机，只要硬件架构有了一定改动，机器语言也可能随之发生变化，这就造成了其可移植性和重用性都很差的后果。&lt;/p&gt;

&lt;p&gt;如今，已经没有人再用机器语言进行实际编程了。&lt;/p&gt;

&lt;h2 id=&quot;汇编语言&quot;&gt;汇编语言&lt;/h2&gt;
&lt;p&gt;汇编语言在机器语言之后出现，但也是在20世界50年代。汇编语言直到今天还在被使用，主要被用于一些对速度要求高的场合，例如嵌入式系统、驱动程序等。&lt;/p&gt;

&lt;p&gt;汇编语言的出现主要是为了解决机器语言看不懂的缺点。机器语言的一连串0和1简直就是天书，而汇编语言已经开始有自己的语法。汇编语言的使用者对于计算机的体系结构，各个寄存器的作用，程序计数器等要有基本的了解。由于引入了语法，汇编语言需要经过编译器转化为机器语言再交由计算机执行。从这里就可以看出，计算机中引入中间层的观点是很早就有了的。此外，汇编语言的诞生也表明了程序是写给程序员看的，而不是写给机器看的。&lt;/p&gt;

&lt;p&gt;汇编语言的优点是目标代码简短，占用内存少，执行速度快，且比起机器语言来便于记忆。但汇编语言没有解决机器语言无法移植的特点。在不同的机器之间，汇编语言的语法也不相同。另一方面，由于汇编语言直接对寄存器等进行操作，程序的真实意图也被掩盖在细节之中，并且常常需要大量的代码完成简单的工作。最后，汇编语言也很容易产生bug并且难于调试。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">前段时间想去了解一下计算机技术的发展历史，但是搜了一下没有发现很系统的讲述这方面内容的书或者博客，因此就想自己来调查了解一下，也挺有意思的。</summary></entry><entry><title type="html">Arts Weekfour Vim插件管理 Vundle</title><link href="http://localhost:4000/ARTS-WeekFour-vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-Vundle/" rel="alternate" type="text/html" title="Arts Weekfour Vim插件管理 Vundle" /><published>2019-05-01T00:00:00+08:00</published><updated>2019-05-01T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFour-vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-Vundle</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFour-vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-Vundle/">&lt;p&gt;vim有非常之多的插件，因此需要一个插件管理器来管理这些插件。而Vundle就是这一利器。&lt;/p&gt;

&lt;p&gt;Vundle是vim bundle的缩写。它能自动跟踪&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中的插件，安装、更新、卸载插件。Vundle自动管理插件的运行时目录并会在安装和更新后自动重新生成帮助tag。&lt;/p&gt;

&lt;h2 id=&quot;vundle的安装设置&quot;&gt;Vundle的安装设置：&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;首先输入&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone https://github.com/VundleVim/Vundle.vim.git ~/vim/bundle/Vundle.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;将下列内容保存到~/.vimrc中&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set nocompatible              &quot; be iMproved, required
filetype off                  &quot; required

&quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&quot; alternatively, pass a path where Vundle should install plugins
&quot;call vundle#begin('~/some/path/here')

&quot; let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

&quot; The following are examples of different formats supported.
&quot; Keep Plugin commands between vundle#begin/end.
&quot; plugin on GitHub repo
Plugin 'tpope/vim-fugitive'
&quot; plugin from http://vim-scripts.org/vim/scripts.html
Plugin 'L9'
&quot; Git plugin not hosted on GitHub
Plugin 'git://git.wincent.com/command-t.git'
&quot; git repos on your local machine (i.e. when working on your own plugin)
Plugin 'file:///home/gmarik/path/to/plugin'
&quot; The sparkup vim script is in a subdirectory of this repo called vim.
&quot; Pass the path to set the runtimepath properly.
Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
&quot; Avoid a name conflict with L9
Plugin 'user/L9', {'name': 'newL9'}

&quot; All of your Plugins must be added before the following line
call vundle#end()            &quot; required
filetype plugin indent on    &quot; required
&quot; To ignore plugin indent changes, instead use:
&quot;filetype plugin on
&quot;
&quot; Brief help
&quot; :PluginList          - list configured plugins
&quot; :PluginInstall(!)    - install (update) plugins
&quot; :PluginSearch(!) foo - search (or refresh cache first) for foo
&quot; :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins
&quot;
&quot; see :h vundle for more details or wiki for FAQ
&quot; Put your non-Plugin stuff after this line
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;安装配置好的bundle:打开vim并输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginInstall&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;插件&quot;&gt;插件&lt;/h2&gt;
&lt;h3 id=&quot;配置插件&quot;&gt;配置插件&lt;/h3&gt;
&lt;p&gt;Vundle跟踪&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令。每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令让Vundle使能脚本并将其加入|runtimepath|中。&lt;/p&gt;

&lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令有一个指向脚本的URI。在URI后面可选择接受第二个参数。这个参数必须是一个目录。每个键值对都是一个配置选项。&lt;/p&gt;

&lt;p&gt;下面是一些配置选项&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;‘rtp’:设置repo中的一个目录为vim插件所在目录。该目录将被加入|runtimepath|中&lt;/li&gt;
  &lt;li&gt;‘name’:将放置配置脚本的本地拷贝的目录名字&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;支持的uri&quot;&gt;支持的URI&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Github:当user/repo被传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;时Github被使用,例如&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'VundleVim/Vundle.vim' =&amp;gt; https://github.com/VundleVim/Vundle.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Vim Scripts:没有’/’的单词都被认为从Vim Scripts中获取&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'ctrlp.vim' =&amp;gt; https://github.com/vim-scripts/ctrlp.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;本地插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'file:///path/from/root/to/plugin'&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;基本使用方式&quot;&gt;基本使用方式&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginInstall&lt;/code&gt; 安装&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中配置的所有插件，也可以在后面跟上插件名特定安装&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginUpdate&lt;/code&gt; 更新插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginSearch&lt;/code&gt; 需要有&lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;,搜索指定插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginList&lt;/code&gt; 列举已经安装的插件列表&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginClean&lt;/code&gt; 清除不在&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;而在安装目录下的插件&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">vim有非常之多的插件，因此需要一个插件管理器来管理这些插件。而Vundle就是这一利器。</summary></entry></feed>