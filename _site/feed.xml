<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-04-16T20:15:55+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tonfeiz’s Blog</title><subtitle></subtitle><author><name>Tonfeiz</name></author><entry><title type="html">Arts Vim进阶</title><link href="http://localhost:4000/ARTS-vim%E8%BF%9B%E9%98%B6/" rel="alternate" type="text/html" title="Arts Vim进阶" /><published>2019-04-16T00:00:00+08:00</published><updated>2019-04-16T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-vim%E8%BF%9B%E9%98%B6</id><content type="html" xml:base="http://localhost:4000/ARTS-vim%E8%BF%9B%E9%98%B6/">&lt;p&gt;上周开了vim的坑，因此决心干脆尽量把vim的大部分常用内容都记录下来，便于以后翻阅。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;^ -&amp;gt; 到本行第一个不是blank字符的位置&lt;/li&gt;
  &lt;li&gt;g_ -&amp;gt; 到本行最后一个不是blank字符的位置&lt;/li&gt;
  &lt;li&gt;:e &amp;lt;path/to/file&amp;gt; -&amp;gt; 打开一个文件&lt;/li&gt;
  &lt;li&gt;:saveas &amp;lt;path/to/file&amp;gt; -&amp;gt; 另存为&amp;lt;path/to/file&amp;gt;&lt;/li&gt;
  &lt;li&gt;:bn和:bp -&amp;gt; 同时打开多个文件时，使用这两个命令切换上一个和下一个文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; -&amp;gt; 可以重复上一次的命令&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;N&amp;lt;command&amp;gt;&lt;/code&gt; -&amp;gt; 重复某个命令N次&lt;/li&gt;
  &lt;li&gt;*和# -&amp;gt; 匹配光标当前所在的单词，移动光标到下一个或上一个匹配单词&lt;/li&gt;
  &lt;li&gt;很多命令可以以下面的形式来干&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;start position&amp;gt;&amp;lt;command&amp;gt;&amp;lt;end position&amp;gt;&lt;/code&gt;&lt;br /&gt;
例如&lt;code class=&quot;highlighter-rouge&quot;&gt;0y$&lt;/code&gt;意味着：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; -&amp;gt; 到行头&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; -&amp;gt; 拷贝&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; -&amp;gt; 到本行最后一个字符&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gU&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;gu&lt;/code&gt;后跟位置(例如w，e，$等)变换大小写&lt;/li&gt;
  &lt;li&gt;在当前行上，&lt;code class=&quot;highlighter-rouge&quot;&gt;fa&lt;/code&gt;可以到下一个字符为a的位置处，a可变。ta可以到a前的第一个字符，a可变。这两者前可加数字&lt;/li&gt;
  &lt;li&gt;区域选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;action&amp;gt;a&amp;lt;object&amp;gt;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;action&amp;gt;i&amp;lt;object&amp;gt;&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt;可以是任何命令，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;等&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;可以是&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;(单词),&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;(句子),&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;(段落)，或者是特别字符:&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;&lt;br /&gt;
举例来说，字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;(haha (-) (&quot;tfz&quot;))&lt;/code&gt;.光标在f位置
        &lt;blockquote&gt;
          &lt;ul&gt;
            &lt;li&gt;vi” -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;tfz&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;va” -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;tfz&quot;&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;vi) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;tfz&quot;&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;va) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;(&quot;tfz&quot;)&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;v2i) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;haha (-) (&quot;tfz&quot;)&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;v2a) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;(haha (-) (&quot;tfz&quot;))&lt;/code&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;块操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-v&amp;gt; &amp;lt;move&amp;gt; &amp;lt;motion&amp;gt; [ESC]&lt;/code&gt;&lt;br /&gt;
一般都用于插入，举例来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-v&amp;gt; 向下移动 I-- [ESC]&lt;/code&gt;为在同一位置前方插入&lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;字符&lt;/li&gt;
  &lt;li&gt;Insert模式下按&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;或是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;可以自动补全&lt;/li&gt;
  &lt;li&gt;宏录制
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;qa&lt;/code&gt;把操作记录在寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@a&lt;/code&gt;会replay被录制的宏&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@@&lt;/code&gt;会replay最新录制的宏&lt;br /&gt;
例如：在一行只有”1”的文本中，键入下面的命令:&lt;/li&gt;
      &lt;li&gt;qayyp&lt;C-a&gt;q -&amp;gt;&lt;/C-a&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;qa开始录制&lt;/li&gt;
      &lt;li&gt;yyp复制并粘贴当前行&lt;/li&gt;
      &lt;li&gt;
        &lt;C-a&gt;增加1  
&lt;/C-a&gt;
      &lt;/li&gt;
      &lt;li&gt;q停止录制&lt;br /&gt;
      * @a -&amp;gt; 在1下面写下2&lt;br /&gt;
      * @@ -&amp;gt; 在2下面写下3&lt;br /&gt;
      * 100@@ -&amp;gt; 创建新的100行，并把数据增加到103&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;块操作，当目标块被选中后，可以有如下操作：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt; -&amp;gt; 把所有的行连接起来变成一行&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; -&amp;gt; 左右缩进&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; -&amp;gt; 自动缩进&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分屏，&lt;code class=&quot;highlighter-rouge&quot;&gt;:split&lt;/code&gt;水平分屏，&lt;code class=&quot;highlighter-rouge&quot;&gt;vsplit&lt;/code&gt;垂直分屏, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-w&amp;gt;&amp;lt;direction(可以是hjkl)&amp;gt;&lt;/code&gt;切换分屏&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;资料来源&quot;&gt;资料来源&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/5426.html&quot;&gt;简明vim练级攻略&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Tonfeiz</name></author><summary type="html">上周开了vim的坑，因此决心干脆尽量把vim的大部分常用内容都记录下来，便于以后翻阅。</summary></entry><entry><title type="html">Arts Weektwo Leetcode704 Binarysearch</title><link href="http://localhost:4000/ARTS-WeekTwo-Leetcode704-BinarySearch/" rel="alternate" type="text/html" title="Arts Weektwo Leetcode704 Binarysearch" /><published>2019-04-15T00:00:00+08:00</published><updated>2019-04-15T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekTwo-Leetcode704-BinarySearch</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekTwo-Leetcode704-BinarySearch/">&lt;p&gt;Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.&lt;/p&gt;

&lt;p&gt;You may assume that all elements in nums are unique.
n will be in the range [1, 10000].
The value of each element in nums will be in the range [-9999, 9999].&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题其实就是一个简单的二分搜索，数组中的元素都是唯一的，且数值也不大，难怪会被分到简单题里&lt;/p&gt;

&lt;p&gt;二分搜索很有名，要实现一个完全正确的二分搜索是很困难的，但这题的要求并不高。基本思想就是每次寻找中间元素并根据中间元素与目标元素的大小判断下一个搜索范围应该在哪一侧&lt;/p&gt;

&lt;p&gt;二分搜索时，左侧和右侧的范围应当界定明确。在下面的代码中，采用的范围是C++中的通用范围，即[left, right)。因此，循环的推出条件就是两者相等。当缩小范围时，要根据上面的关系选择是中间元素还是中间元素的两侧元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func search(nums []int, target int) int {
    left := 0
    right := len(nums)
    
    res := -1;
    for left &amp;lt; right {
        middle := left + (right - left) / 2;
        if(nums[middle] &amp;gt; target) {
            right = middle;
        } else if(nums[middle] &amp;lt; target) {
            left = middle + 1;
        } else {
            return middle;
        }
    }
    
    return res;   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.</summary></entry><entry><title type="html">Arts Weektwo Twelve Factor(二)</title><link href="http://localhost:4000/ARTS-WeekTwo-Twelve-Factor(%E4%BA%8C)/" rel="alternate" type="text/html" title="Arts Weektwo Twelve Factor(二)" /><published>2019-04-15T00:00:00+08:00</published><updated>2019-04-15T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekTwo-Twelve-Factor(%E4%BA%8C)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekTwo-Twelve-Factor(%E4%BA%8C)/">&lt;p&gt;Twelve Factor Part Two&lt;br /&gt;
Backing services&lt;br /&gt;
Build, release and run&lt;br /&gt;
processes&lt;br /&gt;
&amp;lt;!–more&amp;gt;&lt;/p&gt;

&lt;h2 id=&quot;四支持服务backing-services&quot;&gt;四、支持服务(Backing services)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;backing services&lt;/em&gt;应当被视为附加资源&lt;/p&gt;

&lt;p&gt;&lt;em&gt;backing services&lt;/em&gt;是app通过网络使用的服务，并且这些服务被视为它基本操作的一部分。举例来说，数据存储服务(MySQL等)、消息队列系统(RabbitMQ)和缓存系统(Memcached)都属于这种服务。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;backing services&lt;/em&gt;包括本地管理的服务和第三方服务。本条的要点就在于，不管哪类服务对app来说都应当没有区别，都被看作附加资源，都可以通过URL或者配置中的locator/credential访问。&lt;/p&gt;

&lt;p&gt;对于app来说，一个&lt;em&gt;backing services&lt;/em&gt;应当和另一个同样功能的&lt;em&gt;backing services&lt;/em&gt;完成无缝替换——不需要更改任何代码。这就是因为把它们看作附加资源而使其变成松耦合带来的好处&lt;/p&gt;

&lt;h2 id=&quot;五构建发行和运行&quot;&gt;五、构建、发行和运行&lt;/h2&gt;
&lt;p&gt;严格的区分构建和运行阶段&lt;/p&gt;

&lt;p&gt;一个&lt;em&gt;codebase&lt;/em&gt;通过下面三个阶段被转换为一个部署：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;构建阶段将代码转换成一批可执行文件。构建阶段获取提供者的依赖并编译二进制文件和资源&lt;/li&gt;
  &lt;li&gt;发行阶段将构建完成的东西和部署当前的配置结合起来。发行阶段完成的东西随时可以在执行环境中运行&lt;/li&gt;
  &lt;li&gt;运行阶段在执行环境中运行，启动app的一些进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;twelve-factor app严格的区分上面这三个阶段，这样就不能对运行阶段的代码作任何修改，也可以方便的回滚到上一个发行版本。每个发行版本应该有一个独一无二的ID作为标识。任何发行版本都不应该被改动，想要改动则需要新的发行版本&lt;/p&gt;

&lt;p&gt;运行时可执行文件应当自动在任何场合(如服务器重启，进程崩溃后重启)自动执行。&lt;/p&gt;

&lt;h2 id=&quot;六进程&quot;&gt;六、进程&lt;/h2&gt;
&lt;p&gt;将app作为一个或多个无状态进程执行&lt;/p&gt;

&lt;p&gt;进程应当是无状态的，不共享任何东西。需要持久化的数据应当被存在一个有状态的&lt;em&gt;backing service&lt;/em&gt;中，通常是一个数据库&lt;/p&gt;

&lt;p&gt;进程的内存空间或者文件系统可以被作为一个简短的，单个的事务(transaction)缓存处理。twelve-factor app从不假设在内存或是磁盘上缓存的东西在未来的请求或是工作中会是有效的——有多种情况会导致它们是失效的或被清除。  、&lt;/p&gt;

&lt;p&gt;sticky session将用户的session数据保存在app的进程内存中并期望从相同的访问者来的请求被路由到同样的进程。这是对本准则的违反，不应当被使用。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Twelve Factor Part Two Backing services Build, release and run processes</summary></entry><entry><title type="html">Arts Weekone Vimtutor总结</title><link href="http://localhost:4000/ARTS-WeekOne-vimtutor%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="Arts Weekone Vimtutor总结" /><published>2019-04-14T00:00:00+08:00</published><updated>2019-04-14T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekOne-vimtutor%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekOne-vimtutor%E6%80%BB%E7%BB%93/">&lt;p&gt;虽然一直在使用vim编辑器，但其实一直没有练习过。借着ARTS中T的名头，就稍微学习一下vimtutor并将其中的总结放在这。&lt;/p&gt;

&lt;h2 id=&quot;一&quot;&gt;一&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用h，j，k，l作为vim中光标的移动键(比上下左右要有效率的多)。&lt;/li&gt;
  &lt;li&gt;使用:q!(&lt;code class=&quot;highlighter-rouge&quot;&gt;quit!&lt;/code&gt;)强制退出当前正在编辑的文件&lt;/li&gt;
  &lt;li&gt;使用x删除当前光标停留处的文字&lt;/li&gt;
  &lt;li&gt;使用i(&lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;)在当前光标位置处插入内容&lt;/li&gt;
  &lt;li&gt;使用A(&lt;code class=&quot;highlighter-rouge&quot;&gt;Append&lt;/code&gt;)在当前最后一行处添加内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二&quot;&gt;二&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用dw(&lt;code class=&quot;highlighter-rouge&quot;&gt;delete word&lt;/code&gt;)来删除当前光标处的一个单词&lt;/li&gt;
  &lt;li&gt;使用d$删除当前位置到行末的所有内容&lt;/li&gt;
  &lt;li&gt;许多改变文本的命令都由一个&lt;code class=&quot;highlighter-rouge&quot;&gt;operator&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;组成，例如d代表删除&lt;code class=&quot;highlighter-rouge&quot;&gt;operator&lt;/code&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;可以有如下选择：
    &lt;ul&gt;
      &lt;li&gt;w：直到下一个单词的起始位置，不包括该起始位置&lt;/li&gt;
      &lt;li&gt;e: 直到当前单词的结束位置，包括该结束位置&lt;/li&gt;
      &lt;li&gt;$: 直到当前行的结尾，包括最后一个单词&lt;br /&gt;
 如果只按上述&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;则可以让光标按&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;移动&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;前面可以使用数字进行对多个&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;的操作&lt;/li&gt;
  &lt;li&gt;使用0到一行的起始位置处&lt;/li&gt;
  &lt;li&gt;使用dd删除一整行数据&lt;/li&gt;
  &lt;li&gt;使用u来撤销上一个操作，U来修复一整行的操作，CTRL-R来撤销撤销操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三&quot;&gt;三&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用p(&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;paste&lt;/code&gt;)来放置vim寄存器中的文本数据(可通过dd，d，yy等操作得到)&lt;/li&gt;
  &lt;li&gt;使用r(&lt;code class=&quot;highlighter-rouge&quot;&gt;replace&lt;/code&gt;)来替换当前光标处的文本&lt;/li&gt;
  &lt;li&gt;使用c(&lt;code class=&quot;highlighter-rouge&quot;&gt;change&lt;/code&gt;)+&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;来改变文版，注意按c之后会进入插入模式&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四&quot;&gt;四&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用CTRL-G命令显示当前文件名以及总行数、当前行数&lt;/li&gt;
  &lt;li&gt;使用G(&lt;code class=&quot;highlighter-rouge&quot;&gt;Go&lt;/code&gt;)到当前文件底端，gg到当前文件顶端,[number]G到[number]行&lt;/li&gt;
  &lt;li&gt;使用/[text]搜索和[text]一样的文本，n是前进，N是后退&lt;/li&gt;
  &lt;li&gt;使用%来匹配各种括号&lt;/li&gt;
  &lt;li&gt;使用:s(&lt;code class=&quot;highlighter-rouge&quot;&gt;substitute&lt;/code&gt;)来替进行各种替换&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五&quot;&gt;五&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用:!来执行外部的shell命令，例如:!ls就可以列举目录&lt;/li&gt;
  &lt;li&gt;使用:w(&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;) FILENAME来将当前已经写完的内容写入某个文件&lt;/li&gt;
  &lt;li&gt;使用v(&lt;code class=&quot;highlighter-rouge&quot;&gt;visual&lt;/code&gt;)进入可视化模式，选择部分内容并利用:w来将这些内容写入某个文件&lt;/li&gt;
  &lt;li&gt;使用:r(&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;) FILENAME来将目标文件的内容读入当前正在编辑的文件中(不一定是文件内容，某个命令的输出也可以，感觉和管道或是重定向很像)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;六&quot;&gt;六&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用o来在当前行下面插入一行，使用O来在当前行上面插入一行&lt;/li&gt;
  &lt;li&gt;使用a来在当前光标的下一个位置插入文本&lt;/li&gt;
  &lt;li&gt;使用R来批量替换文本&lt;/li&gt;
  &lt;li&gt;使用y来复制，p来粘贴。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;对我来说，这个教程比较有用的是2.3,4.4和5.5。以后还要多多练习，对这些基本操作更加熟练&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">虽然一直在使用vim编辑器，但其实一直没有练习过。借着ARTS中T的名头，就稍微学习一下vimtutor并将其中的总结放在这。</summary></entry><entry><title type="html">搭建个人博客</title><link href="http://localhost:4000/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="alternate" type="text/html" title="搭建个人博客" /><published>2019-04-12T00:00:00+08:00</published><updated>2019-04-12T00:00:00+08:00</updated><id>http://localhost:4000/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2</id><content type="html" xml:base="http://localhost:4000/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">&lt;p&gt;关于写博客，其实早就想写了。写博客的好处也从各种渠道都听说过，奈何实在是懒。现在由于看到了ARTS，觉得挺有用的，也想养成长期主动学习的习惯，因此就把博客搞起来，作为这个计划的集合地，当然其它想写的时候也会随便写一些文章。&lt;/p&gt;

&lt;p&gt;搭建博客的教程网上有很多，随便找一个基本上就能搭建完成。我也是拼拼凑凑搭出来的，现在也还只是个雏形。这里还是做个记录，毕竟别人的经验始终是别人的，自己写出来的才是自己的。&lt;/p&gt;

&lt;h2 id=&quot;一利用github-pages托管网站&quot;&gt;一、利用github pages托管网站&lt;/h2&gt;
&lt;p&gt;搭建自己的博客首先得有自己的网站，要有自己的网站首先得有服务器主机来维护它，作为非土豪人士，自己买服务器托管网站这种事是干不出来的。因此，可以使用github pages来托管自己的网站。&lt;/p&gt;

&lt;p&gt;github pages是一个静态站点服务，主要就用来直接从github repo生成网站。因为之前一直也用github，因此一些基本操作也是轻车熟路了，使用它也是基于这个考虑。&lt;/p&gt;

&lt;p&gt;github pages也有一些缺陷，这里简单的列举几点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;它是静态站点服务，不支持服务端代码，例如PHP，Ruby或者Python&lt;/li&gt;
  &lt;li&gt;github pages所在的repo最好不要超过1GB&lt;/li&gt;
  &lt;li&gt;发布的github pages网站不能超过1GB&lt;/li&gt;
  &lt;li&gt;github pages站点的软带宽每个月不超过100GB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一般的个人博客网站来说，这些限制应该问题不大。&lt;/p&gt;

&lt;p&gt;接下去说说具体的流程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在github上创建一个repo，这个repo的名字必须是&lt;em&gt;username&lt;/em&gt;.github.io,其中&lt;em&gt;username&lt;/em&gt;就是你在github上的用户名&lt;/li&gt;
  &lt;li&gt;选择一个文件夹作为github repo的存放地，例如就在$HOME目录下，在终端下输入下面的命令：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone https://github.com/username/username.github.io&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;进入上面的文件夹，创建一个index.html文件。命令如下：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd username.github.io&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;Hello World&quot; &amp;gt; index.html&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;将改变上传到github端。命令如下：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git add -all&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &quot;Initial commit&quot;&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git push -u origin master&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，网站就可以查看了。可以在浏览器中输入&lt;br /&gt;
&lt;strong&gt;https://&lt;em&gt;username&lt;/em&gt;.github.io&lt;/strong&gt;&lt;br /&gt;
查看自己的网站&lt;/p&gt;
&lt;h2 id=&quot;二利用jkeyll编辑自己的博客&quot;&gt;二、利用jkeyll编辑自己的博客&lt;/h2&gt;
&lt;p&gt;有了github pages托管网站之后，接下去就是要将网站变成博客形式了。虽然之前稍微学过一点前端的知识，但要自己从头搭建还是有些困难。在github pages上发现大力推荐的一个静态网页和博客生成框架jekyll，可以直接把markdown格式的文件转化成网页，因此干脆就入坑jekyll了。&lt;/p&gt;

&lt;p&gt;目前我也只是过了两遍jekyll的教程，具体使用还需要摸索，这里就简单的讲一下基础的内容。如果想要详细了解，还是得去&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyll官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;jekyll首先需要安装Ruby的运行环境，在Linux Ubuntu环境下是很简单的，输入下面的命令：
&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install ruby-full build-essential zlib1g-dev&lt;/code&gt;
接着设置一下环境变量&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo '# Install Ruby Gems to ~/gems' &amp;gt;&amp;gt; ~/.bashrc
echo 'export GEM_HOME=&quot;$HOME/gems&quot;' &amp;gt;&amp;gt; ~/.bashrc
echo 'export PATH=&quot;$HOME/gems/bin:$PATH&quot;' &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后，安装jekyll以及bundler插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll bundler&lt;/code&gt;&lt;br /&gt;
至此，jekyll的安装就完成了。&lt;/p&gt;

&lt;p&gt;jekyll的使用也很简单，如果不使用github pages，直接
&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new [foldername]&lt;/code&gt;
其中&lt;code class=&quot;highlighter-rouge&quot;&gt;foldername&lt;/code&gt;就是文件夹名字，jekyll就会在文件夹中生成一个网站的雏形。想要在本地浏览网页只需要&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;就可以在浏览器中输入&lt;a href=&quot;http://127.0.0.1:4000&quot;&gt;http://127.0.0.1:4000&lt;/a&gt;浏览网页的样子了。(注意，这里&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new&lt;/code&gt;可能花费较长时间，其实不用该命令也可以，自己手动建立目录就行了)&lt;/p&gt;

&lt;p&gt;如果使用github pages，也很简单，在之前的第一步生成的github repo里面创建对应目录结构也一样可以浏览。一般的目录结构如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.  
+-- _site  
+-- _layouts  
|   +--  default.html  
|   +--  post.html  
+-- _posts  
|   +-- 2019-11-11-new-post.md  
|   +-- 2019-1-1-old-post.md  
+-- _data  
+-- _includes  
+-- assets  
|   +-- css  
|   +-- images  
|   +-- js  
+-- _sass  
+-- _config.yml  
+-- index.html  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中,_layouts目录放置的是网页文件的布局样式，_posts目录放置的是博客文章(注意，文件名字必须是yyyy-mm-dd-&lt;em&gt;article_title&lt;/em&gt;样式的)，_includes目录放置的是导入文件，assets目录放置的是资源文件，包括css和js等。_config.yml是配置文件，index.html则是网页文件。&lt;/p&gt;

&lt;p&gt;在github pages上还可以直接使用jekyll的主题，虽然主题不多，但暂时可以将就着用，后期再自己改进。&lt;/p&gt;

&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;博客搭建的过程到这里算是暂时结束了，后期还需要对jekyll作进一步的深入了解以调整自己的博客。目前暂时就先这样吧。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">关于写博客，其实早就想写了。写博客的好处也从各种渠道都听说过，奈何实在是懒。现在由于看到了ARTS，觉得挺有用的，也想养成长期主动学习的习惯，因此就把博客搞起来，作为这个计划的集合地，当然其它想写的时候也会随便写一些文章。</summary></entry><entry><title type="html">Arts Weekone Twelve Factor(一)</title><link href="http://localhost:4000/ARTS-WeekOne-Twelve-Factor(%E4%B8%80)/" rel="alternate" type="text/html" title="Arts Weekone Twelve Factor(一)" /><published>2019-04-11T00:00:00+08:00</published><updated>2019-04-11T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekOne-Twelve-Factor(%E4%B8%80)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekOne-Twelve-Factor(%E4%B8%80)/">&lt;p&gt;Twelve-Factor指的是构建Saas的应用程序应当满足的12个特性。&lt;/p&gt;

&lt;p&gt;这些应用程序具备的特点包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用声明式方法(declarative formats)来自动化设置，以此最小化新的成员加入工程的时间和花费&lt;/li&gt;
  &lt;li&gt;与底层的操作系统之间有明确的协议，以此最大化不同执行环境之间的可移植性&lt;/li&gt;
  &lt;li&gt;适合于部署在现代云平台上，避免了服务器和系统管理员的需要&lt;/li&gt;
  &lt;li&gt;最小化开发环境(development)和生产环境(production)之间的分歧，为了最大化灵活性使用持续部署&lt;/li&gt;
  &lt;li&gt;能够在不显著改变工具、架构或者开发实践的基础上自由扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面有一些名词是我暂时还不太理解的，这里做个简单的解释。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;声明式方法：倾向于直接告诉计算机做什么，而不是告诉计算机怎么做的方法。具体可见&lt;a href=&quot;https://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarative programming&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;持续部署：和持续部署相关的概念还有持续集成和持续交付。持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地集成在一起。持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（production-like environments）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续手动部署到生产环境中。持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。(引自知乎yumminhuang)&lt;/li&gt;
  &lt;li&gt;生产环境、开发环境：软件应用开发的几个环境包括：开发环境(development)，集成环境(integration)、测试环境(testing)、QA验证、模拟环境(staging)、生产环境(production)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本是打算一次性把这12个特性都叙述一遍，但发现其中涉及到许多自己不知道的东西，因此决定还是分批来，本周先仔细看3个特性。&lt;/p&gt;

&lt;h2 id=&quot;一基准代码codebase&quot;&gt;一、基准代码(codebase)&lt;/h2&gt;
&lt;p&gt;这一特性用一句话说就是，只有一个用版本控制系统跟踪的代码库，但可以有许多部署(deploy)&lt;/p&gt;

&lt;p&gt;在中心化的版本管理系统中，一个&lt;em&gt;codebase&lt;/em&gt;就是单个的代码库。在去中心化的版本管理系统中，一个&lt;em&gt;codebase&lt;/em&gt;就是共享一个根提交(root commit)的代码库&lt;/p&gt;

&lt;p&gt;需要注意的是，在&lt;em&gt;codebase&lt;/em&gt;和app之间永远是一对一的关系，如果有多个&lt;em&gt;codebase&lt;/em&gt;，那就不是一个app，而是一个分布式系统，其中的每个组件都应当是一个满足twelve-factor的app。&lt;/p&gt;

&lt;p&gt;然而，一个app可以有多个部署。例如在生产环境中的部署，在每个开发环境上的部署等。&lt;/p&gt;

&lt;p&gt;不同部署的&lt;em&gt;codebase&lt;/em&gt;是相同的，但是每个活跃的部署可以是不同的版本。&lt;/p&gt;

&lt;h2 id=&quot;二依赖&quot;&gt;二、依赖&lt;/h2&gt;
&lt;p&gt;这一特性用一句话说就是，显示的声明依赖并隔离它们&lt;/p&gt;

&lt;p&gt;这一章读的还不太懂，可能是自身还缺乏关于微服务方面的知识的原因。&lt;/p&gt;

&lt;p&gt;一个满足这一特性的app绝不会依赖于隐式的系统级别的库。它会使用依赖清单来显式声明自己所依赖的所有依赖项，并且会在执行期间使用依赖隔离工具来防止外界系统的隐式依赖泄漏&lt;strong&gt;进来&lt;/strong&gt;(leak in)。对Ruby来说，依赖清单就是&lt;code class=&quot;highlighter-rouge&quot;&gt;Gemfile&lt;/code&gt;，依赖隔离工具就是&lt;code class=&quot;highlighter-rouge&quot;&gt;bundle exec&lt;/code&gt;。对Python来说，依赖清单就是&lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt;，依赖隔离工具就是&lt;code class=&quot;highlighter-rouge&quot;&gt;virtualenv&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这么做的一个优势就是对于新来的开发者来说，他只需要安装语言运行时环境以及依赖管理工具就可以进行app的开发。&lt;/p&gt;

&lt;p&gt;twelve-factor app也不会隐式的依赖任何系统工具，即便这些工具在大部分操作系统上都存在，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;三配置&quot;&gt;三、配置&lt;/h2&gt;
&lt;p&gt;将配置存在环境中&lt;/p&gt;

&lt;p&gt;一个app的配置是在不同的部署中不同的东西。有些app将这些配置直接硬编码到代码中，这是违反twelve-factor的。配置应该从代码中严格的分离开来。当然对于内在的配置，即在不同部署中相同的配置，可以直接硬编码。&lt;/p&gt;

&lt;p&gt;一种配置方法是使用配置文件。配置文件不应当被放入版本控制系统中，但这一点容易被忽略，而且大多配置文件往往基于特定的语言或是框架。&lt;/p&gt;

&lt;p&gt;twelve-factor app将配置存在环境变量中。注意，使用组合的环境变量会使app失去可扩展性(组合的环境变量存疑)，最好还是将每个环境变量单独使用。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Twelve-Factor指的是构建Saas的应用程序应当满足的12个特性。</summary></entry><entry><title type="html">Arts Weekone Leetcode941</title><link href="http://localhost:4000/ARTS-WeekOne-Leetcode941/" rel="alternate" type="text/html" title="Arts Weekone Leetcode941" /><published>2019-04-10T00:00:00+08:00</published><updated>2019-04-10T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekOne-Leetcode941</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekOne-Leetcode941/">&lt;p&gt;Given an array &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; of integers, return &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; if and only if it is a &lt;em&gt;valid mountain array&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Recall that &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; is a mountain array if and only if:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;A.length&lt;/code&gt; &amp;gt;= 3&lt;/li&gt;
  &lt;li&gt;There exists some &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;0 &amp;lt; i &amp;lt; A.length - 1&lt;/code&gt; such that:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i]&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[B.length - 1]&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;这是一道简单题，题意就是判断一个数组是否存在且只存在一个山顶，其实就是判断是否数组是先升后降的，并且不存在相等元素。&lt;/p&gt;

&lt;p&gt;思路很直白，设置一个变量&lt;code class=&quot;highlighter-rouge&quot;&gt;mountain_top&lt;/code&gt;(需初始化为0)，遍历数组，当找到降序后将山顶位置赋值给它，然后继续遍历，若此后出现升序则直接返回false。最后，若遍历完成后该变量未被修改，说明不存在山顶(单纯升序则为0,单纯降序也为0)。最后，注意排除相等的情况。&lt;/p&gt;

&lt;p&gt;代码是用go语言写的，如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func validMountainArray(A []int) bool {
    if len(A) &amp;lt; 3 {
        return false
    }
    
    mountain_top := 0
    for i := 0; i &amp;lt; len(A) - 1; i++ {
        if A[i] &amp;gt; A[i + 1] {
            mountain_top = i
            break
        } else if A[i] == A[i + 1] {
            return false;
        }
    }
    for i := mountain_top; i &amp;lt; len(A) - 1; i++ {
        if A[i] &amp;lt;= A[i + 1] {
            return false
        } 
    }
    
    
    return mountain_top != 0
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given an array A of integers, return true if and only if it is a valid mountain array.</summary></entry></feed>