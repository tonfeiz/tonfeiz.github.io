<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-06-02T11:13:51+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tonfeiz’s Blog</title><subtitle></subtitle><author><name>Tonfeiz</name></author><entry><title type="html">Arts Weekeight Leetcode605 Canplaceflowers</title><link href="http://localhost:4000/ARTS-WeekEight-Leetcode605-CanPlaceFlowers/" rel="alternate" type="text/html" title="Arts Weekeight Leetcode605 Canplaceflowers" /><published>2019-06-02T00:00:00+08:00</published><updated>2019-06-02T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekEight-Leetcode605-CanPlaceFlowers</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekEight-Leetcode605-CanPlaceFlowers/">&lt;p&gt;Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.&lt;/p&gt;

&lt;p&gt;Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: flowerbed = [1,0,0,0,1], n = 1
Output: True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: flowerbed = [1,0,0,0,1], n = 2
Output: False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;这题的意思是在一串0和1组成的数组中，0表示可以放置花的位置，1表示已经有花的位置，花与花不能相邻，则判断给定数能否放下。&lt;/p&gt;

&lt;p&gt;最开始直接采用了模拟的方法，考虑了多种情况，写出的代码较复杂，放在后面仅做参考。后来仔细思考后发现其实就是贪心算法。对于数组两侧为0的情况，则在两侧放置为1肯定是最优解。接下来遍历数组，碰到0则判断是否能放，能放则放，不能放则继续，如此就能得到最多能放下的花数。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func canPlaceFlowers(flowerbed []int, n int) bool {

    res := 0
    length := len(flowerbed)
    if length == 1 {
        if flowerbed[0] == 0 {
            return n &amp;lt;= 1
        } else {
            return n == 0
        }
    }
    
    if flowerbed[0] == 0 &amp;amp;&amp;amp; flowerbed[1] == 0 {
        flowerbed[0] = 1
        res++;
    }
    if flowerbed[length - 1] == 0 &amp;amp;&amp;amp; flowerbed[length - 2] == 0 {
        flowerbed[length - 1] = 1
        res++
    }
    
    for i := 1; i &amp;lt; length - 1; i++ {
        if(flowerbed[i] == 0 &amp;amp;&amp;amp; flowerbed[i - 1] == 0 &amp;amp;&amp;amp; flowerbed[i + 1] == 0) {
            res++
            flowerbed[i] = 1
        }
    }
    
    return res &amp;gt;= n
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一种想法的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func canPlaceFlowers(flowerbed []int, n int) bool {

    left_start := 0
    right_end := len(flowerbed) - 1

    for left_start &amp;lt;= right_end &amp;amp;&amp;amp; flowerbed[left_start] == 0  {
        left_start++;
    }
    for right_end &amp;gt;= left_start &amp;amp;&amp;amp; flowerbed[right_end] == 0 {
        right_end--;
    }

    if left_start &amp;gt;= right_end {
        if len(flowerbed) == 1 {
            if(flowerbed[0] == 1 &amp;amp;&amp;amp; n &amp;gt;= 1) {
                return false
            } else {
                return n &amp;lt;= 1
            }
        }
        if left_start == len(flowerbed) {
            return ((left_start + 1) / 2) &amp;gt;= n
        } else {
            return (left_start / 2 + (len(flowerbed) - 1 - right_end) / 2) &amp;gt;= n
        }
    }

    res := 0
    current_start := left_start
    for i := left_start + 1; i &amp;lt;= right_end; i++ {
        if flowerbed[i] == 1 {
            res += (i - current_start - 2) / 2
            current_start = i
        }
    }

    return (res + left_start  / 2 + (len(flowerbed) - 1 - right_end) / 2) &amp;gt;= n
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</summary></entry><entry><title type="html">Arts Weekseven Design Restful Api(一)</title><link href="http://localhost:4000/ARTS-WeekSeven-Design-RESTful-API(%E4%B8%80)/" rel="alternate" type="text/html" title="Arts Weekseven Design Restful Api(一)" /><published>2019-05-26T00:00:00+08:00</published><updated>2019-05-26T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekSeven-Design-RESTful-API(%E4%B8%80)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekSeven-Design-RESTful-API(%E4%B8%80)/">&lt;p&gt;Best Practice for Designing a Pragmatic RESTful API&lt;/p&gt;

&lt;h2 id=&quot;key-requirements-for-the-api&quot;&gt;Key requirements for the API&lt;/h2&gt;
&lt;p&gt;列举了一些API的需求：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;应当在有意义的地方使用web标准&lt;/li&gt;
  &lt;li&gt;它应当对开发者友好并且可以通过浏览器地址栏探索&lt;/li&gt;
  &lt;li&gt;它应当是简单的，符合直觉的&lt;/li&gt;
  &lt;li&gt;它应当提供足够的灵活性&lt;/li&gt;
  &lt;li&gt;在维持其他需求的同时，它应当是有效的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;use-restful-urls-and-actions&quot;&gt;Use RESTful URLS and actions&lt;/h2&gt;
&lt;p&gt;RESTful原则是被广泛采用的原则。REST的关键原则是将API分成逻辑资源。这些资源通过HTTP请求来操纵。HTTP中的方法具有特殊的意义(GET,POST,PUT,PATCH,DELETE)。&lt;/p&gt;

&lt;p&gt;API设计的一大关键是不要把实现细节暴露给API。&lt;/p&gt;

&lt;p&gt;当把资源定义好之后，你需要识别出可以对它们应用的动作(actions)以及它们如何映射到自己的API。RESTful原则提供使用HTTP方法来处理CRUD动作的策略。这些HTTP方法被映射为：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GET /tickets&lt;/code&gt; - 获取tickets列表&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GET /tickets/12&lt;/code&gt; - 获取一个特定的ticket&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;POST /tickets&lt;/code&gt; - 创造一个新的ticket&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PUT /tickets/12&lt;/code&gt; - 更新#12 ticket&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PATCH /tickets/12&lt;/code&gt; - 部分更新#12 ticket&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE /tickets/12&lt;/code&gt; - 删除#12 ticket&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;REST的好处在于在单个端点&lt;code class=&quot;highlighter-rouge&quot;&gt;/tickets&lt;/code&gt;上使用已存在的HTTP方法完成了至关重要的功能。没有方法命名规范需要遵循并且URL结构干净清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;端点名字应当是单数还是复数？&lt;/strong&gt;keep-it-simple规则可以应用在这里。虽然内在逻辑可能是单数，但是工程上考虑需要将URL格式一致并且总是使用复数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何处理关系？&lt;/strong&gt;如果一个关系只能和其他资源共存，RESTful原则提供了有用的指导。例如，一个ticket由许多message组成。这些message可以被映射到&lt;code class=&quot;highlighter-rouge&quot;&gt;/tickets&lt;/code&gt;端点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GET /tickets/12/messages&lt;/code&gt; - 获取#12 ticket的消息列表&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;GET /tickets/12/messages/5&lt;/code&gt; - 获取ticket #12的第5条消息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;POST /tickets/12/messages&lt;/code&gt; - 为ticket #12创建一个新消息&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果一个关系能独立于资源存在，那么在资源的输出表达中包括该标识符是有意义的。然后API使用者就不得不到达关系的端点。然而，如果该关系通常和资源一起使用，则API能将关系表达嵌入到API中来避免第二次hit。(这里很难翻译。。)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不能用CRUD操作表达的动作怎么办？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是事情变得复杂的地方。有许多方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;重新结构化动作使其表现的像是资源的一个域。如果该动作不接收参数则这是可以工作的。例如，激活动作可以被映射为布尔值&lt;code class=&quot;highlighter-rouge&quot;&gt;activated&lt;/code&gt;然后通过到资源的PATCH更新&lt;/li&gt;
  &lt;li&gt;使用RESTful原则将它作为子资源对待。例如，GitHub的API允许你使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PUT /gists/:id/star&lt;/code&gt;对gist打星，并且使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE /gists/:id/star&lt;/code&gt;取消打星&lt;/li&gt;
  &lt;li&gt;有时候确实不能将动作映射到有意义的RESTful架构。例如，一个多资源的搜索不能有意义的用到一个特定资源的端点。在这种情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;/search&lt;/code&gt;是可以的，虽然它不是一个资源。做从API使用者角度来看是对的事情并及早文档化以避免误解&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ssl-everywhere---all-the-time&quot;&gt;SSL everywhere - all the time&lt;/h2&gt;
&lt;p&gt;总是使用SSL，没有例外。今天，web API能够从各个地方被获取。不是所有的地方都是安全的。许多完全不加密通信，使得认证证书被劫持后信息被偷听或身份被冒充。&lt;/p&gt;

&lt;p&gt;总是使用SSL的另一个好处是保证加密过的通信简化了认证&lt;/p&gt;

&lt;p&gt;需要注意的是对API URL的无SSL请求。不要把它们重定向的SSL的版本，而是要抛出一个硬错误！&lt;/p&gt;

&lt;h2 id=&quot;documentation&quot;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;一个API最多和它的文档一样好。文档应当便于获取并且是公共的。大多数开发者在使用API之前会检查文档。如果文档被隐藏在PDF文件中或者需要登录才能获取，则它们不仅难于找到且难于搜索到&lt;/p&gt;

&lt;p&gt;文档应当展示完整的请求/回应循环的例子。最好请求是可以粘贴的例子——要不是可以粘贴到浏览器的链接，要不是可以粘贴到终端中的curl例子。&lt;/p&gt;

&lt;p&gt;一旦发布了一个公共API，则你就承诺了不会无通知的破坏它。文档必须包含任何过时的东西。更新应当通过博客或是邮件列表发送。&lt;/p&gt;

&lt;h2 id=&quot;versioning&quot;&gt;Versioning&lt;/h2&gt;
&lt;p&gt;总是将你的API标识上版本号。这样帮助你更快的迭代并且阻止无效的请求到达更新过的端点。它也帮助平滑了主要API版本的转换，你可以继续提供旧API版本一段时间。&lt;/p&gt;

&lt;p&gt;对于版本号应当在URL还是在首部中有不同的观点。学术上来说，它应当在首部中。然而，版本号应当在URL中来确保通过探索资源?(翻译有点问题)&lt;/p&gt;

&lt;p&gt;作者比较喜欢的一种做法是URL有一个主要版本号，而API有一个可通过顾客HTTP请求头选择的基于日期的子版本号。在这种情况下，主版本号提供了API结构的稳定性，子版本号负责较小的变化。&lt;/p&gt;

&lt;p&gt;API永远不可能是完全稳定的。变化是不可避免的。重要的是变化是怎么被管理的。被较好的文档化和声明的多个月的过时安排可以是一个可接受的选择。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Best Practice for Designing a Pragmatic RESTful API</summary></entry><entry><title type="html">Arts Weekseven Dockerfile Reference</title><link href="http://localhost:4000/ARTS-WeekSeven-Dockerfile-Reference/" rel="alternate" type="text/html" title="Arts Weekseven Dockerfile Reference" /><published>2019-05-26T00:00:00+08:00</published><updated>2019-05-26T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekSeven-Dockerfile-Reference</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekSeven-Dockerfile-Reference/">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt;从一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;和&lt;em&gt;环境(context)&lt;/em&gt;中构建一个镜像。构建的环境是一个指定&lt;code class=&quot;highlighter-rouge&quot;&gt;路径(PATH)&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;处的文件集。&lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt;是本地文件系统的目录，&lt;code class=&quot;highlighter-rouge&quot;&gt;URL&lt;/code&gt;是一个Git库的位置。&lt;/p&gt;

&lt;p&gt;build命令是被Docker守护程序执行的，而不是客户端。build过程的第一步就是把整个上下文(递归的)传送给守护程序。最好的做法是从一个空文件夹作为上下文开始并将Dockerfile保持在该目录中。只把需要build Dockerfile的文件加到目录中。&lt;/p&gt;

&lt;p&gt;可以指定repository以及？&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build -t shykes/myapp .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker守护程序一个一个地执行&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;中的指令，在必要时把指令执行的结果commit到新的镜像中。守护程序将自动清理你传送过去的上下文。&lt;/p&gt;

&lt;h2 id=&quot;格式&quot;&gt;格式&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;的格式为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Comment
INSTRUCTION arguments
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;指令不是大小写敏感的，但传统上均是大写&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;必须以&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt;指令开头。&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt;指令指定了你正在构造的镜像的基本镜像(&lt;em&gt;Base Image&lt;/em&gt;)。&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt;之前只能是&lt;code class=&quot;highlighter-rouge&quot;&gt;ARG&lt;/code&gt;指令，它声明了&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt;要使用的参数&lt;/p&gt;

&lt;h2 id=&quot;from&quot;&gt;FROM&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM &amp;lt;image&amp;gt; [AS &amp;lt;name&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM &amp;lt;image&amp;gt;[:&amp;lt;tag&amp;gt;] [AS &amp;lt;name&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM &amp;lt;image&amp;gt;[@&amp;lt;digest&amp;gt;] [AS &amp;lt;name&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt;指令初始化一个新的构建阶段并且为接下来的指令设置了基本镜像。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt;可以在一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;内出现许多次以创建多个镜像或者将一个构建阶段作为另一个构建阶段的依赖。&lt;/li&gt;
  &lt;li&gt;可以通过添加&lt;code class=&quot;highlighter-rouge&quot;&gt;AS name&lt;/code&gt;给一个新的构建阶段命名。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;digest&lt;/code&gt;是可选的。如果忽视它们，builder会默认给一个&lt;code class=&quot;highlighter-rouge&quot;&gt;latest&lt;/code&gt;标志。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;run&quot;&gt;RUN&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;有两种形式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN &amp;lt;command&amp;gt;&lt;/code&gt;(&lt;em&gt;shell&lt;/em&gt;形式，命令在一个shell中执行，Linux中默认是&lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh -c&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt;(&lt;em&gt;exec&lt;/em&gt;形式)&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;执行将在当前镜像的顶部新层次上执行任何命令并提交(commit)结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;分层次的&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;指令和生成的提交(commit)是Docker的核心概念。&lt;/p&gt;

&lt;h2 id=&quot;cmd&quot;&gt;CMD&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;有三种形式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt;(较好的形式)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD [&quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt;(作为&lt;em&gt;ENTRYPOINT&lt;/em&gt;的默认参数)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD command param1 param2&lt;/code&gt;&lt;br /&gt;
一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;中只能有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;指令。如果有多个则只有最后一个起作用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;指令的主要作用是为正在执行的容器提供默认(入口)。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：不要把&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;搞混。&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;会运行一个命令并提交结果。&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;不会在构建时执行任何动作，而是为镜像指定了要执行的命令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;expose&quot;&gt;EXPOSE&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;/&amp;lt;protocol&amp;gt;...]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EXPOSE&lt;/code&gt;指令告诉Docker容器在运行时的监听网络端口。可以指定是TCP还是UDP，默认是TCP。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EXPOSE&lt;/code&gt;指令并不发布端口。它是作为构建镜像的人和运行容器的人之间的一种文档存在。想要在运行容器时发布端口，在&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt;时使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;标志来发布和映射一个或更多端口。&lt;/p&gt;

&lt;h2 id=&quot;env&quot;&gt;ENV&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;
ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENV&lt;/code&gt;指令将环境变量&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;key&amp;gt;&lt;/code&gt;设置为值&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;value&amp;gt;&lt;/code&gt;。该值将被接下去的指令使用。&lt;/p&gt;

&lt;h2 id=&quot;add&quot;&gt;ADD&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;有两种形式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] [&quot;src&quot;, ... &quot;&amp;lt;dest&amp;gt;&quot;]&lt;/code&gt;(这种形式是因为有些路径中包含空格因而被需要)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;指令从&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt;复制新的文件、目录或者远程文件的URL并将它们添加到镜像文件系统中的路径&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;遵循下面的规则：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt;路径必须在构建的&lt;em&gt;环境(context)&lt;/em&gt;中;你不能&lt;code class=&quot;highlighter-rouge&quot;&gt;ADD ../something /something&lt;/code&gt;,因为&lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt;的第一步是将环境文件夹以及其子文件夹发送给docker守护程序&lt;/li&gt;
  &lt;li&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt;是一个目录，则目录的所有内容都会被复制，包括文件系统元数据(目录本身不会被拷贝，仅仅是它的内容)&lt;/li&gt;
  &lt;li&gt;….&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;copy&quot;&gt;COPY&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COPY&lt;/code&gt;有两种形式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] [&quot;&amp;lt;src&amp;gt;&quot;,... &quot;&amp;lt;dest&amp;gt;&quot;]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COPY&lt;/code&gt;指令从&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt;复制新的文件或目录并将它们添加到容器文件系统中的路径&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;中&lt;/p&gt;

&lt;h2 id=&quot;entrypoint&quot;&gt;ENTRYPOINT&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;有两种形式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]&lt;/code&gt;(&lt;em&gt;exec&lt;/em&gt;形式，较好)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT command param1 param2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;允许你配置(configure)一个将作为可执行文件被运行的容器&lt;/p&gt;

&lt;p&gt;例如，下列命令将启动nginx，在端口80监听：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -i -t --rm -p 80:80 nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run &amp;lt;image&amp;gt;&lt;/code&gt;的命令行参数将在执行形式&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;下的所有元素之后被添加，并且将覆盖&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;形式的元素。&lt;/p&gt;

&lt;p&gt;只有最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;指令是有效的&lt;/p&gt;

&lt;h2 id=&quot;volume&quot;&gt;VOLUME&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VOLUME [&quot;/data&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VOLUME&lt;/code&gt;指令使用指定的名字创建一个挂载点并将它作为从原始本地或是其他容器获取数据的挂载卷。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt;命令初始化新创建的卷时会包括基本镜像中在指定位置的数据。例如：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM ubuntu
RUN mkdir /myvol
RUN echo &quot;hello world&quot; &amp;gt; /myvol/greeting
VOLUME /myvol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这会创造一个镜像，该镜像的&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt;会在&lt;code class=&quot;highlighter-rouge&quot;&gt;/myvol&lt;/code&gt;创造一个新的挂载点并将&lt;code class=&quot;highlighter-rouge&quot;&gt;greeting&lt;/code&gt;文件复制到新创建的挂载点&lt;/p&gt;

&lt;h2 id=&quot;workdir&quot;&gt;WORKDIR&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WORKDIR /path/to/workdir
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WORKDIR&lt;/code&gt;为例如&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;COPY&lt;/code&gt;等指令设置工作目录。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">docker build从一个Dockerfile和环境(context)中构建一个镜像。构建的环境是一个指定路径(PATH)或URL处的文件集。PATH是本地文件系统的目录，URL是一个Git库的位置。</summary></entry><entry><title type="html">Arts Weekseven Envoy Example Analyze.</title><link href="http://localhost:4000/ARTS-WeekSeven-Envoy-Example-Analyze" rel="alternate" type="text/html" title="Arts Weekseven Envoy Example Analyze." /><published>2019-05-26T00:00:00+08:00</published><updated>2019-05-26T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekSeven-Envoy-Example-Analyze.</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekSeven-Envoy-Example-Analyze">&lt;p&gt;最近在学习envoy，这里简单学习一下其中的入门例子front-proxy.其目录位于envoy/example/front-proxy下。&lt;/p&gt;

&lt;h2 id=&quot;目录结构&quot;&gt;目录结构&lt;/h2&gt;
&lt;p&gt;首先看下目录结构，如下所示&lt;br /&gt;
&lt;img src=&quot;./directory_structure.png&quot; alt=&quot;目录结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大体上目录中的文件可以分为四个部分：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;docker compose: docker-compose.yaml&lt;/li&gt;
  &lt;li&gt;docker: Dockerfile-frontenvoy, Dockerfile-service&lt;/li&gt;
  &lt;li&gt;envoy: service-envoy.yaml, front-envoy.yaml&lt;/li&gt;
  &lt;li&gt;source: service.py, start_service.sh&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下去分别看下这四个部分的内容&lt;/p&gt;

&lt;h2 id=&quot;docker-compose&quot;&gt;docker compose&lt;/h2&gt;
&lt;p&gt;docker compose是用来配置、管理各个服务的。在本例中，docker compose定义了三个服务，分别是front-envoy, service1和service2.&lt;/p&gt;

&lt;p&gt;front-envoy的dockerfile被指定为Dockerfile-frontenvoy，这样启动docker容器时就会去找到该文件并使用它与docker daemon进行交互。它还将当前目录下的front-envoy.yaml挂载到了docker容器中的/etc中。&lt;/p&gt;

&lt;p&gt;front-envoy还有一个重要的点，它将本地端口80映射到了外界端口8000上，这样外界就可以通过端口8000与其进行交互。而front-envoy则应当监听80端口。&lt;/p&gt;

&lt;p&gt;service1和service2是类似的。以service1为例，它指定了dockerfile为Dockerfile-service，并将当前目录下的service-envoy.yaml挂载到docker容器中的/etc目录下。&lt;/p&gt;

&lt;p&gt;此外，service1的网络还被重命名为service1(为了方便后续配置socket address?),其环境变量SERVICE_NAME被设置为1以便后面启动。这里的问题是，expose到底有用吗？&lt;/p&gt;
&lt;h2 id=&quot;docker&quot;&gt;Docker&lt;/h2&gt;
&lt;p&gt;Docker文件是CLI与docker daemon交流的文件，主要是为docker容器的启动作准备。&lt;/p&gt;

&lt;p&gt;Dockerfile-frontenvoy配置了front-envoy服务所在docker容器的属性。它首先指定了base image为envoyproxy/envoy-dev:latest,然后进行更新并安装curl。值得注意的是最后它执行了/usr/local/bin/envoy命令，这应该就是envoy程序的核心所在。&lt;/p&gt;

&lt;p&gt;Dockerfile-service配置了service所在docker容器的属性。它首先指定了base image为envoyproxy/envoy-alpine-dev:latest,然后更新并安装了python3、bash和curl。它创建了/code目录，将service.py添加到了该目录下，并将执行脚本start_service.sh放到了/usr/local/bin下。最后，它将容器的执行点设置为该脚本。&lt;/p&gt;

&lt;h2 id=&quot;source&quot;&gt;source&lt;/h2&gt;
&lt;p&gt;源文件包含了服务的业务逻辑。&lt;/p&gt;

&lt;p&gt;start_service.sh脚本主要干了两件事，一是启动服务service，二是启动envoy。可见，envoy程序必须和业务程序共同启动。此外，之前设置的环境变量在此处也起到了选择service(cluster?)的作用。&lt;/p&gt;

&lt;p&gt;服务程序service.py用到了falsk等框架，我不太了解，因此不详述。这里要说的，服务程序监听的端口号是8080,这个端口号在service-envoy.yaml中被映射到envoy的端口。&lt;/p&gt;

&lt;h2 id=&quot;envoy&quot;&gt;envoy&lt;/h2&gt;
&lt;p&gt;最后是envoy的配置文件。这些配置文件在启动envoy程序时被使用。&lt;/p&gt;

&lt;p&gt;在service-envoy中，envoy在80端口上监听，并匹配”/service”前缀的URL，匹配到之后把请求转发给8080端口。&lt;/p&gt;

&lt;p&gt;在front-envoy中，envoy在80端口上监听，并分别匹配”/service/1”和”/service/2”前缀的URL，将请求分别分发给service1的80端口和service2的80端口。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">最近在学习envoy，这里简单学习一下其中的入门例子front-proxy.其目录位于envoy/example/front-proxy下。</summary></entry><entry><title type="html">Arts Weekseven Leetcode728 Selfdividenumbers</title><link href="http://localhost:4000/ARTS-WeekSeven-Leetcode728-SelfDivideNumbers/" rel="alternate" type="text/html" title="Arts Weekseven Leetcode728 Selfdividenumbers" /><published>2019-05-20T00:00:00+08:00</published><updated>2019-05-20T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekSeven-Leetcode728-SelfDivideNumbers</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekSeven-Leetcode728-SelfDivideNumbers/">&lt;p&gt;A self-dividing number is a number that is divisible by every digit it contains.&lt;/p&gt;

&lt;p&gt;For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.&lt;/p&gt;

&lt;p&gt;Also, a self-dividing number is not allowed to contain the digit zero.&lt;/p&gt;

&lt;p&gt;Given a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题其实也很简单，就按照题目意思顺次遍历然后转化为字符串判断是否可以自除即可。go语言代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func selfDividingNumbers(left int, right int) []int {
    res := make([]int, 0)
    
    for i := left; i &amp;lt;= right; i++ {
        if(isSelfDivide(i)) {
            res = append(res, i)
        }
    }
    
    return res
    
}

func isSelfDivide(num int) bool {
    strNum := strconv.Itoa(num)
    
    for i := 0; i &amp;lt; len(strNum); i++ {
        n := (int)(strNum[i] - '0')
        if n == 0 || num % n != 0 {
            return false
        }
    }
    
    return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">A self-dividing number is a number that is divisible by every digit it contains.</summary></entry><entry><title type="html">计算机技术历史 语言(三)</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%89)/" rel="alternate" type="text/html" title="计算机技术历史 语言(三)" /><published>2019-05-19T00:00:00+08:00</published><updated>2019-05-19T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%89)</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%89)/">&lt;p&gt;本次介绍一下虽然没有名气，但是深远的影响了后面的大部分程序设计语言的一个语言-Algol编程语言。&lt;/p&gt;

&lt;p&gt;ALGOL语言诞生在20世纪50年代末。目前大多数现代语言的语法其实都是类似类Algol的。它是最有影响力的四种高级语言之一：FORTRAN，Lisp和COBOL。它被设计来改善FORTRAN暴露的问题并且最后导致了许多编程语言的诞生——PL/I，BCPL，B，Pascal和C。&lt;/p&gt;

&lt;p&gt;Algol引入了代码块的概念和&lt;code class=&quot;highlighter-rouge&quot;&gt;begin...end&lt;/code&gt;对。它也是第一个支持嵌套函数定义的编程语言。此外，它是第一个详细关注(?)正式语言定义的编程语言。并且也是它引入了BNF范式。&lt;/p&gt;

&lt;p&gt;ALGOL 60有两种参数传递方式：按值传递和按名字传递。按名字传递对引用传递有深远的影响。按名字传递指的是当参数传递给函数时，它是在函数内部出现该参数的地方直接替换。这样的话，如果函数内部没有用到该参数，它就不会被求值。如果函数内部出现了多次，每次它都会被重新求值。&lt;/p&gt;

&lt;p&gt;然而，ALGOL 60没有定义I/O设施。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">本次介绍一下虽然没有名气，但是深远的影响了后面的大部分程序设计语言的一个语言-Algol编程语言。</summary></entry><entry><title type="html">Arts Weeksix Leetcode674 Lcis</title><link href="http://localhost:4000/ARTS-WeekSix-Leetcode674-LCIS/" rel="alternate" type="text/html" title="Arts Weeksix Leetcode674 Lcis" /><published>2019-05-17T00:00:00+08:00</published><updated>2019-05-17T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekSix-Leetcode674-LCIS</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekSix-Leetcode674-LCIS/">&lt;p&gt;Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题其实就是找数组中的最长连续递增子序列。想法也很简单，设置一个startIndex，当发现序列不是递增时，则子序列的长度是当前的Index减去startIndex，同时将startIndex设置为当前位置(这里注意可能有off-by-one)。遍历整个序列，找到最长的序列即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func findLengthOfLCIS(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    lengthMax := 1
    startIndex := 0
    
    arrayLength := len(nums)
    for i := 0; i &amp;lt; arrayLength - 1; i++ {
        if nums[i + 1] &amp;lt;= nums[i] {
            if i +  1 - startIndex &amp;gt; lengthMax {
                lengthMax = i + 1 - startIndex
            }
            startIndex = i + 1
        }
    }
    
    if startIndex != arrayLength - 1 &amp;amp;&amp;amp; arrayLength - startIndex &amp;gt; lengthMax {
        lengthMax = arrayLength - startIndex
    }
    
    return lengthMax
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</summary></entry><entry><title type="html">Arts Weeksix Vim Tricks</title><link href="http://localhost:4000/ARTS-WeekSix-vim-tricks/" rel="alternate" type="text/html" title="Arts Weeksix Vim Tricks" /><published>2019-05-17T00:00:00+08:00</published><updated>2019-05-17T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekSix-vim-tricks</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekSix-vim-tricks/">&lt;p&gt;这篇文章介绍了一些vim中的小技巧。&lt;/p&gt;

&lt;h2 id=&quot;替换单词&quot;&gt;替换单词&lt;/h2&gt;
&lt;p&gt;替换命令可以将一个单词替换为另一个单词，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/four/4/g&lt;/code&gt;&lt;br /&gt;
然而，对于&lt;code class=&quot;highlighter-rouge&quot;&gt;thirtyfour&lt;/code&gt;来说显然不用替换，此时可以使用”\&amp;lt;”标志，转化为&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\&amp;lt;four/4/g&lt;/code&gt;&lt;br /&gt;
显然，对于&lt;code class=&quot;highlighter-rouge&quot;&gt;fourteen&lt;/code&gt;来说，也是不对。可以使用”\&amp;gt;”标志，则转化为:&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\&amp;lt;four\&amp;gt;/4/g&lt;/code&gt;&lt;br /&gt;
如果正在编程，可能希望替换注释中的“four”，这可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\&amp;lt;four\&amp;gt;4/gc&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;将last-first转化为first-last&quot;&gt;将”Last, First”转化为”First Last”&lt;/h2&gt;
&lt;p&gt;假设你有许多单词，其形式为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Doe, John
Smith, Peter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;你想将它们变为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;John Doe
Peter Smith
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这可以通过一个命令完成：&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\([^,]*\),\(.*\)/\2 \1/&lt;/code&gt;&lt;br /&gt;
解释如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The first part between \( \) matches &quot;Last&quot;	\(     \)
match anything but a comma			  [^,]
any number of times				      *
matches &quot;, &quot; literally					 ,
The second part between \( \) matches &quot;First&quot;		   \(  \)
any character					     .
any number of times					      *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;“\2”和”\1”叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;backreferences&lt;/code&gt;，可以指代前面用”\( \)”包围的文本&lt;/p&gt;

&lt;h2 id=&quot;逆转行的顺序&quot;&gt;逆转行的顺序&lt;/h2&gt;
&lt;p&gt;命令为&lt;code class=&quot;highlighter-rouge&quot;&gt;:global/^/m 0&lt;/code&gt;&lt;br /&gt;
它的意思是，对于特定的一行，&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;到达行开始，&lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;移动整行，移动位置是第0行，也就是第一行之前。而&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;命令不会被改变的顺序影响，因此所有的行依次进行上面的命令，则逆转了文件所有行的顺序&lt;/p&gt;

&lt;h2 id=&quot;数单词&quot;&gt;数单词&lt;/h2&gt;
&lt;p&gt;命令为&lt;code class=&quot;highlighter-rouge&quot;&gt;g CTRL-G&lt;/code&gt;，注意&lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt;的后面没有空格。也可以在可视模式下选择部分内容再使用上面的命令&lt;/p&gt;

&lt;h2 id=&quot;无用的空格&quot;&gt;无用的空格&lt;/h2&gt;
&lt;p&gt;有时候有些空格在行的最后没有用且很丑，为了删除这些空格，可以使用这条命令&lt;code class=&quot;highlighter-rouge&quot;&gt;:%s/\s\+$//&lt;/code&gt;。这句话的意思是将一个或多个&lt;code class=&quot;highlighter-rouge&quot;&gt;(\+)&lt;/code&gt;在结尾&lt;code class=&quot;highlighter-rouge&quot;&gt;($)&lt;/code&gt;处的空格&lt;code class=&quot;highlighter-rouge&quot;&gt;(\s)&lt;/code&gt;替换成空白&lt;code class=&quot;highlighter-rouge&quot;&gt;(//)&lt;/code&gt;。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">这篇文章介绍了一些vim中的小技巧。</summary></entry><entry><title type="html">Arts Weeksix Threerules</title><link href="http://localhost:4000/ARTS-weekSix-ThreeRules/" rel="alternate" type="text/html" title="Arts Weeksix Threerules" /><published>2019-05-16T00:00:00+08:00</published><updated>2019-05-16T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-weekSix-ThreeRules</id><content type="html" xml:base="http://localhost:4000/ARTS-weekSix-ThreeRules/">&lt;p&gt;这篇文章讲述了Instagram构建可伸缩云应用架构的三个原则。&lt;/p&gt;

&lt;h2 id=&quot;三使用被证实的稳定的技术&quot;&gt;三、使用被证实的稳定的技术&lt;/h2&gt;
&lt;p&gt;Instagram会观察周围的最具实力的专家们都在使用哪些技术，然后争取使用和他们一致的技术。&lt;/p&gt;

&lt;p&gt;例如，观察周围的这些公司，就会发现它们都在从旧时代的，微缩整体的架构转换到如今的微服务架构。微服务架构更偏向于简化的选择正确的工具。&lt;/p&gt;

&lt;h2 id=&quot;二不要重新发明轮子&quot;&gt;二、不要重新发明轮子&lt;/h2&gt;
&lt;p&gt;云提供商和基础数据库决策以及向DevOps的持续转变正在变得常见。科技应当帮助你建造接下来的事情，而不是让你确保处理用户的下一波浪潮。&lt;/p&gt;

&lt;p&gt;使用已有的东西，不管那是库、社区或是已知的内在知识。&lt;/p&gt;

&lt;h2 id=&quot;一保持简单&quot;&gt;一、保持简单&lt;/h2&gt;
&lt;p&gt;每个决策都可能使得代码变得更复杂。因此，要确保每个决策都尽量谨慎以使得程序保持简单、简洁&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">这篇文章讲述了Instagram构建可伸缩云应用架构的三个原则。</summary></entry><entry><title type="html">Arts Weekfive Avoid Over Engineering</title><link href="http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering/" rel="alternate" type="text/html" title="Arts Weekfive Avoid Over Engineering" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering/">&lt;p&gt;商业需求是在不断变化的，因此过度设计往往得不偿失。注意：下面的一些内容不是不要做，而是要适当，不要过度。&lt;/p&gt;

&lt;p&gt;以下是一些误解&lt;/p&gt;
&lt;h2 id=&quot;1-工程比商业更聪明&quot;&gt;1. 工程比商业更聪明&lt;/h2&gt;
&lt;p&gt;工程师们往往认为自己掌控一切，但事实上商业需求永远技高一筹。在第1000个问题被解决后，它们还能冒出第1001个需求来。&lt;/p&gt;

&lt;p&gt;商业需求是发散的，而不是收敛的&lt;/p&gt;

&lt;h2 id=&quot;2-重用商业功能模块&quot;&gt;2. 重用商业功能模块&lt;/h2&gt;
&lt;p&gt;当商业抛出越来越多的功能，我们有时候会将逻辑组合起来，尽量泛化它们。然而商业需求只会发散而不会收敛，这就使得共享的逻辑变得庞大。反之，我们应该将每个动作和逻辑分离开来，只有很少的共享逻辑。&lt;/p&gt;

&lt;p&gt;在横向分离之前先尝试纵向分裂商业功能。多隔离动作而少组合动作。&lt;/p&gt;

&lt;h2 id=&quot;3-所有的事情都是关于泛型&quot;&gt;3. 所有的事情都是关于泛型&lt;/h2&gt;
&lt;p&gt;有些时候工程师会执着于完美的抽象而忽略了真正的问题。其实答案非常简单。&lt;/p&gt;

&lt;p&gt;今天最好的设计是它能怎么样被取消(undesigned)。写的代码要易于删除，而不是易于扩展。&lt;/p&gt;

&lt;p&gt;重复比错误的抽象要好。重复次数多了，抽象就显现出来了。&lt;/p&gt;

&lt;h2 id=&quot;4-臃肿的包裹器&quot;&gt;4. 臃肿的包裹器&lt;/h2&gt;
&lt;p&gt;在使用每个外部库之前都写一个包裹器是不对的。这会使得包裹器变得臃肿。另一方面，包裹器往往和底层的库紧密的耦合，底层库变了包裹器也变了。&lt;/p&gt;

&lt;p&gt;现在许多外部库的API已经足够优秀了，因此不要总想着写包裹器。包裹器是一个异常情况，而不是正常情况。&lt;/p&gt;

&lt;h2 id=&quot;5-像使用工具一样使用质量&quot;&gt;5. 像使用工具一样使用质量&lt;/h2&gt;
&lt;p&gt;盲目的应用质量概念（例如将所有变量改成”private final”,为所有的类写接口等）并不会使代码奇迹般的变好。&lt;/p&gt;

&lt;p&gt;记住要总是往后退一步然后看看总体的风景。&lt;/p&gt;

&lt;p&gt;有些代码完全符合各种原则和概念，但是从整体来看却很糟糕。&lt;/p&gt;

&lt;h3 id=&quot;51-三明治层&quot;&gt;5.1 三明治层&lt;/h3&gt;
&lt;p&gt;例如，将一个简洁的，紧密相连的动作划分层10或20层三明治层，每一层都与外界无关。在过去使用继承来完成，即A扩展出B扩展出C……。现在想要完成这件事并且符合SOLID原则，则需要对每个类构建接口，并且把一个类依次注入到下一个类中，明显变得更麻烦了。&lt;/p&gt;

&lt;p&gt;像SOLID这样的概念是由于继承和其他OOP概念的滥用才产生的。大多数工程师不知道这些东西为什么诞生，只是跟随着就用。&lt;/p&gt;

&lt;p&gt;脑海中的概念应当会转换，而不能被盲目的像工具一样使用。&lt;/p&gt;

&lt;h2 id=&quot;6-过度使用综合征&quot;&gt;6. 过度使用综合征&lt;/h2&gt;
&lt;p&gt;一些过度使用综合征的例子：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;发现了泛型，于是一个简单的”HelloWorldPrinter”变成了”HelloWorldPrinter&amp;lt;String, Writer&amp;gt;”&lt;/li&gt;
  &lt;li&gt;发现了策略模式，于是每个”if”都是一个策略&lt;/li&gt;
  &lt;li&gt;发现了怎么写DSL，于是到处使用DSL&lt;/li&gt;
  &lt;li&gt;发现了Mocks，于是对每个测试的对象都使用mock&lt;/li&gt;
  &lt;li&gt;元编程太棒了，到处都使用元编程&lt;/li&gt;
  &lt;li&gt;枚举/扩展方法/Traits等等太棒了，到处都使用它…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-x-ity&quot;&gt;7. &amp;lt;X&amp;gt;-ity&lt;/h2&gt;
&lt;p&gt;…性。例如可配置性，安全性，扩展性，维护性，伸缩性等等。这些性质当然是好的，但不要对每个性能都担忧会发生意外。仔细的考虑使用场景，再对这些性能作优化。&lt;/p&gt;

&lt;h2 id=&quot;8-内部发明&quot;&gt;8. 内部”发明”&lt;/h2&gt;
&lt;p&gt;内部的库、框架和工具最近很流行，但并不一定是好的。&lt;/p&gt;

&lt;p&gt;一些被错过的事情：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于某个问题领域有很深的了解是很难的，需要很多的技能。&lt;/li&gt;
  &lt;li&gt;让“发明”持续运行需要很多努力。即使是很小的库的维护也需要诸多时间&lt;/li&gt;
  &lt;li&gt;和对现有框架作出贡献相比，创造一个”发明”往往需要更多的时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重用，fork，贡献，重新考虑&lt;/p&gt;

&lt;h2 id=&quot;9-维持现状&quot;&gt;9. 维持现状&lt;/h2&gt;
&lt;p&gt;一旦一件事情被完成了，每个人都开始基于它构建东西。没人质疑现状。工作着的代码被认为是正确的。每个人都改变自己来适应这个库。&lt;/p&gt;

&lt;p&gt;这样是不对的。一个健康的系统是会搅动、翻腾的。很长时间不提交的代码一定是有问题的。&lt;/p&gt;

&lt;p&gt;重构是每个故事的一部分。没有代码是不可触碰的。&lt;/p&gt;

&lt;h2 id=&quot;10-差的估计&quot;&gt;10. 差的估计&lt;/h2&gt;
&lt;p&gt;我们经常发现非常优秀的团队或是程序员写出糟糕的代码。这是因为质量需要时间而不仅仅是技术。聪明的程序员往往会高估自己的实力于是只能匆忙写出较差的代码。因此，谨慎估计完成日期。&lt;/p&gt;

&lt;p&gt;差的估计在代码开始写之前就破坏了质量。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章主要是关于过度设计的。作者列举了10个过度设计的例子，其中有些由于我还没有接触实际的生产代码还不清楚，但大部分内容还是很有帮助的。&lt;/p&gt;

&lt;p&gt;第1点是文章的核心，我在很多其他地方也见到过类似的内容，即需求是一直变化的，不要妄想自己写出完美的代码。&lt;/p&gt;

&lt;p&gt;第3点对我来说比较重要，因为我之前总想着把变化封装起来，看了第3点之后明白了，一定要适度，过度抽象只会弄巧成拙。&lt;/p&gt;

&lt;p&gt;第9点也点醒了我。之前一直以为较好的库意味着很少对它作改动，每个人都用的舒心，然而其实不是这样的。即便是很好的库也一定会有问题存在，人们不动它可能是因为人们去习惯它。我们应当时刻注意自己写的内容，当很长时间没有翻新时则更要警惕。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">商业需求是在不断变化的，因此过度设计往往得不偿失。注意：下面的一些内容不是不要做，而是要适当，不要过度。</summary></entry></feed>