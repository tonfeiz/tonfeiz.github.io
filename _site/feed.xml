<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-06-19T17:13:46+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tonfeiz’s Blog</title><subtitle></subtitle><author><name>Tonfeiz</name></author><entry><title type="html">Arts Weekeleven Leetcode915 Disjoint Intervals</title><link href="http://localhost:4000/ARTS-WeekEleven-Leetcode915-Disjoint-Intervals/" rel="alternate" type="text/html" title="Arts Weekeleven Leetcode915 Disjoint Intervals" /><published>2019-06-19T00:00:00+08:00</published><updated>2019-06-19T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekEleven-Leetcode915-Disjoint-Intervals</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekEleven-Leetcode915-Disjoint-Intervals/">&lt;p&gt;Given an array A, partition it into two (contiguous) subarrays left and right so that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every element in left is less than or equal to every element in right.&lt;/li&gt;
  &lt;li&gt;left and right are non-empty.&lt;/li&gt;
  &lt;li&gt;left has the smallest possible size.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;p&gt;Input: [5,0,3,8,6]
Output: 3
Explanation: left = [5,0,3], right = [8,6]&lt;/p&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;p&gt;Input: [1,1,1,0,6,12]
Output: 4
Explanation: left = [1,1,1,0], right = [6,12]&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题的意思是将数组划分成两个区间，左边的每一个元素都小于右边的每一个元素。如此一来，思路就很清晰了——找到数组中每个位置左边最大元素和右边最小元素，使得该位置上左边最大元素小于右边最小元素，同时该位置应当尽量靠近左边。&lt;/p&gt;

&lt;p&gt;为了找到每个位置的左边最大元素和右边最小元素，需遍历数组两次。第一次从左往右，并与当前的最大值做比较，同时记录。第二次从右往左，并与当前的最小值作比较，同时记录。最后根据左边最大、右边最小两个数组上对应位置的大小关系即可确认划分位置。这里要注意的是，存在一些细节问题，但只要仔细思考，这些细节问题很容易解决。&lt;/p&gt;

&lt;p&gt;代码如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    int partitionDisjoint(vector&amp;lt;int&amp;gt;&amp;amp; A) {
        vector&amp;lt;int&amp;gt; left_max(A.size()), right_min(A.size());
        
        int current_max = INT_MIN;
        for(int i = 0; i &amp;lt; A.size(); ++i) {
            if(A[i] &amp;gt; current_max) {
                current_max = A[i];
            }
            left_max[i] = current_max;
        }
        
        int current_min = INT_MAX;
        for(int i = A.size() - 1; i &amp;gt;= 0; --i) {
            right_min[i] = current_min;
            if(A[i] &amp;lt; current_min) {
                current_min = A[i];
            }
        }
    
        int res = 0;
        for(int i = 0; i &amp;lt; A.size() - 1; ++i) {
            if(left_max[i] &amp;lt;= right_min[i]) {
                res = i + 1;
                break;
            }
        }
        return res;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given an array A, partition it into two (contiguous) subarrays left and right so that:</summary></entry><entry><title type="html">Envoy学习之旅(四)</title><link href="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E5%9B%9B)/" rel="alternate" type="text/html" title="Envoy学习之旅(四)" /><published>2019-06-17T00:00:00+08:00</published><updated>2019-06-17T00:00:00+08:00</updated><id>http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E5%9B%9B)</id><content type="html" xml:base="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E5%9B%9B)/">&lt;p&gt;本周对envoy的介绍文档仔细的阅读了一遍。在此将笔记记录如下。&lt;/p&gt;

&lt;h2 id=&quot;what-is-envoy&quot;&gt;What is Envoy&lt;/h2&gt;
&lt;p&gt;Envoy是一个L7的代理以及通讯总线，被用于大规模现代SOA架构。&lt;/p&gt;

&lt;p&gt;Envoy认为:&lt;br /&gt;
&lt;strong&gt;网络对应用应当是透明的。当网络和应用发生了问题，应该可以很简单就定位到问题的源头&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Envoy有下列特性：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Out of process architecture&lt;/strong&gt;：Envoy是一个自包含进程，与应用服务一同启动。这有两大好处：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与任意应用语言都能工作&lt;/li&gt;
  &lt;li&gt;由于不是库的形式，Envoy可以快速部署和升级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;现代C++11代码&lt;/strong&gt;: 既有速度又有生产力&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;L3/L4过滤架构&lt;/strong&gt;: Envoy在其核心是一个L3/L4的网络代理。可插入的&lt;code class=&quot;highlighter-rouge&quot;&gt;filter chain&lt;/code&gt;机制使过滤器能被写出来用于完成不同的TCP代理任务并插入到主服务器中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP过滤架构&lt;/strong&gt;：Envoy提供一层额外的HTPP过滤层。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP L7 路由&lt;/strong&gt;: 在HTTP模式下，Envoy支持一个路由子系统。该系统能基于路径、内容和运行时值等路由和重定向请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多种支持&lt;/strong&gt;： gRPC,MongDB L7, Dynamo DB L7等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务发现和动态配置&lt;/strong&gt;： Envoy可选的提供了动态配置API层。该层允许Envoy动态的更新：后端&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;,后端&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;,HTTP 路由，监听 sockets等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;健康检查&lt;/strong&gt;： 构建Envoy网格的建议方式是将服务发现作为最终一致的过程。Envoy包含一个健康检查子系统，能可选的主动检查上游服务cluster的健康情况。&lt;br /&gt;
&lt;strong&gt;高级负载均衡&lt;/strong&gt;:&lt;/p&gt;

&lt;h2 id=&quot;architecture-overview&quot;&gt;Architecture overview&lt;/h2&gt;
&lt;h3 id=&quot;terminoogy&quot;&gt;Terminoogy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;: 能进行网络通信的一个实体(移动手机上的应用，服务器等)。一台硬件上可能有多个Host&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Downstream&lt;/strong&gt;: 一个下游host连接到Envoy，发送请求并接收回应&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Upstream&lt;/strong&gt;: 一个上游host从Envoy接收连接和请求并作出回应&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Listener&lt;/strong&gt;: 一个Listener是一个命名了的网络位置(例如端口，Unix域socket等)，该位置可以被下游客户端连接。Envoy会暴露一个或多个listener供下游host连接&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cluster&lt;/strong&gt;: 一个cluster是逻辑上相似的一组上游host，Envoy连接到这些host。Envoy通过服务发现找到cluster中的成员，通过健康检查判断该成员是否健康，通过负载均衡策略路由请求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mesh&lt;/strong&gt;: 一组协调起来提供一致的网络拓扑的host。在本文档中，”Envoy mesh”是指一组分布式系统中组成了消息传递基础的Envoy代理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime configuration&lt;/strong&gt;: 带外实时配置系统，与Envoy一同部署&lt;/p&gt;

&lt;h3 id=&quot;thread-model&quot;&gt;Thread model&lt;/h3&gt;
&lt;p&gt;Envoy使用单进程多线程架构。单个&lt;em&gt;master&lt;/em&gt;线程控制偶尔发生的协调任务，一些&lt;em&gt;worker&lt;/em&gt;线程处理监听、过滤和转发任务。一旦一个连接被一个listener接受，该连接的剩余生命就和该worker线程绑定了。这使得Envoy大部分是单线程的(&lt;code class=&quot;highlighter-rouge&quot;&gt;embarrassingly parallel&lt;/code&gt;),一小部分更复杂的代码处理worker线程之间的协调。通常Envoy是完全非阻塞的，大部分情况下建议工作线程的数量和硬件线程的数量一致。&lt;/p&gt;

&lt;h3 id=&quot;listeners&quot;&gt;Listeners&lt;/h3&gt;
&lt;p&gt;Envoy配置支持在一个进程中设置任意数量的listener。通常我们建议不管设置的listener有多少，每个机器都设置一个Envoy。&lt;/p&gt;

&lt;p&gt;每个listener都通过一些网络层(L3/L4)过滤器独立的配置。当listener接收到了一个新的连接，配置好的本地连接过滤器堆栈将会被实例化并开始处理一系列的事件。&lt;/p&gt;

&lt;p&gt;Listener也可以配置一些listener过滤器。该过滤器在网络层过滤器之前被使用，可以操纵连接的元数据。通常这是为了影响连接后续怎么被过滤器或者cluster处理。&lt;/p&gt;

&lt;p&gt;Listener也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;listener discovery service&lt;/code&gt;(LDS)动态的获取。&lt;/p&gt;

&lt;h3 id=&quot;listener-filters&quot;&gt;Listener filters&lt;/h3&gt;
&lt;p&gt;Listener filters的主要目的是使得以后增加系统集成函数更简单(通过不改变Envoy的核心功能)。&lt;/p&gt;

&lt;p&gt;Listener filters的API相对简单因为最终是对新接受的sockets进行操作。&lt;/p&gt;

&lt;h3 id=&quot;networkl3l4-filters&quot;&gt;Network(L3/L4) filters&lt;/h3&gt;
&lt;p&gt;网络层过滤器是Envoy连接处理的核心。有三种不同种类的网络过滤器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读：当Envoy从下游连接收到信息时，读过滤器被调用&lt;/li&gt;
  &lt;li&gt;写：当Envoy要发送数据给下游连接时，写过滤器被调用&lt;/li&gt;
  &lt;li&gt;读/写：不管Envoy收到数据还是发送数据，读/写过滤器都会被调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;网络层过滤器的API相对简单，因为最终过滤器对原始字节和一小部分的连接事件(例如TLS握手，连接断开等)进行操作。&lt;/p&gt;

&lt;h3 id=&quot;http-connection-management&quot;&gt;HTTP connection management&lt;/h3&gt;
&lt;p&gt;Envoy有一个内置的网络层过滤器&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;。该过滤器将原始字节转化为HTTP层的信息和事件。它也处理所有HTTP连接和请求共同的功能。&lt;/p&gt;

&lt;h4 id=&quot;http-protocols&quot;&gt;HTTP protocols&lt;/h4&gt;
&lt;p&gt;Envoy的&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;原生支持HTTP/1.1,WebSockets和HTTP/2。Envoy设计为最先支持HTTP/2复用代理。HTTP/2的术语被用来描述系统组件。例如，HTTP请求和响应在流上发生。一个&lt;code class=&quot;highlighter-rouge&quot;&gt;codec&lt;/code&gt;API被使用来转化协议。以HTTP/1.1为例，&lt;code class=&quot;highlighter-rouge&quot;&gt;codec&lt;/code&gt;将协议的序列/管道能力转化为像HTTP/2一样(对更高层来说)。&lt;/p&gt;

&lt;h4 id=&quot;http-header-sanitizing&quot;&gt;HTTP header sanitizing&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;出于安全考虑提供许多不同的首部净化措施。&lt;/p&gt;

&lt;h4 id=&quot;route-table-configuration&quot;&gt;Route table configuration&lt;/h4&gt;
&lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;过滤器有一个关联的路由表。路由表可以是静态的，也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RDS&lt;/code&gt;API动态指定。&lt;/p&gt;

&lt;h3 id=&quot;http-filters&quot;&gt;HTTP filters&lt;/h3&gt;
&lt;p&gt;Envoy在&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;内支持HTTP级别的过滤器。过滤器不需要知道底层的物理协议(HTTP/1.1,HTTP/2等)。有三种HTTP级别的过滤器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Decoder&lt;/strong&gt;: 当manager解码部分请求流(首部、实体等)时，该过滤器被调用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Encoder&lt;/strong&gt;: 当manager编码部分响应流(首部、实体等)时，该过滤器被调用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Decoer/Encoder&lt;/strong&gt;: 上述两种情况均会调用该过滤器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-routing&quot;&gt;HTTP routing&lt;/h3&gt;
&lt;p&gt;Envoy包含一个HTTP路由过滤器。这对处理边缘流量和构建服务对服务Envoy网格十分有用。Envoy也有配置为前向代理的能力。在前向代理配置中，网格客户端可以通过适当的配置它们的http代理为Envoy来加入。在一个较高的层次上看，路由器接受一个到来的HTTP请求，将它和上游的cluster匹配，获取一个到上游cluster中的host的连接池，然而转发请求。路由过滤器有如下特性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将域名映射到一系列路由规则集合的虚拟主机&lt;/li&gt;
  &lt;li&gt;前缀和完整的路径匹配规则&lt;/li&gt;
  &lt;li&gt;虚拟主机层次的TLS重定向&lt;/li&gt;
  &lt;li&gt;路由层次的路径/主机重定向&lt;/li&gt;
  &lt;li&gt;路由层次的直接(非代理的)HTTP响应&lt;/li&gt;
  &lt;li&gt;显式主机重写&lt;/li&gt;
  &lt;li&gt;前缀重写&lt;/li&gt;
  &lt;li&gt;通过HTTP首部或者路由配置的请求重试&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;route-table&quot;&gt;Route table&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;的配置中有被所有配置好的HTTP过滤器使用的路由表。虽然路由过滤器是路由表的主要使用者，其他过滤器也能访问该路由表&lt;/p&gt;

&lt;h3 id=&quot;upstream-clusters&quot;&gt;Upstream clusters&lt;/h3&gt;
&lt;h4 id=&quot;cluster-manager&quot;&gt;Cluster manager&lt;/h4&gt;
&lt;p&gt;Envoy的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster manager&lt;/code&gt;管理所有的上游&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;的数量是任意的。&lt;/p&gt;

&lt;p&gt;上游的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;从网络/HTTP过滤器栈中抽象出来。&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster manager&lt;/code&gt;给过滤器栈暴露API以允许过滤器获取到一个上游&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;的L3/L4连接，或是到上游&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;的抽象HTTP连接池的句柄。过滤器决定是否需要L3/L4连接或是新的HTTP流，&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster manager&lt;/code&gt;则管理负载均衡、线程本地存储、上游连接类型、知道哪些&lt;code class=&quot;highlighter-rouge&quot;&gt;hosts&lt;/code&gt;是可用并且健康的这些功能。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster manager&lt;/code&gt;知道的&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;可通过静态配置或是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster discovery service&lt;/code&gt;(CDS) API动态配置。&lt;/p&gt;

&lt;h5 id=&quot;cluster-warming&quot;&gt;Cluster warming&lt;/h5&gt;
&lt;p&gt;当cluster通过服务器引导或是CDS初始化时，它们被”预热”了。这意味着&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;不可用直到下面的操作发生：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;初始化服务发现负载(DNS解析，EDS更新等)&lt;/li&gt;
  &lt;li&gt;初始主动健康检查通过(如果主动健康检查被配置)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面的举措确保了Envoy在用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;进行服务时对该&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;有准确的映像。&lt;/p&gt;

&lt;p&gt;当谈论&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster warming&lt;/code&gt;时，&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;变得可用意味着：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于新加入的&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;，在它被预热之前对于Envoy看上去是不存在的，如果HTTP路由到该&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;则会引发404或503&lt;/li&gt;
  &lt;li&gt;对于更新&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;，老的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;会继续存在并提供服务。当新的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;被预热了，它会原子的和老的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;互换这样就不会发生流量中断的情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;service-discovery&quot;&gt;Service discovery&lt;/h3&gt;
&lt;p&gt;当上游的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;在配置中定义了，Envoy需要知道如何解析&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中的成员。这被称为服务发现。&lt;/p&gt;
&lt;h4 id=&quot;supported-service-discovery-types&quot;&gt;Supported service discovery types&lt;/h4&gt;
&lt;h5 id=&quot;static&quot;&gt;Static&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Static&lt;/code&gt;是最简单的服务发现种类。配置中显式的指定每个上游&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;的被解析的网络名字(IP地址/端口，unix域socket等)&lt;/p&gt;

&lt;h5 id=&quot;strict-dns&quot;&gt;Strict DNS&lt;/h5&gt;
&lt;p&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;strict DNS&lt;/code&gt;服务发现时，Envoy会持续异步的解析指定的DNS目标。每个返回的IP地址将被认为是上游&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中的一个显式&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;。这意味着如果查询返回了三个IP地址，Envoy会认为&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中有三个&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;，并且都可以被负载均衡到。&lt;/p&gt;

&lt;h5 id=&quot;logical-dns&quot;&gt;Logical DNS&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Logical DNS&lt;/code&gt;使用和&lt;code class=&quot;highlighter-rouge&quot;&gt;strict DNS&lt;/code&gt;相似的解析策略。然而，当一个新的连接需要被初始化时，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;logical DNS cluster'&lt;/code&gt;只使用返回结果中的第一个IP地址。因此，一个逻辑连接池可能包含对不同上游&lt;code class=&quot;highlighter-rouge&quot;&gt;hosts&lt;/code&gt;的许多物理连接。&lt;/p&gt;

&lt;h5 id=&quot;endpoint-discovery-serviceeds&quot;&gt;Endpoint discovery service(EDS)&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt;成员在Envoy术语中叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;endpoint&lt;/code&gt;。Envoy通过发现服务从每个&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中获取&lt;code class=&quot;highlighter-rouge&quot;&gt;endpoints&lt;/code&gt;。EDS由于下面的原因是推荐的服务发现机制：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Envoy有显式的每个上游&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;的知识(和通过DNS解析负载均衡器相比)并能作出更智能的负载均衡决策&lt;/li&gt;
  &lt;li&gt;在每个&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;discovery API&lt;/code&gt;响应中携带的额外属性能告知Envoy&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;的负载均衡比，状态等。这些额外的属性可被Envoy网格使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;on-eventually-consistent-service-discovery&quot;&gt;On eventually consistent service discovery&lt;/h4&gt;
&lt;p&gt;Envoy从最开始的设计目标就是服务发现不需要全一致性，而是假设进出的&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;是最终一致的。我们建议在部署服务对服务的Envoy网格配置时，使用最终一致的服务发现(伴随主动健康检查)来决定&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;是否健康。这一范式有下列好处：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;所有的健康决策被完全分布了。因此，网络分区问题被优雅的解决了&lt;/li&gt;
  &lt;li&gt;当健康检查被一个上游&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;配置，Envoy使用一个2×2矩阵来决定是否路由到该&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Discovery Status&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Health Check OK&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Healtch Check Failed&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Discovered&lt;/td&gt;
      &lt;td&gt;Route&lt;/td&gt;
      &lt;td&gt;Don’t Route&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Absent&lt;/td&gt;
      &lt;td&gt;Route&lt;/td&gt;
      &lt;td&gt;Don’t Route/Delete&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Tonfeiz</name></author><summary type="html">本周对envoy的介绍文档仔细的阅读了一遍。在此将笔记记录如下。</summary></entry><entry><title type="html">Arts Weekten High Performance Server(二)</title><link href="http://localhost:4000/ARTS-WeekTen-High-Performance-Server(%E4%BA%8C)/" rel="alternate" type="text/html" title="Arts Weekten High Performance Server(二)" /><published>2019-06-12T00:00:00+08:00</published><updated>2019-06-12T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekTen-High-Performance-Server(%E4%BA%8C)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekTen-High-Performance-Server(%E4%BA%8C)/">&lt;p&gt;接下去介绍高性能服务器设计的最后两个因素。&lt;/p&gt;

&lt;h2 id=&quot;memory-allocation&quot;&gt;Memory allocation&lt;/h2&gt;
&lt;p&gt;内存分配是制约服务器性能的一大瓶颈。&lt;/p&gt;

&lt;p&gt;作者提出了三种方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;预分配内存。动态分配内存的好处是不会浪费空间，然而需要消耗时间。如果有些内存分配是必需的，在程序运行前就可以确定的，则可以进行预分配，即便这样会浪费一些内存。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;look aside&lt;/code&gt;列表。其基本思想是对于要释放的对象不立即释放，而是将它加入到一个列表中。这样，，多个私有列表来保持较低的分配开支如果短时间内又需要用到该对象，则不重新分配而是从链表中获取即可。对于&lt;code class=&quot;highlighter-rouge&quot;&gt;look aside&lt;/code&gt;列表的使用，显然不能让其无限制变多，因此作者提出采用新旧列表的方法，既避免了过多的锁争用，又能释放无用对象的内存。&lt;/li&gt;
  &lt;li&gt;在分配内存时会出现锁争用的情况，即使使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;look aside&lt;/code&gt;列表也是如此。该情况是内存分配消耗最大的情况。为了避免该情况，可以维护多个私有的&lt;code class=&quot;highlighter-rouge&quot;&gt;look aside&lt;/code&gt;列表。例如，可以给每个线程分配一个该列表，这样就避免了锁争用。或者是一个处理器一个列表。必要时也可以用一个共享列表，多个私有列表来保持较低的分配开支&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;lock-contention&quot;&gt;Lock Contention&lt;/h2&gt;
&lt;p&gt;这一块由于接触的太少，我还看不太懂，暂时就先不翻译了。&lt;/p&gt;

&lt;h2 id=&quot;other-stuff&quot;&gt;Other Stuff&lt;/h2&gt;
&lt;p&gt;作者提出了一些其他的问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于较大或较小的请求你的存储子系统表现如何？序列化或随机化请求呢？&lt;code class=&quot;highlighter-rouge&quot;&gt;read-ahead&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;write-behind&lt;/code&gt;工作情况如何？&lt;/li&gt;
  &lt;li&gt;你正在使用的网络协议效率如何？有没有你能设置的参数或者标志能使其工作的更好？有没有像&lt;code class=&quot;highlighter-rouge&quot;&gt;TCP_CORK&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;MSG_PUSH&lt;/code&gt;或是Nagle这样的技巧使其避免较小的信息？&lt;/li&gt;
  &lt;li&gt;你的系统支持离散/聚合IO(readv/writev)吗？使用该技术能提高性能并避免使用缓冲区的链的痛苦&lt;/li&gt;
  &lt;li&gt;页的大小是多少？缓存行的大小是多少？在这些大小上对齐值得吗？系统调用或者上下文切换比起其他东西的开销来说如何？&lt;/li&gt;
  &lt;li&gt;你的读/写锁会饥饿吗？你的事件有惊群效应吗？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;问题有很多，这些问题都是值得思考的。应当对于不同的平台都了解上面的东西，哪怕只是经验值。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">接下去介绍高性能服务器设计的最后两个因素。</summary></entry><entry><title type="html">Arts Weekten Progit(二)</title><link href="http://localhost:4000/ARTS-WeekTen-ProGit(%E4%BA%8C)/" rel="alternate" type="text/html" title="Arts Weekten Progit(二)" /><published>2019-06-12T00:00:00+08:00</published><updated>2019-06-12T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekTen-ProGit(%E4%BA%8C)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekTen-ProGit(%E4%BA%8C)/">&lt;p&gt;本章讲述Git的基础知识。&lt;/p&gt;

&lt;h2 id=&quot;git基础&quot;&gt;Git基础&lt;/h2&gt;
&lt;h3 id=&quot;获取git-repo&quot;&gt;获取Git Repo&lt;/h3&gt;
&lt;p&gt;有两种获取Git Repo的方法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将本地未纳入版本控制的目录转变为Git repo&lt;/li&gt;
  &lt;li&gt;从其他地方克隆Git repo&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;在已存在的目录中初始化repo&quot;&gt;在已存在的目录中初始化Repo&lt;/h4&gt;
&lt;p&gt;在已存在的目录中输入
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git init&lt;/code&gt;&lt;br /&gt;
即可。&lt;/p&gt;

&lt;p&gt;该命令会在目录中创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;的子目录，其中包含了所有必要的repo文件。此时，工程中没有任何文件被追踪。&lt;/p&gt;

&lt;p&gt;如果想要开始对已存在的文件进行版本控制，可以输入下面命令&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add *.c
$ git add LICENSE
$ git commit -m &quot;initial project version&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;克隆已存在的repo&quot;&gt;克隆已存在的Repo&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt;可以用来克隆已存在的文件。与其他版本控制系统常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;checkout&lt;/code&gt;不同，这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;表示Git会把已存在Repo中所有的文件的所有版本都克隆到本地，而不是只拷贝当前版本的文件。&lt;/p&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone &amp;lt;url&amp;gt;&lt;/code&gt;可以克隆repo。例如：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git clone https://github.com/libgit2/libgit2&lt;/code&gt;&lt;br /&gt;
创建了一个名叫&lt;code class=&quot;highlighter-rouge&quot;&gt;libgit2&lt;/code&gt;的目录，在其中初始化了&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;目录，将该库的数据都拉到其中，并签出(&lt;code class=&quot;highlighter-rouge&quot;&gt;checkout&lt;/code&gt;)了最新版本的文件。&lt;/p&gt;

&lt;h3 id=&quot;记录repo的变化&quot;&gt;记录Repo的变化&lt;/h3&gt;
&lt;p&gt;每个工作目录中的文件有两个状态：&lt;em&gt;tracked&lt;/em&gt;或是&lt;em&gt;untracked&lt;/em&gt;。&lt;em&gt;tracked&lt;/em&gt;的文件是在上一个快照中的文件；它们可以是未修改的(&lt;code class=&quot;highlighter-rouge&quot;&gt;unmodified&lt;/code&gt;)，修改的(&lt;code class=&quot;highlighter-rouge&quot;&gt;modified&lt;/code&gt;)和暂存的(&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;几个状态之间的转移图如图所示。&lt;br /&gt;
&lt;img src=&quot;./git_status_change.png&quot; alt=&quot;文件状态生命周期&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;检查文件状态&quot;&gt;检查文件状态&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;可用来检查文件的状态。&lt;/p&gt;

&lt;p&gt;例如，假设刚刚&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;了一个repo，则此时使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令一般显示如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这表明工作目录是干净的，即你所跟踪(&lt;code class=&quot;highlighter-rouge&quot;&gt;track&lt;/code&gt;)的文件都没有被修改&lt;/p&gt;

&lt;p&gt;如果添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;README&lt;/code&gt;文件，则它是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;untracked&lt;/code&gt;文件，目录的状态就发生了变化&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo 'My Project' &amp;gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
(use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
README
nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;untracked&lt;/code&gt;文件表示该文件没有出现在上一次&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;的快照中&lt;/p&gt;

&lt;h4 id=&quot;跟踪新文件&quot;&gt;跟踪新文件&lt;/h4&gt;
&lt;p&gt;可通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;命令跟踪新文件。例如&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git add README&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此时运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令，则输出为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:  README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在该文件就处于暂存(&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;)状态了。该状态下对文件的改变等待被&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;暂存修改后文件&quot;&gt;暂存修改后文件&lt;/h4&gt;
&lt;p&gt;如果修改了一个之前跟踪的文件，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;，然后运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;,则输出为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    new file:  README
Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
    modified:  CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;文件被修改了，但还没有位于暂存区中，需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;命令将其加入暂存区。&lt;/p&gt;

&lt;p&gt;运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;命令后状态如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    new file: README
    modified: CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果此时调用&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，则两个文件都会被加入快照中。如果此时你修改了&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;文件，则&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令的输出会是&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    new file: README
    modified: CONTRIBUTING.md

Changes not staged for commit:
 (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
 (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
    modified: CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;既是&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;又是&lt;code class=&quot;highlighter-rouge&quot;&gt;unstaged&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;的文件是上一次&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;加进去的，而后面修改内容的文件处于&lt;code class=&quot;highlighter-rouge&quot;&gt;unstaged&lt;/code&gt;状态。如果现在&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，则快照中的文件仍然是修改之前的，即&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;状态的文件。&lt;/p&gt;

&lt;h4 id=&quot;忽略文件&quot;&gt;忽略文件&lt;/h4&gt;
&lt;p&gt;Git可通过在&lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt;文件中设置对应的语法规则来使得Git在添加、提交等操作时忽略一些文件，例如程序构建后的文件、构建过程中的目标文件、临时文件等。其中的语法这里不再详细介绍，当用到时去查看即可。&lt;/p&gt;

&lt;h4 id=&quot;观看暂存以及未暂存的改变&quot;&gt;观看暂存以及未暂存的改变&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令的输出太模糊、宽泛了——你知道文件的状态，但不知道文件的内容发生了什么变化。&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt;命令可用于观看这些变化。&lt;/p&gt;

&lt;p&gt;例如，假设你编辑并且暂存了&lt;code class=&quot;highlighter-rouge&quot;&gt;README&lt;/code&gt;文件，编辑了&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;文件但没有暂存它，则&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;的输出是&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
 (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    modified: README
Changes not staged for commit:
 (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
 (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
    modified: CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了观看改变的但是没有暂存的内容，直接输入&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;if we have to read the whole diff to figure out why you're contributing in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive +chunks if your patch is longer than a dozen lines.

If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it's
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该命令比较工作目录和暂存区的差异。因此结果就是告诉你你所改变的没有暂存的内容。&lt;/p&gt;

&lt;p&gt;如果想看已经暂存的(即将要进入下一次&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;中的)内容，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff --staged&lt;/code&gt;。该命令比较暂存区和上一次&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;的内容的变化&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;提交发生的改变&quot;&gt;提交发生的改变&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;命令可以将暂存区中的内容加入到快照当中。&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;命令会打开默认编辑器让你键入&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;的相关信息。也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &amp;lt;message&amp;gt;&lt;/code&gt;来输入信息。&lt;/p&gt;

&lt;p&gt;记住，只有暂存区的内容会加入快照当中，不在暂存区的修改都会是&lt;code class=&quot;highlighter-rouge&quot;&gt;modified&lt;/code&gt;状态。&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;命令的本质是创建一个暂存区的快照。&lt;/p&gt;

&lt;h4 id=&quot;跳过暂存区&quot;&gt;跳过暂存区&lt;/h4&gt;
&lt;p&gt;通过给&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;命令传递&lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt;选项可以使其跳过暂存阶段。该选项会将所有跟踪的改变内容的文件暂存(注意：未跟踪的文件不会被暂存！)&lt;/p&gt;

&lt;h4 id=&quot;删除文件&quot;&gt;删除文件&lt;/h4&gt;
&lt;p&gt;为了从Git中删除文件，需要删除跟踪着的文件然后&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt;会删除跟踪着的文件。工作目录中的对应文件也会被删除。&lt;/p&gt;

&lt;p&gt;如果只是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt;命令删除，则该改变使得Git进入下面的状态&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
 (use &quot;git add/rm &amp;lt;file&amp;gt;...&quot; to update what will be committed)
 (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
    deleted: PROJECTS.md
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt;命令，则对应的文件会从暂存区中删除&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
 (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    deleted: PROJECTS.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;接着&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;即可。如果对文件进行了修改(处于&lt;code class=&quot;highlighter-rouge&quot;&gt;modified&lt;/code&gt;状态，未加入暂存区)或已经将它加入暂存区(没有&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;)，则需要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;选项强制删除。&lt;/p&gt;

&lt;p&gt;有时候或许只想从暂存区中删除文件，而希望在硬盘上保留它。也就是说，希望Git不再跟踪该文件，则可以给&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt;命令加上&lt;code class=&quot;highlighter-rouge&quot;&gt;--cached&lt;/code&gt;选项。&lt;/p&gt;

&lt;h4 id=&quot;移动文件&quot;&gt;移动文件&lt;/h4&gt;
&lt;p&gt;Git不显式跟踪文件的移动。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
 (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    renamed: README.md -&amp;gt; README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的命令和下面的命令是等价的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mv README.md README
$ git rm README.md
$ git add README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">本章讲述Git的基础知识。</summary></entry><entry><title type="html">Arts Weekten Leetcode779 Kth Symbol</title><link href="http://localhost:4000/ARTS-WeekTen-Leetcode779-Kth-Symbol/" rel="alternate" type="text/html" title="Arts Weekten Leetcode779 Kth Symbol" /><published>2019-06-11T00:00:00+08:00</published><updated>2019-06-11T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekTen-Leetcode779-Kth-Symbol</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekTen-Leetcode779-Kth-Symbol/">&lt;p&gt;On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.&lt;/p&gt;

&lt;p&gt;Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).&lt;/p&gt;

&lt;p&gt;Examples:&lt;br /&gt;
Input: N = 1, K = 1&lt;br /&gt;
Output: 0&lt;/p&gt;

&lt;p&gt;Input: N = 2, K = 1&lt;br /&gt;
Output: 0&lt;/p&gt;

&lt;p&gt;Input: N = 2, K = 2&lt;br /&gt;
Output: 1&lt;/p&gt;

&lt;p&gt;Input: N = 4, K = 5&lt;br /&gt;
Output: 1&lt;/p&gt;

&lt;p&gt;row 1: 0&lt;br /&gt;
row 2: 01&lt;br /&gt;
row 3: 0110&lt;br /&gt;
row 4: 01101001&lt;br /&gt;
—
这题还是很有意思的。最直观的解法是生成第N行然后直接索引第K个，然而很快就会发现，第row行的字符数量是&lt;code class=&quot;highlighter-rouge&quot;&gt;$2^(N-1)$&lt;/code&gt;，显然是放不下的。因此还要有其他方法。&lt;/p&gt;

&lt;p&gt;我自己的解法是比较复杂的，主要是通过观察数列规律得出。很显然，可以根据K和N分为下列情况（假设middle是第N行的中间位置,f(N,K)是想要寻找的数字)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;K &amp;lt; middle, 此时就是第N-1行的对应索引，即f(N, K) = f(N-1, K)&lt;/li&gt;
  &lt;li&gt;K &amp;gt; middle,此时要分N是奇数还是偶数
    &lt;ul&gt;
      &lt;li&gt;N为奇数时，此时N行左半边和右半边对称，因此f(N, K) = f(N, middle * 2 - K + 1) = f(N - 1, middle * 2- K + 1)&lt;/li&gt;
      &lt;li&gt;N为偶数时，将数列划分为四等分，则必定是abba的形式，因此又分两种情况
        &lt;ul&gt;
          &lt;li&gt;K在右侧的左半边时，则位于abba中第2个b的位置，则可在第1个b中找到其对应位置，即f(N, K) = f(N, K - middle / 2) = f(N - 1, K - middle / 2)&lt;/li&gt;
          &lt;li&gt;K在右侧的右半边时，即位于abba中第2个a的位置，则可在第1个a中找到其对应位置，即f(N, K) = f(N, K - middle / 2 * 3) = f(N - 1, K - middle / 2 * 3)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基准情形则是N=1和N=2时的情况。总体来说，思路就是把N往小了化简。&lt;/p&gt;

&lt;p&gt;在看了解析之后，才发现其实很简单。把第N-1行的0看作第N行的0和1的父节点，第N-1行的1看作第N行的1和0的父节点。很显然，第N行中如果K是偶数，则它是父节点的右子节点，如果K是奇数，则它是父节点的左子节点。而只要确定了K对应的位置的父节点的数值，则K的数值就很简单就能确定。从子节点一直往上回溯直到找到基准情形即可。这种思路的代码非常简单，如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    int kthGrammar(int N, int K) {
	if (N == 1) return 0;
	if (K % 2 == 0) return (kthGrammar(N - 1, K / 2) == 0) ? 1 : 0;
	else return (kthGrammar(N - 1, (K + 1) / 2) == 0) ? 0 : 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我自己的代码复杂一些，这里也附上&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    int kthGrammar(int N, int K) {
        if(N == 1)
            return 0;   
        if(N == 2 &amp;amp;&amp;amp; K == 1)
            return 0;
        if(N == 2 &amp;amp;&amp;amp; K == 2)
            return 1;
        
        int middle = pow(2, N - 2);
        if(K &amp;lt;= middle)
            return kthGrammar(N-1, K);
        else if(K &amp;gt; middle &amp;amp;&amp;amp; N % 2)
            return kthGrammar(N - 1, middle * 2 - K + 1);
        else 
        {
            if(K &amp;lt;= 3 * middle / 2)
                return kthGrammar(N - 1, K - middle / 2);
            else
                return kthGrammar(N - 1, K - middle / 2 * 3);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.</summary></entry><entry><title type="html">Envoy学习之旅(三)</title><link href="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%B8%89)/" rel="alternate" type="text/html" title="Envoy学习之旅(三)" /><published>2019-06-10T00:00:00+08:00</published><updated>2019-06-10T00:00:00+08:00</updated><id>http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%B8%89)</id><content type="html" xml:base="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%B8%89)/">&lt;p&gt;上回修改了docker容器以及app实际监听的端口号。现在app在容器内部的8080端口号上监听，而我们访问则通过容器发布的8000端口号访问。接下去终于进入了正题，即使用envoy来代理对该app的访问。&lt;/p&gt;

&lt;h2 id=&quot;实现过程&quot;&gt;实现过程&lt;/h2&gt;
&lt;p&gt;首先小小的修改一下&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt;文件。在其中&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;下面添加一个选项&lt;code class=&quot;highlighter-rouge&quot;&gt;volumes&lt;/code&gt;,如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;volumes:
    - ./service-envoy.yaml:/etc/service-envoy.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这句话的意思是把当前目录下的配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;service-envoy.yaml&lt;/code&gt;挂在到容器中的&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;然后把&lt;code class=&quot;highlighter-rouge&quot;&gt;expose&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ports&lt;/code&gt;选项改成下面的样子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;expose:
    - &quot;80&quot;
ports:
    - &quot;8000:80&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至于为什么要改成这样，在后面马上会提到。&lt;/p&gt;

&lt;p&gt;接下去修改一下启动脚本，其中添加了&lt;code class=&quot;highlighter-rouge&quot;&gt;envoy&lt;/code&gt;的启动，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
python3 /code/hello_world_service.py &amp;amp;
envoy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; /etc/service-envoy.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，最关键的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;service-envoy.yaml&lt;/code&gt;文件了。&lt;code class=&quot;highlighter-rouge&quot;&gt;service-envoy.yaml&lt;/code&gt;文件和官网提供的例子很像，其内容如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 80
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        typed_config:
          &quot;@type&quot;: type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: service
              domains:
              - &quot;*&quot;
              routes:
              - match:
                  prefix: &quot;/&quot;
                route:
                  cluster: local_service
          http_filters:
          - name: envoy.router
            typed_config: {}
  clusters:
  - name: local_service
    connect_timeout: 0.25s
    type: strict_dns
    lb_policy: round_robin
    load_assignment:
      cluster_name: local_service
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: 0.0.0.0
                port_value: 8080
admin:
  access_log_path: &quot;/dev/null&quot;
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 8081
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的选项非常之多，我这里暂且不做详细的解释，在下面我阅读了envoy的官方文档，并将其中涉及到的重要选项列举一下。&lt;/p&gt;

&lt;p&gt;这里我只大概说一下文件所表达的意思。首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;envoy&lt;/code&gt;根据该文件创建了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;监听在端口号80上,&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;则监听在在端口号8080上。&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;根据过滤器的配置过滤、转发请求。这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;将前缀为&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;的所有请求转发给名字叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;local_service&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;,由&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;再给出回应。&lt;/p&gt;

&lt;p&gt;这里尤其要注意的是端口号。此处&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;的监听端口号是容器内部的端口号。因此在做端口映射时，主机端口应当映射到该端口，也因此&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt;中的文件中的端口相关选项做了修改。&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;的端口号应当是业务逻辑，即app中的监听端口号。&lt;/p&gt;

&lt;h2 id=&quot;相关envoy选项含义&quot;&gt;相关envoy选项含义&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* `static_resources`: 静态指定的资源  
  * `listeners`: 静态的监听者
    * `address`: 监听者监听的地址。通常，该地址应当是唯一的  
    * `filter_chains`: 一系列用于该监听者的过滤器链  
      * `filters`: 过滤器列表。注意：如果过滤器列表是空的，则连接默认将会关闭  
        * `name`: 要实例化的滤波器的名字。该名字必须匹配一个支持的滤波器。内置的滤波器包括：  
          * `envoy.echo`  
          * `envoy.http_connection_manager`  
          * `envoy.tcp_proxy`
        还有一些，这里不列出了  
        * `config`与`typed_config`: 与选定的过滤器名字相关，下面以`envoy.http_connection_manager`为例  
          * `codec_type`: 编码译码类型  
          * `stat_prefix`: 发送统计信息时人可阅读的前缀。  
          * `route_config`: `connection_manager`的路由表。  
            * `name`: 路由配置的名字。  
            * `virtual_hosts`: 组成路由表的虚拟主机列表  
              * `name`: 虚拟主机的逻辑名字。当发送特定的统计信息时被使用，但和路由无关  
              * `domains`: 将匹配到该虚拟主机的域名。也可以使用通配符匹配  
              * `routes`: 将被匹配的路由列表。第一个匹配的路由将被使用  
                * `match`: 路由匹配参数  
                * `route`: 将请求路由给上游的`cluster`  
                  * `cluster`: 指定请求将要传给哪个上游`cluster`  
          * `http_filters`: http的过滤器列表  
            * `name`: 要实例的过滤器名字。一些特定的过滤器包括  
              * `envoy.buffer`  
              * `envoy.gzip`  
              * `envoy.rate_limit`  
              * `envoy.router`  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">上回修改了docker容器以及app实际监听的端口号。现在app在容器内部的8080端口号上监听，而我们访问则通过容器发布的8000端口号访问。接下去终于进入了正题，即使用envoy来代理对该app的访问。</summary></entry><entry><title type="html">Arts Weeknine High Performance Server(一)</title><link href="http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(%E4%B8%80)/" rel="alternate" type="text/html" title="Arts Weeknine High Performance Server(一)" /><published>2019-06-09T00:00:00+08:00</published><updated>2019-06-09T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(%E4%B8%80)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(%E4%B8%80)/">&lt;p&gt;这篇英文文章讲的是高性能服务器设计的一些要点。&lt;br /&gt;
原文链接为&lt;img src=&quot;http://pl.atyp.us/content/tech/servers.html&quot; alt=&quot;High-Performance Server Architecture&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-copies&quot;&gt;Data Copies&lt;/h2&gt;
&lt;p&gt;数据拷贝可能被掩盖或是伪装。在第三方库中或是驱动中都可能进行许多数据拷贝。一个明显的例子是哈希。&lt;/p&gt;

&lt;p&gt;一种方法是使用缓冲区描述符而不是单纯的缓冲区指针。每个描述符由下列事项组成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一个指针以及缓冲区的长度&lt;/li&gt;
  &lt;li&gt;一个指针或是偏移值以及长度。指针指向实际填充区域的开始，偏移也是，长度是实际填充的长度&lt;/li&gt;
  &lt;li&gt;指向其他缓冲区的前向以及后向指针&lt;/li&gt;
  &lt;li&gt;引用计数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述方法在某些情况下工作的很好，然而有时候也会让人头疼。这是因为在缓冲区链的前面和后面添加缓冲区是很方便的，但在中间添加缓冲区或是指向部分缓冲区等操作非常麻烦。&lt;/p&gt;

&lt;p&gt;作者不建议使用上述方法。最好的方法是识别出程序中的大对象并分别分配它们以避免拷贝。&lt;/p&gt;

&lt;p&gt;作者最后提醒，不要过分防止数据拷贝。过分防止数据拷贝可能导致代码变得更混乱、复杂。&lt;/p&gt;

&lt;h2 id=&quot;context-switches&quot;&gt;Context Switches&lt;/h2&gt;
&lt;p&gt;当系统在线程间来回切换的时间比它在一个线程内干实际的活所消耗的时间还多时，上下文切换就严重拖慢了系统效率。&lt;/p&gt;

&lt;p&gt;造成上述现象的第一个原因是活跃线程数比处理器数量要多，因此可扩展的系统通常会限制活跃线程的数量。&lt;/p&gt;

&lt;p&gt;通常在前端需要使用select/poll,异步IO,信号或是completion ports等事件驱动机制来使得一个线程处理多个连接。&lt;/p&gt;

&lt;p&gt;最简单的多线程事件驱动服务器维护一个队列，每个请求被一个或多个&lt;code class=&quot;highlighter-rouge&quot;&gt;listeners&lt;/code&gt;监听并放入队列，而&lt;code class=&quot;highlighter-rouge&quot;&gt;worker threads&lt;/code&gt;从队列中取出任务。然而，这样做也会拖慢系统。上下文切换的第二个原因就是从一个线程到另一个线程传递任务。较好的设计应当是&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;能变成&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;再变回&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如何限制活跃线程的数量呢？作者提出使用最简单的方法：信号量。活跃线程首先获取信号量再执行工作。&lt;/p&gt;

&lt;p&gt;作者接着提出，可以将对请求的处理分为多个阶段，通过阶段分发函数的返回值确定。例如:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;请求需要传给下一个阶段(ID或是指针作为返回值)&lt;/li&gt;
  &lt;li&gt;请求已经被完成(特殊的”请求完成”返回值)&lt;/li&gt;
  &lt;li&gt;请求被阻塞(特殊的”请求阻塞”返回值)。这和前面的阶段一样，但该请求未被释放，会在其他线程继续&lt;br /&gt;
在上面的模型中，请求的排队在阶段内完成，而不是阶段之间。这避免了将请求压入成功阶段的队列然后进入成功阶段又取出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者最后对SEDA发表了自己的看法。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SEDA的批处理将多个请求通过一个阶段处理，作者提出的方法将单个请求通过多个阶段处理&lt;/li&gt;
  &lt;li&gt;学术研究角度而言，用java完成SEDA是有意义的。实际工程中也许并不好&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Tonfeiz</name></author><summary type="html">这篇英文文章讲的是高性能服务器设计的一些要点。 原文链接为</summary></entry><entry><title type="html">Envoy学习之旅(二)</title><link href="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%BA%8C)/" rel="alternate" type="text/html" title="Envoy学习之旅(二)" /><published>2019-06-09T00:00:00+08:00</published><updated>2019-06-09T00:00:00+08:00</updated><id>http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%BA%8C)</id><content type="html" xml:base="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%BA%8C)/">&lt;p&gt;在完成了docker中运行app之后，需要将envoy作为app的代理。其他服务通过envoy与app进行交互。然而，之前使用了相同的端口号，这容易产生混淆，因此想修改两个端口不一致以区分。&lt;/p&gt;

&lt;h2 id=&quot;docker-compose内容说明&quot;&gt;docker compose内容说明&lt;/h2&gt;
&lt;p&gt;在进一步深入之前，由于对docker compose知识的缺乏，这里去了解了一下其中用到的各个字段，记录如下。&lt;/p&gt;

&lt;p&gt;docker compose中有top-level的key，该key在配置文件中定义了一个区域，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;deploy&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;depends_on&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;networks&lt;/code&gt;等。在该key的下面列出了支持他们作为子主题的选项。因此，一般映射是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;key&amp;gt;: &amp;lt;option&amp;gt;: &amp;lt;value&amp;gt;&lt;/code&gt;这样的。&lt;/p&gt;

&lt;h3 id=&quot;service-configuration-reference&quot;&gt;Service configuration reference&lt;/h3&gt;
&lt;p&gt;Service定义(&lt;code class=&quot;highlighter-rouge&quot;&gt;services:&lt;/code&gt;)包含了每个为了该服务启动的容器的配置，很像给&lt;code class=&quot;highlighter-rouge&quot;&gt;docker container create&lt;/code&gt;传递参数。与此类似的，网络和卷的定义和&lt;code class=&quot;highlighter-rouge&quot;&gt;docker network create&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;docker volume create&lt;/code&gt;很像。&lt;/p&gt;

&lt;h4 id=&quot;build&quot;&gt;build&lt;/h4&gt;
&lt;p&gt;包含在构建时的配置选项。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;可以被指定为一个包含构建上下文的路径字符串，也可以使用对象的形式指定，例如&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: &quot;3.7&quot;
services:
  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
	buildno: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;context&quot;&gt;CONTEXT&lt;/h5&gt;
&lt;p&gt;可以是一个包含Dockerfile的目录路径，也可以是到一个git repo的url&lt;/p&gt;

&lt;h5 id=&quot;dockerfile&quot;&gt;DOCKERFILE&lt;/h5&gt;
&lt;p&gt;可选的Dockerfile&lt;/p&gt;

&lt;h4 id=&quot;expose&quot;&gt;expose&lt;/h4&gt;
&lt;p&gt;暴露端口且不向主机发布它们 - 它们将只能由链到的接服务所接触。只有内在的端口可以被指定。&lt;/p&gt;

&lt;p&gt;这里指的是app使用的端口号，而不是docker容器对外暴露的端口号&lt;/p&gt;

&lt;h4 id=&quot;networks&quot;&gt;networks&lt;/h4&gt;
&lt;p&gt;要加入的网络&lt;/p&gt;

&lt;h5 id=&quot;aliases&quot;&gt;ALIASES&lt;/h5&gt;
&lt;p&gt;在网络上该服务的别名。相同网络中的其他容器可以使用服务名或是此别名来连接到服务的其中一个容器。&lt;/p&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;aliases&lt;/code&gt;是网络范围内的，相同的服务可以在不同的网络中使用不同的别名。&lt;/p&gt;

&lt;p&gt;一种通用格式是这样的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;services:
  some-service:
    networks:
      some-network:
        aliases:
         - alias1
	 - alias3
      other-network:
        aliases:
         - alias2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ports&quot;&gt;ports&lt;/h4&gt;
&lt;p&gt;暴露端口&lt;/p&gt;

&lt;h5 id=&quot;short-syntax&quot;&gt;SHORT SYNTAX&lt;/h5&gt;
&lt;p&gt;指定两个端口号(&lt;code class=&quot;highlighter-rouge&quot;&gt;HOST:CONTAINER&lt;/code&gt;),或者只有容器端口(一个短暂的host端口将被选择)&lt;/p&gt;

&lt;p&gt;后面的是容器内部的端口，即app监听端口，前面的是暴露端口，即我们访问docker容器的端口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ports:
 - &quot;3000&quot;
 - &quot;3000-3005&quot;
 - &quot;8000:8000&quot;
 - &quot;9090-9091:8080-8081&quot;
 - &quot;49100:22&quot;
 - &quot;127.0.0.1:8001:8001&quot;
 - &quot;127.0.0.1:5000-5010:5000-5010&quot;
 - &quot;6060:6060/udp&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;long-syntax&quot;&gt;LONG SYNTAX&lt;/h5&gt;
&lt;p&gt;较长形式的语法允许对不能被短语法形式表现的配置域。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;:容器内部的端口&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;published&lt;/code&gt;:公开暴露的端口&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;protocol&lt;/code&gt;:端口的协议(&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp&lt;/code&gt;或是&lt;code class=&quot;highlighter-rouge&quot;&gt;udp&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt;: 在每个节点上都发布一个host端口则是&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;,在需要负载均衡的swarm模式下的端口则是&lt;code class=&quot;highlighter-rouge&quot;&gt;ingress&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ports:
  - target: 80
    published: 8080
    protocol: tcp
    mode: host
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改端口&quot;&gt;修改端口&lt;/h2&gt;
&lt;p&gt;app监听端口仍为8080，将容器暴露端口改为8000，docker-compose文件的格式为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;expose:
- &quot;8080&quot;
ports:
- &quot;8000:8080&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，就可以通过8000端口号访问服务了。&lt;/p&gt;

&lt;p&gt;中间由于对端口的配置理解有误，自己尝试了各种端口号配置，记录如下。app的监听端口号不变是8080。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;expose&lt;/th&gt;
      &lt;th&gt;ports&lt;/th&gt;
      &lt;th&gt;访问&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8000:8000”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8000:8080”&lt;/td&gt;
      &lt;td&gt;8080&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8000:8080”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;成功&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8080:8000”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8080:8000”&lt;/td&gt;
      &lt;td&gt;8080&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8080”&lt;/td&gt;
      &lt;td&gt;“8000:8080”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;成功&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8080”&lt;/td&gt;
      &lt;td&gt;“8000:8080”&lt;/td&gt;
      &lt;td&gt;8080&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8080”&lt;/td&gt;
      &lt;td&gt;“8080:8000”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8080”&lt;/td&gt;
      &lt;td&gt;“8080:8000”&lt;/td&gt;
      &lt;td&gt;8080&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从上面表格可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;expose&lt;/code&gt;的作用感觉不大，&lt;code class=&quot;highlighter-rouge&quot;&gt;ports&lt;/code&gt;中前面的端口可以自己配置，访问时需访问该端口。后面的端口需要和app监听端口保持一致，否则访问也会失败。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">在完成了docker中运行app之后，需要将envoy作为app的代理。其他服务通过envoy与app进行交互。然而，之前使用了相同的端口号，这容易产生混淆，因此想修改两个端口不一致以区分。</summary></entry><entry><title type="html">Arts Weeknine Progit(一)</title><link href="http://localhost:4000/ARTS-WeekNine-ProGit(%E4%B8%80)/" rel="alternate" type="text/html" title="Arts Weeknine Progit(一)" /><published>2019-06-06T00:00:00+08:00</published><updated>2019-06-06T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekNine-ProGit(%E4%B8%80)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekNine-ProGit(%E4%B8%80)/">&lt;p&gt;git可说是目前最常用的版本控制系统之一，虽然之前也曾经学过，但并没有深刻理解其中的原理，因此就下载了Pro Git这本书，争取把git里里外外都搞个通透。&lt;/p&gt;

&lt;h2 id=&quot;一基本信息&quot;&gt;一、基本信息&lt;/h2&gt;
&lt;h3 id=&quot;版本控制&quot;&gt;版本控制&lt;/h3&gt;
&lt;p&gt;在日常生活中，我们编辑文件。随着时间的流逝，文件数目越来越多，对文件的修改也越来越多。有时我们修改错误，想要找回上一个版本的东西。有时在不同的场合下，我们想换一个版本使用。这就诞生出了版本控制，即控制我们开发的东西的不同版本，并且具备回退等能力。&lt;/p&gt;

&lt;p&gt;通常由三种版本控制系统：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;本地控制，即自己手动通过文件名等手段标志出版本信息&lt;/li&gt;
  &lt;li&gt;中心化版本控制，文件存在一个中心服务器，任何想要文件的人通过服务器获取最新文件并编辑&lt;/li&gt;
  &lt;li&gt;分布式版本控制，每个机器都把文件以及版本信息复制下来，这样当一个服务器失效，任何一台机器都可顶替服务器的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;git的一些基本概念&quot;&gt;Git的一些基本概念&lt;/h3&gt;
&lt;h4 id=&quot;快照而不是差别&quot;&gt;快照，而不是差别&lt;/h4&gt;
&lt;p&gt;其他的VCS大多把一个版本一个版本的更迭视为对文件的修改，即他们存下文件，而以后的版本是对文件作出修改。Git则把每个版本视为对当前文件的一个快照。在git中，每次commit或是保存当前工程的状态，git都会记录当前你的所有文件看起来是怎么样的并且保存一个到该快照的引用。对于未修改的文件，git则会有到上一个版本该文件的引用，而不重新保存。&lt;/p&gt;

&lt;h4 id=&quot;几乎所有操作都是本地的&quot;&gt;几乎所有操作都是本地的&lt;/h4&gt;
&lt;p&gt;由于git在本地电脑上保留了所有的版本控制信息，因此提交等操作不需要依赖于服务器，只需在本地进行即可。其他的VCS在提交、浏览过去版本信息等操作中往往需要和中心服务器取得联络，这就要求必须由互联网，且造成了网络通信的开销。&lt;/p&gt;

&lt;h4 id=&quot;三个状态&quot;&gt;三个状态&lt;/h4&gt;
&lt;p&gt;git中有三个区域：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;工作区：即放置工作文件的位置，是工程的一个签出版本&lt;/li&gt;
  &lt;li&gt;暂存区：是包含在Git目录中的一个文件，其中存储了将放入下一个commit中的信息&lt;/li&gt;
  &lt;li&gt;Git目录区：是Git放置元数据和对象数据库的地方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此引入了三种状态，在工作区中修改但还没加入暂存区的状态是&lt;em&gt;modified&lt;/em&gt;，在暂存区中但还没加入Git目录区(即还没commit)的状态是&lt;em&gt;staged&lt;/em&gt;,在Git目录区中的状态是&lt;em&gt;commited&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;初次设置&quot;&gt;初次设置&lt;/h3&gt;
&lt;p&gt;Git有一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;git config&lt;/code&gt;的工具能设置那些控制Git操作的变量。这些变量存在三个不同的地方：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/config&lt;/code&gt;:包含应用到系统中所有人的值。如果给&lt;code class=&quot;highlighter-rouge&quot;&gt;git config&lt;/code&gt;传递&lt;code class=&quot;highlighter-rouge&quot;&gt;--system&lt;/code&gt;选项，则它会从这个文件中读写&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.gitconfig&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.config/git/config&lt;/code&gt;:该值影响的是当前用户。可以传递&lt;code class=&quot;highlighter-rouge&quot;&gt;--global&lt;/code&gt;选项来让Git从中读写。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config&lt;/code&gt;文件：该文件在Git目录中(&lt;code class=&quot;highlighter-rouge&quot;&gt;.git/config&lt;/code&gt;)，影响的是当前的仓库。通过&lt;code class=&quot;highlighter-rouge&quot;&gt;--local&lt;/code&gt;选项即可让Git从中读写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个层级的值都会覆盖上层的值&lt;/p&gt;

&lt;h4 id=&quot;认证身份&quot;&gt;认证身份&lt;/h4&gt;
&lt;p&gt;首次安装Git后需要配置用户的名字和邮箱，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --global user.name &quot;${USER_NAME}&quot;  
$ git config --global user.email ${USER_EMAIL}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">git可说是目前最常用的版本控制系统之一，虽然之前也曾经学过，但并没有深刻理解其中的原理，因此就下载了Pro Git这本书，争取把git里里外外都搞个通透。</summary></entry><entry><title type="html">Arts Weeknine Leetcode942 Distringmatch</title><link href="http://localhost:4000/ARTS-WeekNine-Leetcode942-DIStringMatch/" rel="alternate" type="text/html" title="Arts Weeknine Leetcode942 Distringmatch" /><published>2019-06-05T00:00:00+08:00</published><updated>2019-06-05T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekNine-Leetcode942-DIStringMatch</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekNine-Leetcode942-DIStringMatch/">&lt;p&gt;Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length.&lt;/p&gt;

&lt;p&gt;Return any permutation A of [0, 1, …, N] such that for all i = 0, …, N-1:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If S[i] == “I”, then A[i] &amp;lt; A[i+1]&lt;/li&gt;
  &lt;li&gt;If S[i] == “D”, then A[i] &amp;gt; A[i+1]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;p&gt;Input: “IDID”&lt;br /&gt;
Output: [0,4,1,3,2]&lt;/p&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;p&gt;Input: “III”&lt;br /&gt;
Output: [0,1,2,3]&lt;/p&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;p&gt;Input: “DDI”&lt;br /&gt;
Output: [3,2,0,1]&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题的意思是对于一个由”I”和”D”组成的序列，”I”表示增加,”D”表示减少，则根据该序列，给出一个由0到N组成的满足上面序列的数字序列。&lt;/p&gt;

&lt;p&gt;这题刚开始思考了一下，有点摸不着头脑，但后来发现，只要遇到”I”则放入当前能放入的最小的数，遇到”D”则放入当前能放入的最大的数，最后两者肯定汇聚到某个数，最后再放入汇聚的数即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; diStringMatch(string S) {
        int left = 0, right = S.size();
        
        vector&amp;lt;int&amp;gt; res(right + 1);
        
        for(int i = 0; i &amp;lt; S.size(); ++i) {
            if(S[i] == 'I') {
                res[i] = left;
                left++;
            } else {
                res[i] = right;
                right--;
            }
        }
        
        res[res.size() - 1] = left;
        
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length.</summary></entry></feed>