<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.7.4">Jekyll</generator>
<link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
<link href="http://localhost:4000/" rel="alternate" type="text/html" />
<updated>2019-06-12T15:14:51+08:00</updated>
<id>http://localhost:4000/</id>
<title>Tonfeiz</title>
<subtitle></subtitle>
<author>
<name>Tonfeiz</name>
</author>
<entry>
<title>Arts Weekten Progit(二)</title>
<link href="http://localhost:4000/ARTS-WeekTen-ProGit(%E4%BA%8C)/" rel="alternate" type="text/html" title="Arts Weekten Progit(二)" />
<published>2019-06-12T00:00:00+08:00</published>
<updated>2019-06-12T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekTen-ProGit(二)</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekTen-ProGit(%E4%BA%8C)/">&lt;p&gt;本章讲述Git的基础知识。&lt;/p&gt;

&lt;h2 id=&quot;git基础&quot;&gt;Git基础&lt;/h2&gt;
&lt;h3 id=&quot;获取git-repo&quot;&gt;获取Git Repo&lt;/h3&gt;
&lt;p&gt;有两种获取Git Repo的方法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将本地未纳入版本控制的目录转变为Git repo&lt;/li&gt;
  &lt;li&gt;从其他地方克隆Git repo&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;在已存在的目录中初始化repo&quot;&gt;在已存在的目录中初始化Repo&lt;/h4&gt;
&lt;p&gt;在已存在的目录中输入
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git init&lt;/code&gt;&lt;br /&gt;
即可。&lt;/p&gt;

&lt;p&gt;该命令会在目录中创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;的子目录，其中包含了所有必要的repo文件。此时，工程中没有任何文件被追踪。&lt;/p&gt;

&lt;p&gt;如果想要开始对已存在的文件进行版本控制，可以输入下面命令&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add *.c
$ git add LICENSE
$ git commit -m &quot;initial project version&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;克隆已存在的repo&quot;&gt;克隆已存在的Repo&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt;可以用来克隆已存在的文件。与其他版本控制系统常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;checkout&lt;/code&gt;不同，这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;表示Git会把已存在Repo中所有的文件的所有版本都克隆到本地，而不是只拷贝当前版本的文件。&lt;/p&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone &amp;lt;url&amp;gt;&lt;/code&gt;可以克隆repo。例如：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;$ git clone https://github.com/libgit2/libgit2&lt;/code&gt;&lt;br /&gt;
创建了一个名叫&lt;code class=&quot;highlighter-rouge&quot;&gt;libgit2&lt;/code&gt;的目录，在其中初始化了&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;目录，将该库的数据都拉到其中，并签出(&lt;code class=&quot;highlighter-rouge&quot;&gt;checkout&lt;/code&gt;)了最新版本的文件。&lt;/p&gt;

&lt;h3 id=&quot;记录repo的变化&quot;&gt;记录Repo的变化&lt;/h3&gt;
&lt;p&gt;每个工作目录中的文件有两个状态：&lt;em&gt;tracked&lt;/em&gt;或是&lt;em&gt;untracked&lt;/em&gt;。&lt;em&gt;tracked&lt;/em&gt;的文件是在上一个快照中的文件；它们可以是未修改的(&lt;code class=&quot;highlighter-rouge&quot;&gt;unmodified&lt;/code&gt;)，修改的(&lt;code class=&quot;highlighter-rouge&quot;&gt;modified&lt;/code&gt;)和暂存的(&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;几个状态之间的转移图如图所示。&lt;br /&gt;
&lt;img src=&quot;./git_status_change.png&quot; alt=&quot;文件状态生命周期&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;检查文件状态&quot;&gt;检查文件状态&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;可用来检查文件的状态。&lt;/p&gt;

&lt;p&gt;例如，假设刚刚&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;了一个repo，则此时使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令一般显示如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这表明工作目录是干净的，即你所跟踪(&lt;code class=&quot;highlighter-rouge&quot;&gt;track&lt;/code&gt;)的文件都没有被修改&lt;/p&gt;

&lt;p&gt;如果添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;README&lt;/code&gt;文件，则它是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;untracked&lt;/code&gt;文件，目录的状态就发生了变化&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo 'My Project' &amp;gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
(use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed)
README
nothing added to commit but untracked files present (use &quot;git add&quot; to track)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;untracked&lt;/code&gt;文件表示该文件没有出现在上一次&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;的快照中&lt;/p&gt;

&lt;h4 id=&quot;跟踪新文件&quot;&gt;跟踪新文件&lt;/h4&gt;
&lt;p&gt;可通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;命令跟踪新文件。例如&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git add README&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此时运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令，则输出为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    new file:  README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;现在该文件就处于暂存(&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;)状态了。该状态下对文件的改变等待被&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;暂存修改后文件&quot;&gt;暂存修改后文件&lt;/h4&gt;
&lt;p&gt;如果修改了一个之前跟踪的文件，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;，然后运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;,则输出为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    new file:  README
Changes not staged for commit:
  (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
    modified:  CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;文件被修改了，但还没有位于暂存区中，需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;命令将其加入暂存区。&lt;/p&gt;

&lt;p&gt;运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;命令后状态如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    new file: README
    modified: CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果此时调用&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，则两个文件都会被加入快照中。如果此时你修改了&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;文件，则&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令的输出会是&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    new file: README
    modified: CONTRIBUTING.md

Changes not staged for commit:
 (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
 (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
    modified: CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;既是&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;又是&lt;code class=&quot;highlighter-rouge&quot;&gt;unstaged&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;的文件是上一次&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;加进去的，而后面修改内容的文件处于&lt;code class=&quot;highlighter-rouge&quot;&gt;unstaged&lt;/code&gt;状态。如果现在&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，则快照中的文件仍然是修改之前的，即&lt;code class=&quot;highlighter-rouge&quot;&gt;staged&lt;/code&gt;状态的文件。&lt;/p&gt;

&lt;h4 id=&quot;忽略文件&quot;&gt;忽略文件&lt;/h4&gt;
&lt;p&gt;Git可通过在&lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt;文件中设置对应的语法规则来使得Git在添加、提交等操作时忽略一些文件，例如程序构建后的文件、构建过程中的目标文件、临时文件等。其中的语法这里不再详细介绍，当用到时去查看即可。&lt;/p&gt;

&lt;h4 id=&quot;观看暂存以及未暂存的改变&quot;&gt;观看暂存以及未暂存的改变&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;命令的输出太模糊、宽泛了——你知道文件的状态，但不知道文件的内容发生了什么变化。&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt;命令可用于观看这些变化。&lt;/p&gt;

&lt;p&gt;例如，假设你编辑并且暂存了&lt;code class=&quot;highlighter-rouge&quot;&gt;README&lt;/code&gt;文件，编辑了&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt;文件但没有暂存它，则&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;的输出是&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
 (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    modified: README
Changes not staged for commit:
 (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed)
 (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
    modified: CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了观看改变的但是没有暂存的内容，直接输入&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;if we have to read the whole diff to figure out why you're contributing in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive +chunks if your patch is longer than a dozen lines.

If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it's
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该命令比较工作目录和暂存区的差异。因此结果就是告诉你你所改变的没有暂存的内容。&lt;/p&gt;

&lt;p&gt;如果想看已经暂存的(即将要进入下一次&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;中的)内容，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff --staged&lt;/code&gt;。该命令比较暂存区和上一次&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;的内容的变化&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;提交发生的改变&quot;&gt;提交发生的改变&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;命令可以将暂存区中的内容加入到快照当中。&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;命令会打开默认编辑器让你键入&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;的相关信息。也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &amp;lt;message&amp;gt;&lt;/code&gt;来输入信息。&lt;/p&gt;

&lt;p&gt;记住，只有暂存区的内容会加入快照当中，不在暂存区的修改都会是&lt;code class=&quot;highlighter-rouge&quot;&gt;modified&lt;/code&gt;状态。&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;命令的本质是创建一个暂存区的快照。&lt;/p&gt;

&lt;h4 id=&quot;跳过暂存区&quot;&gt;跳过暂存区&lt;/h4&gt;
&lt;p&gt;通过给&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;命令传递&lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt;选项可以使其跳过暂存阶段。该选项会将所有跟踪的改变内容的文件暂存(注意：未跟踪的文件不会被暂存！)&lt;/p&gt;

&lt;h4 id=&quot;删除文件&quot;&gt;删除文件&lt;/h4&gt;
&lt;p&gt;为了从Git中删除文件，需要删除跟踪着的文件然后&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt;会删除跟踪着的文件。工作目录中的对应文件也会被删除。&lt;/p&gt;

&lt;p&gt;如果只是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rm&lt;/code&gt;命令删除，则该改变使得Git进入下面的状态&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
 (use &quot;git add/rm &amp;lt;file&amp;gt;...&quot; to update what will be committed)
 (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory)
    deleted: PROJECTS.md
no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt;命令，则对应的文件会从暂存区中删除&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
 (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    deleted: PROJECTS.md
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;接着&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;即可。如果对文件进行了修改(处于&lt;code class=&quot;highlighter-rouge&quot;&gt;modified&lt;/code&gt;状态，未加入暂存区)或已经将它加入暂存区(没有&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;)，则需要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;选项强制删除。&lt;/p&gt;

&lt;p&gt;有时候或许只想从暂存区中删除文件，而希望在硬盘上保留它。也就是说，希望Git不再跟踪该文件，则可以给&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt;命令加上&lt;code class=&quot;highlighter-rouge&quot;&gt;--cached&lt;/code&gt;选项。&lt;/p&gt;

&lt;h4 id=&quot;移动文件&quot;&gt;移动文件&lt;/h4&gt;
&lt;p&gt;Git不显式跟踪文件的移动。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
 (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)
    renamed: README.md -&amp;gt; README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的命令和下面的命令是等价的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mv README.md README
$ git rm README.md
$ git add README
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>本章讲述Git的基础知识。</summary>
</entry>
<entry>
<title>Arts Weekten Leetcode779 Kth Symbol</title>
<link href="http://localhost:4000/ARTS-WeekTen-Leetcode779-Kth-Symbol/" rel="alternate" type="text/html" title="Arts Weekten Leetcode779 Kth Symbol" />
<published>2019-06-11T00:00:00+08:00</published>
<updated>2019-06-11T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekTen-Leetcode779-Kth-Symbol</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekTen-Leetcode779-Kth-Symbol/">&lt;p&gt;On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.&lt;/p&gt;

&lt;p&gt;Given row N and index K, return the K-th indexed symbol in row N. (The values of K are 1-indexed.) (1 indexed).&lt;/p&gt;

&lt;p&gt;Examples:&lt;br /&gt;
Input: N = 1, K = 1&lt;br /&gt;
Output: 0&lt;/p&gt;

&lt;p&gt;Input: N = 2, K = 1&lt;br /&gt;
Output: 0&lt;/p&gt;

&lt;p&gt;Input: N = 2, K = 2&lt;br /&gt;
Output: 1&lt;/p&gt;

&lt;p&gt;Input: N = 4, K = 5&lt;br /&gt;
Output: 1&lt;/p&gt;

&lt;p&gt;row 1: 0&lt;br /&gt;
row 2: 01&lt;br /&gt;
row 3: 0110&lt;br /&gt;
row 4: 01101001&lt;br /&gt;
—
这题还是很有意思的。最直观的解法是生成第N行然后直接索引第K个，然而很快就会发现，第row行的字符数量是&lt;code class=&quot;highlighter-rouge&quot;&gt;$2^(N-1)$&lt;/code&gt;，显然是放不下的。因此还要有其他方法。&lt;/p&gt;

&lt;p&gt;我自己的解法是比较复杂的，主要是通过观察数列规律得出。很显然，可以根据K和N分为下列情况（假设middle是第N行的中间位置,f(N,K)是想要寻找的数字)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;K &amp;lt; middle, 此时就是第N-1行的对应索引，即f(N, K) = f(N-1, K)&lt;/li&gt;
  &lt;li&gt;K &amp;gt; middle,此时要分N是奇数还是偶数
    &lt;ul&gt;
      &lt;li&gt;N为奇数时，此时N行左半边和右半边对称，因此f(N, K) = f(N, middle * 2 - K + 1) = f(N - 1, middle * 2- K + 1)&lt;/li&gt;
      &lt;li&gt;N为偶数时，将数列划分为四等分，则必定是abba的形式，因此又分两种情况
        &lt;ul&gt;
          &lt;li&gt;K在右侧的左半边时，则位于abba中第2个b的位置，则可在第1个b中找到其对应位置，即f(N, K) = f(N, K - middle / 2) = f(N - 1, K - middle / 2)&lt;/li&gt;
          &lt;li&gt;K在右侧的右半边时，即位于abba中第2个a的位置，则可在第1个a中找到其对应位置，即f(N, K) = f(N, K - middle / 2 * 3) = f(N - 1, K - middle / 2 * 3)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基准情形则是N=1和N=2时的情况。总体来说，思路就是把N往小了化简。&lt;/p&gt;

&lt;p&gt;在看了解析之后，才发现其实很简单。把第N-1行的0看作第N行的0和1的父节点，第N-1行的1看作第N行的1和0的父节点。很显然，第N行中如果K是偶数，则它是父节点的右子节点，如果K是奇数，则它是父节点的左子节点。而只要确定了K对应的位置的父节点的数值，则K的数值就很简单就能确定。从子节点一直往上回溯直到找到基准情形即可。这种思路的代码非常简单，如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    int kthGrammar(int N, int K) {
	if (N == 1) return 0;
	if (K % 2 == 0) return (kthGrammar(N - 1, K / 2) == 0) ? 1 : 0;
	else return (kthGrammar(N - 1, (K + 1) / 2) == 0) ? 0 : 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我自己的代码复杂一些，这里也附上&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    int kthGrammar(int N, int K) {
        if(N == 1)
            return 0;   
        if(N == 2 &amp;amp;&amp;amp; K == 1)
            return 0;
        if(N == 2 &amp;amp;&amp;amp; K == 2)
            return 1;
        
        int middle = pow(2, N - 2);
        if(K &amp;lt;= middle)
            return kthGrammar(N-1, K);
        else if(K &amp;gt; middle &amp;amp;&amp;amp; N % 2)
            return kthGrammar(N - 1, middle * 2 - K + 1);
        else 
        {
            if(K &amp;lt;= 3 * middle / 2)
                return kthGrammar(N - 1, K - middle / 2);
            else
                return kthGrammar(N - 1, K - middle / 2 * 3);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.</summary>
</entry>
<entry>
<title>Envoy学习之旅(三)</title>
<link href="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%B8%89)/" rel="alternate" type="text/html" title="Envoy学习之旅(三)" />
<published>2019-06-10T00:00:00+08:00</published>
<updated>2019-06-10T00:00:00+08:00</updated>
<id>http://localhost:4000/envoy学习之旅(三)</id>
<content type="html" xml:base="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%B8%89)/">&lt;p&gt;上回修改了docker容器以及app实际监听的端口号。现在app在容器内部的8080端口号上监听，而我们访问则通过容器发布的8000端口号访问。接下去终于进入了正题，即使用envoy来代理对该app的访问。&lt;/p&gt;

&lt;h2 id=&quot;实现过程&quot;&gt;实现过程&lt;/h2&gt;
&lt;p&gt;首先小小的修改一下&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt;文件。在其中&lt;code class=&quot;highlighter-rouge&quot;&gt;service&lt;/code&gt;下面添加一个选项&lt;code class=&quot;highlighter-rouge&quot;&gt;volumes&lt;/code&gt;,如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;volumes:
    - ./service-envoy.yaml:/etc/service-envoy.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这句话的意思是把当前目录下的配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;service-envoy.yaml&lt;/code&gt;挂在到容器中的&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;然后把&lt;code class=&quot;highlighter-rouge&quot;&gt;expose&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;ports&lt;/code&gt;选项改成下面的样子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;expose:
    - &quot;80&quot;
ports:
    - &quot;8000:80&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;至于为什么要改成这样，在后面马上会提到。&lt;/p&gt;

&lt;p&gt;接下去修改一下启动脚本，其中添加了&lt;code class=&quot;highlighter-rouge&quot;&gt;envoy&lt;/code&gt;的启动，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
python3 /code/hello_world_service.py &amp;amp;
envoy &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; /etc/service-envoy.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，最关键的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;service-envoy.yaml&lt;/code&gt;文件了。&lt;code class=&quot;highlighter-rouge&quot;&gt;service-envoy.yaml&lt;/code&gt;文件和官网提供的例子很像，其内容如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static_resources:
  listeners:
  - address:
      socket_address:
        address: 0.0.0.0
        port_value: 80
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        typed_config:
          &quot;@type&quot;: type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: service
              domains:
              - &quot;*&quot;
              routes:
              - match:
                  prefix: &quot;/&quot;
                route:
                  cluster: local_service
          http_filters:
          - name: envoy.router
            typed_config: {}
  clusters:
  - name: local_service
    connect_timeout: 0.25s
    type: strict_dns
    lb_policy: round_robin
    load_assignment:
      cluster_name: local_service
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: 0.0.0.0
                port_value: 8080
admin:
  access_log_path: &quot;/dev/null&quot;
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 8081
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的选项非常之多，我这里暂且不做详细的解释，在下面我阅读了envoy的官方文档，并将其中涉及到的重要选项列举一下。&lt;/p&gt;

&lt;p&gt;这里我只大概说一下文件所表达的意思。首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;envoy&lt;/code&gt;根据该文件创建了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;监听在端口号80上,&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;则监听在在端口号8080上。&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;根据过滤器的配置过滤、转发请求。这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;将前缀为&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;的所有请求转发给名字叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;local_service&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;,由&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;再给出回应。&lt;/p&gt;

&lt;p&gt;这里尤其要注意的是端口号。此处&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;的监听端口号是容器内部的端口号。因此在做端口映射时，主机端口应当映射到该端口，也因此&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yaml&lt;/code&gt;中的文件中的端口相关选项做了修改。&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;的端口号应当是业务逻辑，即app中的监听端口号。&lt;/p&gt;

&lt;h2 id=&quot;相关envoy选项含义&quot;&gt;相关envoy选项含义&lt;/h2&gt;
</content>
<summary>上回修改了docker容器以及app实际监听的端口号。现在app在容器内部的8080端口号上监听，而我们访问则通过容器发布的8000端口号访问。接下去终于进入了正题，即使用envoy来代理对该app的访问。</summary>
</entry>
<entry>
<title>Envoy学习之旅(二)</title>
<link href="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%BA%8C)/" rel="alternate" type="text/html" title="Envoy学习之旅(二)" />
<published>2019-06-09T00:00:00+08:00</published>
<updated>2019-06-09T00:00:00+08:00</updated>
<id>http://localhost:4000/envoy学习之旅(二)</id>
<content type="html" xml:base="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%BA%8C)/">&lt;p&gt;在完成了docker中运行app之后，需要将envoy作为app的代理。其他服务通过envoy与app进行交互。然而，之前使用了相同的端口号，这容易产生混淆，因此想修改两个端口不一致以区分。&lt;/p&gt;

&lt;h2 id=&quot;docker-compose内容说明&quot;&gt;docker compose内容说明&lt;/h2&gt;
&lt;p&gt;在进一步深入之前，由于对docker compose知识的缺乏，这里去了解了一下其中用到的各个字段，记录如下。&lt;/p&gt;

&lt;p&gt;docker compose中有top-level的key，该key在配置文件中定义了一个区域，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;deploy&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;depends_on&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;networks&lt;/code&gt;等。在该key的下面列出了支持他们作为子主题的选项。因此，一般映射是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;key&amp;gt;: &amp;lt;option&amp;gt;: &amp;lt;value&amp;gt;&lt;/code&gt;这样的。&lt;/p&gt;

&lt;h3 id=&quot;service-configuration-reference&quot;&gt;Service configuration reference&lt;/h3&gt;
&lt;p&gt;Service定义(&lt;code class=&quot;highlighter-rouge&quot;&gt;services:&lt;/code&gt;)包含了每个为了该服务启动的容器的配置，很像给&lt;code class=&quot;highlighter-rouge&quot;&gt;docker container create&lt;/code&gt;传递参数。与此类似的，网络和卷的定义和&lt;code class=&quot;highlighter-rouge&quot;&gt;docker network create&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;docker volume create&lt;/code&gt;很像。&lt;/p&gt;

&lt;h4 id=&quot;build&quot;&gt;build&lt;/h4&gt;
&lt;p&gt;包含在构建时的配置选项。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;build&lt;/code&gt;可以被指定为一个包含构建上下文的路径字符串，也可以使用对象的形式指定，例如&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: &quot;3.7&quot;
services:
  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
	buildno: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;context&quot;&gt;CONTEXT&lt;/h5&gt;
&lt;p&gt;可以是一个包含Dockerfile的目录路径，也可以是到一个git repo的url&lt;/p&gt;

&lt;h5 id=&quot;dockerfile&quot;&gt;DOCKERFILE&lt;/h5&gt;
&lt;p&gt;可选的Dockerfile&lt;/p&gt;

&lt;h4 id=&quot;expose&quot;&gt;expose&lt;/h4&gt;
&lt;p&gt;暴露端口且不向主机发布它们 - 它们将只能由链到的接服务所接触。只有内在的端口可以被指定。&lt;/p&gt;

&lt;p&gt;这里指的是app使用的端口号，而不是docker容器对外暴露的端口号&lt;/p&gt;

&lt;h4 id=&quot;networks&quot;&gt;networks&lt;/h4&gt;
&lt;p&gt;要加入的网络&lt;/p&gt;

&lt;h5 id=&quot;aliases&quot;&gt;ALIASES&lt;/h5&gt;
&lt;p&gt;在网络上该服务的别名。相同网络中的其他容器可以使用服务名或是此别名来连接到服务的其中一个容器。&lt;/p&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;aliases&lt;/code&gt;是网络范围内的，相同的服务可以在不同的网络中使用不同的别名。&lt;/p&gt;

&lt;p&gt;一种通用格式是这样的：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;services:
  some-service:
    networks:
      some-network:
        aliases:
         - alias1
	 - alias3
      other-network:
        aliases:
         - alias2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ports&quot;&gt;ports&lt;/h4&gt;
&lt;p&gt;暴露端口&lt;/p&gt;

&lt;h5 id=&quot;short-syntax&quot;&gt;SHORT SYNTAX&lt;/h5&gt;
&lt;p&gt;指定两个端口号(&lt;code class=&quot;highlighter-rouge&quot;&gt;HOST:CONTAINER&lt;/code&gt;),或者只有容器端口(一个短暂的host端口将被选择)&lt;/p&gt;

&lt;p&gt;后面的是容器内部的端口，即app监听端口，前面的是暴露端口，即我们访问docker容器的端口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ports:
 - &quot;3000&quot;
 - &quot;3000-3005&quot;
 - &quot;8000:8000&quot;
 - &quot;9090-9091:8080-8081&quot;
 - &quot;49100:22&quot;
 - &quot;127.0.0.1:8001:8001&quot;
 - &quot;127.0.0.1:5000-5010:5000-5010&quot;
 - &quot;6060:6060/udp&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;long-syntax&quot;&gt;LONG SYNTAX&lt;/h5&gt;
&lt;p&gt;较长形式的语法允许对不能被短语法形式表现的配置域。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;:容器内部的端口&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;published&lt;/code&gt;:公开暴露的端口&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;protocol&lt;/code&gt;:端口的协议(&lt;code class=&quot;highlighter-rouge&quot;&gt;tcp&lt;/code&gt;或是&lt;code class=&quot;highlighter-rouge&quot;&gt;udp&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mode&lt;/code&gt;: 在每个节点上都发布一个host端口则是&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;,在需要负载均衡的swarm模式下的端口则是&lt;code class=&quot;highlighter-rouge&quot;&gt;ingress&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ports:
  - target: 80
    published: 8080
    protocol: tcp
    mode: host
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改端口&quot;&gt;修改端口&lt;/h2&gt;
&lt;p&gt;app监听端口仍为8080，将容器暴露端口改为8000，docker-compose文件的格式为&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;expose:
- &quot;8080&quot;
ports:
- &quot;8000:8080&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，就可以通过8000端口号访问服务了。&lt;/p&gt;

&lt;p&gt;中间由于对端口的配置理解有误，自己尝试了各种端口号配置，记录如下。app的监听端口号不变是8080。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;expose&lt;/th&gt;
      &lt;th&gt;ports&lt;/th&gt;
      &lt;th&gt;访问&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8000:8000”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8000:8080”&lt;/td&gt;
      &lt;td&gt;8080&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8000:8080”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;成功&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8080:8000”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8000”&lt;/td&gt;
      &lt;td&gt;“8080:8000”&lt;/td&gt;
      &lt;td&gt;8080&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8080”&lt;/td&gt;
      &lt;td&gt;“8000:8080”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;成功&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8080”&lt;/td&gt;
      &lt;td&gt;“8000:8080”&lt;/td&gt;
      &lt;td&gt;8080&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8080”&lt;/td&gt;
      &lt;td&gt;“8080:8000”&lt;/td&gt;
      &lt;td&gt;8000&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“8080”&lt;/td&gt;
      &lt;td&gt;“8080:8000”&lt;/td&gt;
      &lt;td&gt;8080&lt;/td&gt;
      &lt;td&gt;失败&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从上面表格可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;expose&lt;/code&gt;的作用感觉不大，&lt;code class=&quot;highlighter-rouge&quot;&gt;ports&lt;/code&gt;中前面的端口可以自己配置，访问时需访问该端口。后面的端口需要和app监听端口保持一致，否则访问也会失败。&lt;/p&gt;
</content>
<summary>在完成了docker中运行app之后，需要将envoy作为app的代理。其他服务通过envoy与app进行交互。然而，之前使用了相同的端口号，这容易产生混淆，因此想修改两个端口不一致以区分。</summary>
</entry>
<entry>
<title>Arts Weeknine High Performance Server(二)</title>
<link href="http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(%E4%BA%8C)/" rel="alternate" type="text/html" title="Arts Weeknine High Performance Server(二)" />
<published>2019-06-09T00:00:00+08:00</published>
<updated>2019-06-09T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(二)</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(%E4%BA%8C)/">&lt;p&gt;接下去介绍高性能服务器设计的最后两个因素。&lt;/p&gt;

&lt;h2 id=&quot;memory-allocation&quot;&gt;Memory allocation&lt;/h2&gt;
&lt;p&gt;内存分配是制约服务器性能的一大瓶颈。&lt;/p&gt;

&lt;p&gt;作者提出了三种方法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;预分配内存。动态分配内存的好处是不会浪费空间，然而需要消耗时间。如果有些内存分配是必需的，在程序运行前就可以确定的，则可以进行预分配，即便这样会浪费一些内存。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;look aside&lt;/code&gt;列表。其基本思想是对于要释放的对象不立即释放，而是将它加入到一个列表中。这样，，多个私有列表来保持较低的分配开支如果短时间内又需要用到该对象，则不重新分配而是从链表中获取即可。对于&lt;code class=&quot;highlighter-rouge&quot;&gt;look aside&lt;/code&gt;列表的使用，显然不能让其无限制变多，因此作者提出采用新旧列表的方法，既避免了过多的锁争用，又能释放无用对象的内存。&lt;/li&gt;
  &lt;li&gt;在分配内存时会出现锁争用的情况，即使使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;look aside&lt;/code&gt;列表也是如此。该情况是内存分配消耗最大的情况。为了避免该情况，可以维护多个私有的&lt;code class=&quot;highlighter-rouge&quot;&gt;look aside&lt;/code&gt;列表。例如，可以给每个线程分配一个该列表，这样就避免了锁争用。或者是一个处理器一个列表。必要时也可以用一个共享列表，多个私有列表来保持较低的分配开支&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;lock-contention&quot;&gt;Lock Contention&lt;/h2&gt;
</content>
<summary>接下去介绍高性能服务器设计的最后两个因素。</summary>
</entry>
<entry>
<title>Arts Weeknine High Performance Server(一)</title>
<link href="http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(%E4%B8%80)/" rel="alternate" type="text/html" title="Arts Weeknine High Performance Server(一)" />
<published>2019-06-09T00:00:00+08:00</published>
<updated>2019-06-09T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(一)</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekNIne-High-Performance-Server(%E4%B8%80)/">&lt;p&gt;这篇英文文章讲的是高性能服务器设计的一些要点。&lt;br /&gt;
原文链接为&lt;img src=&quot;http://pl.atyp.us/content/tech/servers.html&quot; alt=&quot;High-Performance Server Architecture&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-copies&quot;&gt;Data Copies&lt;/h2&gt;
&lt;p&gt;数据拷贝可能被掩盖或是伪装。在第三方库中或是驱动中都可能进行许多数据拷贝。一个明显的例子是哈希。&lt;/p&gt;

&lt;p&gt;一种方法是使用缓冲区描述符而不是单纯的缓冲区指针。每个描述符由下列事项组成：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一个指针以及缓冲区的长度&lt;/li&gt;
  &lt;li&gt;一个指针或是偏移值以及长度。指针指向实际填充区域的开始，偏移也是，长度是实际填充的长度&lt;/li&gt;
  &lt;li&gt;指向其他缓冲区的前向以及后向指针&lt;/li&gt;
  &lt;li&gt;引用计数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述方法在某些情况下工作的很好，然而有时候也会让人头疼。这是因为在缓冲区链的前面和后面添加缓冲区是很方便的，但在中间添加缓冲区或是指向部分缓冲区等操作非常麻烦。&lt;/p&gt;

&lt;p&gt;作者不建议使用上述方法。最好的方法是识别出程序中的大对象并分别分配它们以避免拷贝。&lt;/p&gt;

&lt;p&gt;作者最后提醒，不要过分防止数据拷贝。过分防止数据拷贝可能导致代码变得更混乱、复杂。&lt;/p&gt;

&lt;h2 id=&quot;context-switches&quot;&gt;Context Switches&lt;/h2&gt;
&lt;p&gt;当系统在线程间来回切换的时间比它在一个线程内干实际的活所消耗的时间还多时，上下文切换就严重拖慢了系统效率。&lt;/p&gt;

&lt;p&gt;造成上述现象的第一个原因是活跃线程数比处理器数量要多，因此可扩展的系统通常会限制活跃线程的数量。&lt;/p&gt;

&lt;p&gt;通常在前端需要使用select/poll,异步IO,信号或是completion ports等事件驱动机制来使得一个线程处理多个连接。&lt;/p&gt;

&lt;p&gt;最简单的多线程事件驱动服务器维护一个队列，每个请求被一个或多个&lt;code class=&quot;highlighter-rouge&quot;&gt;listeners&lt;/code&gt;监听并放入队列，而&lt;code class=&quot;highlighter-rouge&quot;&gt;worker threads&lt;/code&gt;从队列中取出任务。然而，这样做也会拖慢系统。上下文切换的第二个原因就是从一个线程到另一个线程传递任务。较好的设计应当是&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;能变成&lt;code class=&quot;highlighter-rouge&quot;&gt;worker&lt;/code&gt;再变回&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如何限制活跃线程的数量呢？作者提出使用最简单的方法：信号量。活跃线程首先获取信号量再执行工作。&lt;/p&gt;

&lt;p&gt;作者接着提出，可以将对请求的处理分为多个阶段，通过阶段分发函数的返回值确定。例如:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;请求需要传给下一个阶段(ID或是指针作为返回值)&lt;/li&gt;
  &lt;li&gt;请求已经被完成(特殊的”请求完成”返回值)&lt;/li&gt;
  &lt;li&gt;请求被阻塞(特殊的”请求阻塞”返回值)。这和前面的阶段一样，但该请求未被释放，会在其他线程继续&lt;br /&gt;
在上面的模型中，请求的排队在阶段内完成，而不是阶段之间。这避免了将请求压入成功阶段的队列然后进入成功阶段又取出&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者最后对SEDA发表了自己的看法。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;SEDA的批处理将多个请求通过一个阶段处理，作者提出的方法将单个请求通过多个阶段处理&lt;/li&gt;
  &lt;li&gt;学术研究角度而言，用java完成SEDA是有意义的。实际工程中也许并不好&lt;/li&gt;
&lt;/ul&gt;
</content>
<summary>这篇英文文章讲的是高性能服务器设计的一些要点。原文链接为</summary>
</entry>
<entry>
<title>Arts Weeknine Progit(一)</title>
<link href="http://localhost:4000/ARTS-WeekNine-ProGit(%E4%B8%80)/" rel="alternate" type="text/html" title="Arts Weeknine Progit(一)" />
<published>2019-06-06T00:00:00+08:00</published>
<updated>2019-06-06T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekNine-ProGit(一)</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekNine-ProGit(%E4%B8%80)/">&lt;p&gt;git可说是目前最常用的版本控制系统之一，虽然之前也曾经学过，但并没有深刻理解其中的原理，因此就下载了Pro Git这本书，争取把git里里外外都搞个通透。&lt;/p&gt;

&lt;h2 id=&quot;一基本信息&quot;&gt;一、基本信息&lt;/h2&gt;
&lt;h3 id=&quot;版本控制&quot;&gt;版本控制&lt;/h3&gt;
&lt;p&gt;在日常生活中，我们编辑文件。随着时间的流逝，文件数目越来越多，对文件的修改也越来越多。有时我们修改错误，想要找回上一个版本的东西。有时在不同的场合下，我们想换一个版本使用。这就诞生出了版本控制，即控制我们开发的东西的不同版本，并且具备回退等能力。&lt;/p&gt;

&lt;p&gt;通常由三种版本控制系统：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;本地控制，即自己手动通过文件名等手段标志出版本信息&lt;/li&gt;
  &lt;li&gt;中心化版本控制，文件存在一个中心服务器，任何想要文件的人通过服务器获取最新文件并编辑&lt;/li&gt;
  &lt;li&gt;分布式版本控制，每个机器都把文件以及版本信息复制下来，这样当一个服务器失效，任何一台机器都可顶替服务器的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;git的一些基本概念&quot;&gt;Git的一些基本概念&lt;/h3&gt;
&lt;h4 id=&quot;快照而不是差别&quot;&gt;快照，而不是差别&lt;/h4&gt;
&lt;p&gt;其他的VCS大多把一个版本一个版本的更迭视为对文件的修改，即他们存下文件，而以后的版本是对文件作出修改。Git则把每个版本视为对当前文件的一个快照。在git中，每次commit或是保存当前工程的状态，git都会记录当前你的所有文件看起来是怎么样的并且保存一个到该快照的引用。对于未修改的文件，git则会有到上一个版本该文件的引用，而不重新保存。&lt;/p&gt;

&lt;h4 id=&quot;几乎所有操作都是本地的&quot;&gt;几乎所有操作都是本地的&lt;/h4&gt;
&lt;p&gt;由于git在本地电脑上保留了所有的版本控制信息，因此提交等操作不需要依赖于服务器，只需在本地进行即可。其他的VCS在提交、浏览过去版本信息等操作中往往需要和中心服务器取得联络，这就要求必须由互联网，且造成了网络通信的开销。&lt;/p&gt;

&lt;h4 id=&quot;三个状态&quot;&gt;三个状态&lt;/h4&gt;
&lt;p&gt;git中有三个区域：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;工作区：即放置工作文件的位置，是工程的一个签出版本&lt;/li&gt;
  &lt;li&gt;暂存区：是包含在Git目录中的一个文件，其中存储了将放入下一个commit中的信息&lt;/li&gt;
  &lt;li&gt;Git目录区：是Git放置元数据和对象数据库的地方&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此引入了三种状态，在工作区中修改但还没加入暂存区的状态是&lt;em&gt;modified&lt;/em&gt;，在暂存区中但还没加入Git目录区(即还没commit)的状态是&lt;em&gt;staged&lt;/em&gt;,在Git目录区中的状态是&lt;em&gt;commited&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;初次设置&quot;&gt;初次设置&lt;/h3&gt;
&lt;p&gt;Git有一个叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;git config&lt;/code&gt;的工具能设置那些控制Git操作的变量。这些变量存在三个不同的地方：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/config&lt;/code&gt;:包含应用到系统中所有人的值。如果给&lt;code class=&quot;highlighter-rouge&quot;&gt;git config&lt;/code&gt;传递&lt;code class=&quot;highlighter-rouge&quot;&gt;--system&lt;/code&gt;选项，则它会从这个文件中读写&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.gitconfig&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.config/git/config&lt;/code&gt;:该值影响的是当前用户。可以传递&lt;code class=&quot;highlighter-rouge&quot;&gt;--global&lt;/code&gt;选项来让Git从中读写。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config&lt;/code&gt;文件：该文件在Git目录中(&lt;code class=&quot;highlighter-rouge&quot;&gt;.git/config&lt;/code&gt;)，影响的是当前的仓库。通过&lt;code class=&quot;highlighter-rouge&quot;&gt;--local&lt;/code&gt;选项即可让Git从中读写&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个层级的值都会覆盖上层的值&lt;/p&gt;

&lt;h4 id=&quot;认证身份&quot;&gt;认证身份&lt;/h4&gt;
&lt;p&gt;首次安装Git后需要配置用户的名字和邮箱，如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git config --global user.name &quot;${USER_NAME}&quot;  
$ git config --global user.email ${USER_EMAIL}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</content>
<summary>git可说是目前最常用的版本控制系统之一，虽然之前也曾经学过，但并没有深刻理解其中的原理，因此就下载了Pro Git这本书，争取把git里里外外都搞个通透。</summary>
</entry>
<entry>
<title>Arts Weeknine Leetcode942 Distringmatch</title>
<link href="http://localhost:4000/ARTS-WeekNine-Leetcode942-DIStringMatch/" rel="alternate" type="text/html" title="Arts Weeknine Leetcode942 Distringmatch" />
<published>2019-06-05T00:00:00+08:00</published>
<updated>2019-06-05T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekNine-Leetcode942-DIStringMatch</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekNine-Leetcode942-DIStringMatch/">&lt;p&gt;Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length.&lt;/p&gt;

&lt;p&gt;Return any permutation A of [0, 1, …, N] such that for all i = 0, …, N-1:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If S[i] == “I”, then A[i] &amp;lt; A[i+1]&lt;/li&gt;
  &lt;li&gt;If S[i] == “D”, then A[i] &amp;gt; A[i+1]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;p&gt;Input: “IDID”&lt;br /&gt;
Output: [0,4,1,3,2]&lt;/p&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;p&gt;Input: “III”&lt;br /&gt;
Output: [0,1,2,3]&lt;/p&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;p&gt;Input: “DDI”&lt;br /&gt;
Output: [3,2,0,1]&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题的意思是对于一个由”I”和”D”组成的序列，”I”表示增加,”D”表示减少，则根据该序列，给出一个由0到N组成的满足上面序列的数字序列。&lt;/p&gt;

&lt;p&gt;这题刚开始思考了一下，有点摸不着头脑，但后来发现，只要遇到”I”则放入当前能放入的最小的数，遇到”D”则放入当前能放入的最大的数，最后两者肯定汇聚到某个数，最后再放入汇聚的数即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; diStringMatch(string S) {
        int left = 0, right = S.size();
        
        vector&amp;lt;int&amp;gt; res(right + 1);
        
        for(int i = 0; i &amp;lt; S.size(); ++i) {
            if(S[i] == 'I') {
                res[i] = left;
                left++;
            } else {
                res[i] = right;
                right--;
            }
        }
        
        res[res.size() - 1] = left;
        
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length.</summary>
</entry>
<entry>
<title>Envoy学习之旅(一)</title>
<link href="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%B8%80)/" rel="alternate" type="text/html" title="Envoy学习之旅(一)" />
<published>2019-06-02T00:00:00+08:00</published>
<updated>2019-06-02T00:00:00+08:00</updated>
<id>http://localhost:4000/envoy学习之旅(一)</id>
<content type="html" xml:base="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%B8%80)/">&lt;p&gt;最近由于公司需要，开始学习一下envoy。envoy的官网教程基本上就是给例子，然而由于缺乏docker、docker-compose等相关知识，在自己搭建envoy过程中遇到了很多问题，因此这里就记录一下学习envoy的过程以及其中所遇到的问题。&lt;/p&gt;

&lt;p&gt;首先，假设不用envoy，直接写一个简单的返回”Hello, World”网页的应用。&lt;/p&gt;

&lt;h2 id=&quot;业务逻辑&quot;&gt;业务逻辑&lt;/h2&gt;
&lt;p&gt;业务逻辑是用python+flask写的，当然有其他很多方法，利用go等，只是这种方法相对最为简单而已。其代码如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from flask import Flask

app = Flask(__name__)

@app.route('/')
def hello():
    return ('Hello world!\n')

if __name__ == &quot;__main__&quot;:
    app.run(host='0.0.0.0', port=8080, debug=False)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Question: host改成&lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;后，在本机上可以，在docker环境下不行，为什么？
    &lt;h2 id=&quot;docker容器配置&quot;&gt;docker容器配置&lt;/h2&gt;
    &lt;p&gt;接下去将上面的业务逻辑放入docker容器中运行。docker的使用方法就不介绍了。直接给出docker文件如下&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM envoyproxy/envoy-alpine-dev:latest

RUN apk update &amp;amp;&amp;amp; apk add python3 bash curl
RUN pip3 install -q Flask==0.11.1
RUN mkdir /code
ADD ./service.py /code/service.py
ADD ./start_service.sh /usr/local/bin/start_service.sh
RUN chmod u+x /usr/local/bin/start_service.sh
ENTRYPOINT /usr/local/bin/start_service.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里用的基准镜像是envoy的镜像，因此需要安装python3、flask等。&lt;/p&gt;

&lt;p&gt;这里用脚本的原因是为了方便后面envoy的使用，目前也可以直接用&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;命令代替&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start_service.sh&lt;/code&gt;的内容如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
python3 /code/hello_world_service.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;docker-compose&quot;&gt;docker compose&lt;/h2&gt;
&lt;p&gt;docker compose主要用于管理多个docker运行时实例，虽然目前只有一个实例，但将来必定会扩展为多个，因此从最开始就使用docker compose来管理。&lt;/p&gt;

&lt;p&gt;docker compse文件的内容如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;version: &quot;3.4&quot;
services:
  service:
    build:
      context: .
      dockerfile: Dockerfile-service
    volumes:
      - ./service-envoy.yaml:/etc/service-envoy.yaml
    networks:
      envoymesh:
        aliases:
          - service1
    environment:
      - SERVICE_NAME=1
    expose:
      - &quot;8080&quot;
    ports:
      - &quot;8080:8080&quot;

networks:
  envoymesh: {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里值得注意的是，app的8080端口是在docker容器中的，而我们可以选择在实际机器环境中docker容器暴露给我们的端口是什么，这里选择8080只是出于方便，也可以更改。&lt;/p&gt;

</content>
<summary>最近由于公司需要，开始学习一下envoy。envoy的官网教程基本上就是给例子，然而由于缺乏docker、docker-compose等相关知识，在自己搭建envoy过程中遇到了很多问题，因此这里就记录一下学习envoy的过程以及其中所遇到的问题。</summary>
</entry>
<entry>
<title>Arts Weekeight Leetcode605 Canplaceflowers</title>
<link href="http://localhost:4000/ARTS-WeekEight-Leetcode605-CanPlaceFlowers/" rel="alternate" type="text/html" title="Arts Weekeight Leetcode605 Canplaceflowers" />
<published>2019-06-02T00:00:00+08:00</published>
<updated>2019-06-02T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekEight-Leetcode605-CanPlaceFlowers</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekEight-Leetcode605-CanPlaceFlowers/">&lt;p&gt;Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.&lt;/p&gt;

&lt;p&gt;Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: flowerbed = [1,0,0,0,1], n = 1
Output: True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: flowerbed = [1,0,0,0,1], n = 2
Output: False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;这题的意思是在一串0和1组成的数组中，0表示可以放置花的位置，1表示已经有花的位置，花与花不能相邻，则判断给定数能否放下。&lt;/p&gt;

&lt;p&gt;最开始直接采用了模拟的方法，考虑了多种情况，写出的代码较复杂，放在后面仅做参考。后来仔细思考后发现其实就是贪心算法。对于数组两侧为0的情况，则在两侧放置为1肯定是最优解。接下来遍历数组，碰到0则判断是否能放，能放则放，不能放则继续，如此就能得到最多能放下的花数。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func canPlaceFlowers(flowerbed []int, n int) bool {

    res := 0
    length := len(flowerbed)
    if length == 1 {
        if flowerbed[0] == 0 {
            return n &amp;lt;= 1
        } else {
            return n == 0
        }
    }
    
    if flowerbed[0] == 0 &amp;amp;&amp;amp; flowerbed[1] == 0 {
        flowerbed[0] = 1
        res++;
    }
    if flowerbed[length - 1] == 0 &amp;amp;&amp;amp; flowerbed[length - 2] == 0 {
        flowerbed[length - 1] = 1
        res++
    }
    
    for i := 1; i &amp;lt; length - 1; i++ {
        if(flowerbed[i] == 0 &amp;amp;&amp;amp; flowerbed[i - 1] == 0 &amp;amp;&amp;amp; flowerbed[i + 1] == 0) {
            res++
            flowerbed[i] = 1
        }
    }
    
    return res &amp;gt;= n
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一种想法的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func canPlaceFlowers(flowerbed []int, n int) bool {

    left_start := 0
    right_end := len(flowerbed) - 1

    for left_start &amp;lt;= right_end &amp;amp;&amp;amp; flowerbed[left_start] == 0  {
        left_start++;
    }
    for right_end &amp;gt;= left_start &amp;amp;&amp;amp; flowerbed[right_end] == 0 {
        right_end--;
    }

    if left_start &amp;gt;= right_end {
        if len(flowerbed) == 1 {
            if(flowerbed[0] == 1 &amp;amp;&amp;amp; n &amp;gt;= 1) {
                return false
            } else {
                return n &amp;lt;= 1
            }
        }
        if left_start == len(flowerbed) {
            return ((left_start + 1) / 2) &amp;gt;= n
        } else {
            return (left_start / 2 + (len(flowerbed) - 1 - right_end) / 2) &amp;gt;= n
        }
    }

    res := 0
    current_start := left_start
    for i := left_start + 1; i &amp;lt;= right_end; i++ {
        if flowerbed[i] == 1 {
            res += (i - current_start - 2) / 2
            current_start = i
        }
    }

    return (res + left_start  / 2 + (len(flowerbed) - 1 - right_end) / 2) &amp;gt;= n
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</summary>
</entry>
</feed>
