<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-05-12T16:21:57+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tonfeiz’s Blog</title><subtitle></subtitle><author><name>Tonfeiz</name></author><entry><title type="html">Arts Weekfive Avoid Over Engineering</title><link href="http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering/" rel="alternate" type="text/html" title="Arts Weekfive Avoid Over Engineering" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFive-Avoid-Over-Engineering/">&lt;p&gt;商业需求是在不断变化的，因此过度设计往往得不偿失。注意：下面的一些内容不是不要做，而是要适当，不要过度。&lt;/p&gt;

&lt;p&gt;以下是一些误解&lt;/p&gt;
&lt;h2 id=&quot;1-工程比商业更聪明&quot;&gt;1. 工程比商业更聪明&lt;/h2&gt;
&lt;p&gt;工程师们往往认为自己掌控一切，但事实上商业需求永远技高一筹。在第1000个问题被解决后，它们还能冒出第1001个需求来。&lt;/p&gt;

&lt;p&gt;商业需求是发散的，而不是收敛的&lt;/p&gt;

&lt;h2 id=&quot;2-重用商业功能模块&quot;&gt;2. 重用商业功能模块&lt;/h2&gt;
&lt;p&gt;当商业抛出越来越多的功能，我们有时候会将逻辑组合起来，尽量泛化它们。然而商业需求只会发散而不会收敛，这就使得共享的逻辑变得庞大。反之，我们应该将每个动作和逻辑分离开来，只有很少的共享逻辑。&lt;/p&gt;

&lt;p&gt;在横向分离之前先尝试纵向分裂商业功能。多隔离动作而少组合动作。&lt;/p&gt;

&lt;h2 id=&quot;3-所有的事情都是关于泛型&quot;&gt;3. 所有的事情都是关于泛型&lt;/h2&gt;
&lt;p&gt;有些时候工程师会执着于完美的抽象而忽略了真正的问题。其实答案非常简单。&lt;/p&gt;

&lt;p&gt;今天最好的设计是它能怎么样被取消(undesigned)。写的代码要易于删除，而不是易于扩展。&lt;/p&gt;

&lt;p&gt;重复比错误的抽象要好。重复次数多了，抽象就显现出来了。&lt;/p&gt;

&lt;h2 id=&quot;4-臃肿的包裹器&quot;&gt;4. 臃肿的包裹器&lt;/h2&gt;
&lt;p&gt;在使用每个外部库之前都写一个包裹器是不对的。这会使得包裹器变得臃肿。另一方面，包裹器往往和底层的库紧密的耦合，底层库变了包裹器也变了。&lt;/p&gt;

&lt;p&gt;现在许多外部库的API已经足够优秀了，因此不要总想着写包裹器。包裹器是一个异常情况，而不是正常情况。&lt;/p&gt;

&lt;h2 id=&quot;5-像使用工具一样使用质量&quot;&gt;5. 像使用工具一样使用质量&lt;/h2&gt;
&lt;p&gt;盲目的应用质量概念（例如将所有变量改成”private final”,为所有的类写接口等）并不会使代码奇迹般的变好。&lt;/p&gt;

&lt;p&gt;记住要总是往后退一步然后看看总体的风景。&lt;/p&gt;

&lt;p&gt;有些代码完全符合各种原则和概念，但是从整体来看却很糟糕。&lt;/p&gt;

&lt;h3 id=&quot;51-三明治层&quot;&gt;5.1 三明治层&lt;/h3&gt;
&lt;p&gt;例如，将一个简洁的，紧密相连的动作划分层10或20层三明治层，每一层都与外界无关。在过去使用继承来完成，即A扩展出B扩展出C……。现在想要完成这件事并且符合SOLID原则，则需要对每个类构建接口，并且把一个类依次注入到下一个类中，明显变得更麻烦了。&lt;/p&gt;

&lt;p&gt;像SOLID这样的概念是由于继承和其他OOP概念的滥用才产生的。大多数工程师不知道这些东西为什么诞生，只是跟随着就用。&lt;/p&gt;

&lt;p&gt;脑海中的概念应当会转换，而不能被盲目的像工具一样使用。&lt;/p&gt;

&lt;h2 id=&quot;6-过度使用综合征&quot;&gt;6. 过度使用综合征&lt;/h2&gt;
&lt;p&gt;一些过度使用综合征的例子：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;发现了泛型，于是一个简单的”HelloWorldPrinter”变成了”HelloWorldPrinter&amp;lt;String, Writer&amp;gt;”&lt;/li&gt;
  &lt;li&gt;发现了策略模式，于是每个”if”都是一个策略&lt;/li&gt;
  &lt;li&gt;发现了怎么写DSL，于是到处使用DSL&lt;/li&gt;
  &lt;li&gt;发现了Mocks，于是对每个测试的对象都使用mock&lt;/li&gt;
  &lt;li&gt;元编程太棒了，到处都使用元编程&lt;/li&gt;
  &lt;li&gt;枚举/扩展方法/Traits等等太棒了，到处都使用它…&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-x-ity&quot;&gt;7. &amp;lt;X&amp;gt;-ity&lt;/h2&gt;
&lt;p&gt;…性。例如可配置性，安全性，扩展性，维护性，伸缩性等等。这些性质当然是好的，但不要对每个性能都担忧会发生意外。仔细的考虑使用场景，再对这些性能作优化。&lt;/p&gt;

&lt;h2 id=&quot;8-内部发明&quot;&gt;8. 内部”发明”&lt;/h2&gt;
&lt;p&gt;内部的库、框架和工具最近很流行，但并不一定是好的。&lt;/p&gt;

&lt;p&gt;一些被错过的事情：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于某个问题领域有很深的了解是很难的，需要很多的技能。&lt;/li&gt;
  &lt;li&gt;让“发明”持续运行需要很多努力。即使是很小的库的维护也需要诸多时间&lt;/li&gt;
  &lt;li&gt;和对现有框架作出贡献相比，创造一个”发明”往往需要更多的时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重用，fork，贡献，重新考虑&lt;/p&gt;

&lt;h2 id=&quot;9-维持现状&quot;&gt;9. 维持现状&lt;/h2&gt;
&lt;p&gt;一旦一件事情被完成了，每个人都开始基于它构建东西。没人质疑现状。工作着的代码被认为是正确的。每个人都改变自己来适应这个库。&lt;/p&gt;

&lt;p&gt;这样是不对的。一个健康的系统是会搅动、翻腾的。很长时间不提交的代码一定是有问题的。&lt;/p&gt;

&lt;p&gt;重构是每个故事的一部分。没有代码是不可触碰的。&lt;/p&gt;

&lt;h2 id=&quot;10-差的估计&quot;&gt;10. 差的估计&lt;/h2&gt;
&lt;p&gt;我们经常发现非常优秀的团队或是程序员写出糟糕的代码。这是因为质量需要时间而不仅仅是技术。聪明的程序员往往会高估自己的实力于是只能匆忙写出较差的代码。因此，谨慎估计完成日期。&lt;/p&gt;

&lt;p&gt;差的估计在代码开始写之前就破坏了质量。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章主要是关于过度设计的。作者列举了10个过度设计的例子，其中有些由于我还没有接触实际的生产代码还不清楚，但大部分内容还是很有帮助的。&lt;/p&gt;

&lt;p&gt;第1点是文章的核心，我在很多其他地方也见到过类似的内容，即需求是一直变化的，不要妄想自己写出完美的代码。&lt;/p&gt;

&lt;p&gt;第3点对我来说比较重要，因为我之前总想着把变化封装起来，看了第3点之后明白了，一定要适度，过度抽象只会弄巧成拙。&lt;/p&gt;

&lt;p&gt;第9点也点醒了我。之前一直以为较好的库意味着很少对它作改动，每个人都用的舒心，然而其实不是这样的。即便是很好的库也一定会有问题存在，人们不动它可能是因为人们去习惯它。我们应当时刻注意自己写的内容，当很长时间没有翻新时则更要警惕。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">商业需求是在不断变化的，因此过度设计往往得不偿失。注意：下面的一些内容不是不要做，而是要适当，不要过度。</summary></entry><entry><title type="html">Arts Weekfive Vim编辑计算机程序</title><link href="http://localhost:4000/ARTS-WeekFive-vim%E7%BC%96%E8%BE%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/" rel="alternate" type="text/html" title="Arts Weekfive Vim编辑计算机程序" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFive-vim%E7%BC%96%E8%BE%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFive-vim%E7%BC%96%E8%BE%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/">&lt;p&gt;vim有许多辅助编写计算机程序的命令，可以编译一个进程并直接跳到报错的位置。&lt;/p&gt;

&lt;h2 id=&quot;一编译&quot;&gt;一、编译&lt;/h2&gt;
&lt;p&gt;在vim内部可以编译程序并且跳转到出错的位置。&lt;/p&gt;

&lt;p&gt;在vim中输入以下命令，程序“make”将会被执行，结果会被捕获。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:make {arguments}&lt;/code&gt;
在vim中会显示出错信息。此时按下&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt;键，vim会显示对应的文件并跳转到出错的位置。&lt;/p&gt;

&lt;p&gt;下面是一些常用命令：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cnext&lt;/code&gt;将跳转到下个出错位置，&lt;code class=&quot;highlighter-rouge&quot;&gt;:cprevious&lt;/code&gt;将跳转到前个出错位置&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cc&lt;/code&gt;将显示完整的出错信息&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:clist&lt;/code&gt;将显示完整的出错列表。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:clist!&lt;/code&gt;将显示所有的出错列表，包含链接错误等等&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cfirst&lt;/code&gt;将跳到第一个出错位置，&lt;code class=&quot;highlighter-rouge&quot;&gt;clast&lt;/code&gt;将跳到最后一个出错位置&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:cc 3&lt;/code&gt;将跳到第3个出错位置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;makeprg&lt;/code&gt;选项指定要运行的编译器,通过斜杠指定传递的参数，例如&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:set makeprg=nmake\ -f\ project.mak&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;二c风格的文本缩进&quot;&gt;二、C风格的文本缩进&lt;/h2&gt;
&lt;p&gt;对于C或者C风格的程序例如Java或者C++，可以通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;cindent&lt;/code&gt;选项来控制缩进。一般来说四个空格是合适的。&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set cindent shiftwidth=4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;操作符来对齐缩进。最简单的命令是&lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;，该命令会将当前行的缩进对齐。&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt;操作符可以在可视化模式下使用。一个很有用的命令是&lt;code class=&quot;highlighter-rouge&quot;&gt;=a{&lt;/code&gt;，这个命令会将当前&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;所在的区域全部缩进对齐。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">vim有许多辅助编写计算机程序的命令，可以编译一个进程并直接跳到报错的位置。</summary></entry><entry><title type="html">计算机技术历史 语言(二)</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%BA%8C)/" rel="alternate" type="text/html" title="计算机技术历史 语言(二)" /><published>2019-05-12T00:00:00+08:00</published><updated>2019-05-12T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%BA%8C)</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%BA%8C)/">&lt;p&gt;在汇编语言之后，诞生了最早的程序设计语言，FORTRAN。&lt;/p&gt;

&lt;h2 id=&quot;fortran语言&quot;&gt;FORTRAN语言&lt;/h2&gt;
&lt;p&gt;FORTAN源自于英语：Formula Translation，即公式翻译。从这里就可以看出，FORTRAN语言的主要用处是科学和工程计算方面。&lt;/p&gt;

&lt;p&gt;汇编语言的缺点在上次已经讲过，难以维护，入门门槛高，要维护各种寄存器等等。在1951年，IBM的John Backus针对这些缺点开始开发FORTRAN语言。&lt;/p&gt;

&lt;p&gt;1954年，FORTRAN I发布。1957年，第一个FORTRAN编译器在IBM704计算机上实现，并首次成功运行了FORTRAN程序。&lt;/p&gt;

&lt;p&gt;由于我也不会FORTRAN语言，因此我只能搜集一些资料，简单的介绍一下FORTRAN语言。&lt;/p&gt;

&lt;p&gt;FORTRAN语言的最大特性是接近数学公式的自然描述，在计算机里具有很高的执行效率。另外，它可以直接对矩阵和复数进行运算，类似于MATLAB。很多大型的数值运算计算机针对Fortran做了优化。&lt;/p&gt;

&lt;p&gt;相对于汇编语言，FORTRAN由于其语法的简洁性使得其入门门槛较低，可维护性也有所提高。然而，由于早期程序设计的局限性，FORTRAN的缺点也是有一大堆。FORTRAN中，某些字母开头的变量默认是某种类型，这就给命名增添了负担。早期的FORTRAN代码往往到处使用GOTO，使得程序的控制流混乱。FORTRAN的数值溢出等等也是坑。此外，虽然相比于汇编程序，FORTRAN的易读性和可维护性提高了，但相比于现代程序设计语言如C++、Java等，仍然有不少的差距。FORTRAN代码往往比较冗长，初看时会不知所以。&lt;/p&gt;

&lt;p&gt;注：上文所说的主要是FORTRAN语言的早期版本，后来FORTRAN也加入了一些现代编程语言的特性，但和原始FORTRAN诞生原因关系不大，因此就不再详细叙述。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/FORTRAN&quot;&gt;百度百科&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/28683874&quot;&gt;和 C++ 相比，用 Fortran 编程是怎样的体验？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Tonfeiz</name></author><summary type="html">在汇编语言之后，诞生了最早的程序设计语言，FORTRAN。</summary></entry><entry><title type="html">Arts Weekfive Leetcode856 Scoreofparentheses</title><link href="http://localhost:4000/ARTS-WeekFive-Leetcode856-ScoreOfParentheses/" rel="alternate" type="text/html" title="Arts Weekfive Leetcode856 Scoreofparentheses" /><published>2019-05-06T00:00:00+08:00</published><updated>2019-05-06T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFive-Leetcode856-ScoreOfParentheses</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFive-Leetcode856-ScoreOfParentheses/">&lt;p&gt;Given a balanced parentheses string S, compute the score of the string based on the following rule:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;() has score 1
AB has score A + B, where A and B are balanced parentheses strings.
(A) has score 2 * A, where A is a balanced parentheses string.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: &quot;()&quot;
Output: 1

Input: &quot;(())&quot;
Output: 2

Input: &quot;()()&quot;
Output: 2

Input: &quot;(()(()))&quot;
Output: 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;这是一道mdeium题，题意是对于一个完全匹配的括号串，()表示1,AB表示A+B,(A)表示A*2，其中A、B都是某个括号表达式，求给定括号串的值。&lt;/p&gt;

&lt;p&gt;这道题还是想了有一点时间，最开始是想用栈，但是感觉怎么用都不太对，后面才开始想用递归的方法。&lt;/p&gt;

&lt;p&gt;递归的核心其实就是把问题的规模变小，并且要有一个最终的停止条件。对一个函数&lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;来说，假设其输入是字符串以及起始位置&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;(范围为&lt;code class=&quot;highlighter-rouge&quot;&gt;[start, end)&lt;/code&gt;)，显然终止条件有:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;end - start &amp;lt; 2&lt;/code&gt;, 此时值为0&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s[start]s[end - 1] == &quot;()&quot;&lt;/code&gt;,此时值为1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不是上面这两种情况，则需要找到当前左括号匹配的右括号，如果该右括号不在&lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;处，那么说明后面还有字符串，则需要将两者代表的值相加。否则说明需要将内部的值扩大两倍并缩小范围。哪种情况都需要继续递归。&lt;/p&gt;

&lt;p&gt;递归版的代码见下，用栈的方法留作练习&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func scoreOfParentheses(S string) int {
    return eval(S, 0, len(S))
}

func eval(s string, start, end int) int {
    if end - start &amp;lt; 2 {
        return 0
    }
    
    if end - start == 2 &amp;amp;&amp;amp;s[start] == '(' &amp;amp;&amp;amp; s[end - 1] == ')' {
        return 1
    }
    
    parenthes_num := 1
    i := start + 1
    for ; i &amp;lt; end; i++ {
        if parenthes_num == 0 {
            break;
        }
        if(s[i] == '(') {
            parenthes_num++;
        } else {
            parenthes_num--;
        }
    }
    
    if i == end {
        return 2 * eval(s, start + 1, end - 1)
    }
    return eval(s, start, i) + eval(s, i, end)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given a balanced parentheses string S, compute the score of the string based on the following rule:</summary></entry><entry><title type="html">计算机技术历史 语言(一)</title><link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%80)/" rel="alternate" type="text/html" title="计算机技术历史 语言(一)" /><published>2019-05-03T00:00:00+08:00</published><updated>2019-05-03T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%80)</id><content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%80)/">&lt;p&gt;前段时间想去了解一下计算机技术的发展历史，但是搜了一下没有发现很系统的讲述这方面内容的书或者博客，因此就想自己来调查了解一下，也挺有意思的。&lt;/p&gt;

&lt;p&gt;为什么要关注计算机技术的历史呢？除了兴趣之外，还有一个重要原因是想从历史获取计算机技术发展的主脉络。现在计算机技术发展日新月异，新技术曾出不穷，但不是所有的技术都能留下来，也有些技术是不必要学。想要判断这些东西，就必须得到以往的技术有所了解，找出其中的规律。&lt;/p&gt;

&lt;p&gt;由于计算机技术实在太多了，因此不可能全部涉及。此外，硬件方面的技术门槛较高，我可能也看不懂。基于此，主要还是关注软件技术。&lt;/p&gt;

&lt;p&gt;首先，先从编程语言开始。&lt;/p&gt;

&lt;h2 id=&quot;机器语言&quot;&gt;机器语言&lt;/h2&gt;
&lt;p&gt;机器语言是最早的编程语言，也可以叫做机器码。大约在第一台计算机诞生时，即20世纪50年代左右，机器语言是主要编程语言。&lt;/p&gt;

&lt;p&gt;我们普通人也常常听到计算机其实就是一连串0和1这样的话，0和1其实就是机器语言。计算机接收这些0和1，将0和1组成的串变成硬件上的高低电平，再由高低电平控制机器完成实际动作。由0和1组成的串的集合又叫做指令集，每个计算机厂家的硬件不同，其指令集也不同。&lt;/p&gt;

&lt;p&gt;机器语言的优点就是快，缺点就是不是写给人看的。写机器语言的人必须对于硬件厂家给出的指令集有深厚的了解，才能较好的驾驭机器语言。可是不同的厂家，甚至相同厂家下面的不同型号计算机，只要硬件架构有了一定改动，机器语言也可能随之发生变化，这就造成了其可移植性和重用性都很差的后果。&lt;/p&gt;

&lt;p&gt;如今，已经没有人再用机器语言进行实际编程了。&lt;/p&gt;

&lt;h2 id=&quot;汇编语言&quot;&gt;汇编语言&lt;/h2&gt;
&lt;p&gt;汇编语言在机器语言之后出现，但也是在20世界50年代。汇编语言直到今天还在被使用，主要被用于一些对速度要求高的场合，例如嵌入式系统、驱动程序等。&lt;/p&gt;

&lt;p&gt;汇编语言的出现主要是为了解决机器语言看不懂的缺点。机器语言的一连串0和1简直就是天书，而汇编语言已经开始有自己的语法。汇编语言的使用者对于计算机的体系结构，各个寄存器的作用，程序计数器等要有基本的了解。由于引入了语法，汇编语言需要经过编译器转化为机器语言再交由计算机执行。从这里就可以看出，计算机中引入中间层的观点是很早就有了的。此外，汇编语言的诞生也表明了程序是写给程序员看的，而不是写给机器看的。&lt;/p&gt;

&lt;p&gt;汇编语言的优点是目标代码简短，占用内存少，执行速度快，且比起机器语言来便于记忆。但汇编语言没有解决机器语言无法移植的特点。在不同的机器之间，汇编语言的语法也不相同。另一方面，由于汇编语言直接对寄存器等进行操作，程序的真实意图也被掩盖在细节之中，并且常常需要大量的代码完成简单的工作。最后，汇编语言也很容易产生bug并且难于调试。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">前段时间想去了解一下计算机技术的发展历史，但是搜了一下没有发现很系统的讲述这方面内容的书或者博客，因此就想自己来调查了解一下，也挺有意思的。</summary></entry><entry><title type="html">Arts Weekfour Vim插件管理 Vundle</title><link href="http://localhost:4000/ARTS-WeekFour-vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-Vundle/" rel="alternate" type="text/html" title="Arts Weekfour Vim插件管理 Vundle" /><published>2019-05-01T00:00:00+08:00</published><updated>2019-05-01T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFour-vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-Vundle</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFour-vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-Vundle/">&lt;p&gt;vim有非常之多的插件，因此需要一个插件管理器来管理这些插件。而Vundle就是这一利器。&lt;/p&gt;

&lt;p&gt;Vundle是vim bundle的缩写。它能自动跟踪&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中的插件，安装、更新、卸载插件。Vundle自动管理插件的运行时目录并会在安装和更新后自动重新生成帮助tag。&lt;/p&gt;

&lt;h2 id=&quot;vundle的安装设置&quot;&gt;Vundle的安装设置：&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;首先输入&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone https://github.com/VundleVim/Vundle.vim.git ~/vim/bundle/Vundle.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;将下列内容保存到~/.vimrc中&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set nocompatible              &quot; be iMproved, required
filetype off                  &quot; required

&quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&quot; alternatively, pass a path where Vundle should install plugins
&quot;call vundle#begin('~/some/path/here')

&quot; let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

&quot; The following are examples of different formats supported.
&quot; Keep Plugin commands between vundle#begin/end.
&quot; plugin on GitHub repo
Plugin 'tpope/vim-fugitive'
&quot; plugin from http://vim-scripts.org/vim/scripts.html
Plugin 'L9'
&quot; Git plugin not hosted on GitHub
Plugin 'git://git.wincent.com/command-t.git'
&quot; git repos on your local machine (i.e. when working on your own plugin)
Plugin 'file:///home/gmarik/path/to/plugin'
&quot; The sparkup vim script is in a subdirectory of this repo called vim.
&quot; Pass the path to set the runtimepath properly.
Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
&quot; Avoid a name conflict with L9
Plugin 'user/L9', {'name': 'newL9'}

&quot; All of your Plugins must be added before the following line
call vundle#end()            &quot; required
filetype plugin indent on    &quot; required
&quot; To ignore plugin indent changes, instead use:
&quot;filetype plugin on
&quot;
&quot; Brief help
&quot; :PluginList          - list configured plugins
&quot; :PluginInstall(!)    - install (update) plugins
&quot; :PluginSearch(!) foo - search (or refresh cache first) for foo
&quot; :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins
&quot;
&quot; see :h vundle for more details or wiki for FAQ
&quot; Put your non-Plugin stuff after this line
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;安装配置好的bundle:打开vim并输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginInstall&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;插件&quot;&gt;插件&lt;/h2&gt;
&lt;h3 id=&quot;配置插件&quot;&gt;配置插件&lt;/h3&gt;
&lt;p&gt;Vundle跟踪&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令。每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令让Vundle使能脚本并将其加入|runtimepath|中。&lt;/p&gt;

&lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令有一个指向脚本的URI。在URI后面可选择接受第二个参数。这个参数必须是一个目录。每个键值对都是一个配置选项。&lt;/p&gt;

&lt;p&gt;下面是一些配置选项&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;‘rtp’:设置repo中的一个目录为vim插件所在目录。该目录将被加入|runtimepath|中&lt;/li&gt;
  &lt;li&gt;‘name’:将放置配置脚本的本地拷贝的目录名字&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;支持的uri&quot;&gt;支持的URI&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Github:当user/repo被传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;时Github被使用,例如&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'VundleVim/Vundle.vim' =&amp;gt; https://github.com/VundleVim/Vundle.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Vim Scripts:没有’/’的单词都被认为从Vim Scripts中获取&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'ctrlp.vim' =&amp;gt; https://github.com/vim-scripts/ctrlp.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;本地插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'file:///path/from/root/to/plugin'&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;基本使用方式&quot;&gt;基本使用方式&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginInstall&lt;/code&gt; 安装&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中配置的所有插件，也可以在后面跟上插件名特定安装&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginUpdate&lt;/code&gt; 更新插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginSearch&lt;/code&gt; 需要有&lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;,搜索指定插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginList&lt;/code&gt; 列举已经安装的插件列表&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginClean&lt;/code&gt; 清除不在&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;而在安装目录下的插件&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">vim有非常之多的插件，因此需要一个插件管理器来管理这些插件。而Vundle就是这一利器。</summary></entry><entry><title type="html">Arts Weekfour Leetcode703 Kthinstream</title><link href="http://localhost:4000/ARTS-WeekFour-Leetcode703-kthInStream/" rel="alternate" type="text/html" title="Arts Weekfour Leetcode703 Kthinstream" /><published>2019-04-30T00:00:00+08:00</published><updated>2019-04-30T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFour-Leetcode703-kthInStream</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFour-Leetcode703-kthInStream/">&lt;p&gt;Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;

&lt;p&gt;Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这题其实的意思是在一段流里找第k大的数，也就是说对于连续的流，每次调用函数都能获取当前第k大的数。&lt;/p&gt;

&lt;p&gt;这也是一道很经典的题了，但是最开始想着要保留所有的数，于是就超时了。实际上很容易想到，既然是求第k大的数，那么只需要保留前k个数即可。每新来一个数都将它与前k个数中最小的数比较，如果小于它就丢弃，如果大于它就将它插入合适位置。这里最开始我想的是排序，利用插入排序的方式。可是后来想到显然小顶堆是最合适的数据结构。另外，go语言很久没用了，这里编译错误好几次，还需要复习go语言的用法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type KthLargest struct {
    h *IntHeap
    num int
}

// An IntHeap is a min-heap of ints.
type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] &amp;lt; h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    // Push and Pop use pointer receivers because they modify the slice's length,
    // not just its contents.
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func Constructor(k int, nums []int) KthLargest {
    h := IntHeap(nums)
    heap.Init(&amp;amp;h)
    return KthLargest{&amp;amp;h, k}
}


func (this *KthLargest) Add(val int) int {
    heap.Push(this.h, val)
    for len(*(this.h)) &amp;gt; this.num {
        heap.Pop(this.h)
    } 
    res := (*this.h)[0]
    return res
}


/**
 * Your KthLargest object will be instantiated and called as such:
 * obj := Constructor(k, nums);
 * param_1 := obj.Add(val);
 */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</summary></entry><entry><title type="html">Arts Weekfour Twelve Factor(四)</title><link href="http://localhost:4000/ARTS-WeekFour-Twelve-Factor(%E5%9B%9B)/" rel="alternate" type="text/html" title="Arts Weekfour Twelve Factor(四)" /><published>2019-04-30T00:00:00+08:00</published><updated>2019-04-30T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekFour-Twelve-Factor(%E5%9B%9B)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekFour-Twelve-Factor(%E5%9B%9B)/">&lt;p&gt;Dev/prod parity&lt;br /&gt;
Logs&lt;br /&gt;
Admin processes&lt;/p&gt;

&lt;h2 id=&quot;十开发环境生产环境相同&quot;&gt;十、开发环境/生产环境相同&lt;/h2&gt;
&lt;p&gt;保持开发环境、模拟环境和生产环境尽可能相似&lt;/p&gt;

&lt;p&gt;历史上，在开发环境和生产环境之间有三道鸿沟，分别位：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;时间：开发者可能在需要花费几天甚至几个月才运行的代码上工作&lt;/li&gt;
  &lt;li&gt;人事：开发者写代码，运维工程师部署它&lt;/li&gt;
  &lt;li&gt;工具：开发者使用Nginx，SQLite和OSX而实际生产环境可能是Apache，MySQL和Linux&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;twelve-factor app需要使上面三者尽可能小来便于持续部署。&lt;/p&gt;

&lt;p&gt;以后台服务(backing services)为例，很多语言提供库来简化与其的通信，例如使用适配器使其能适配不同的数据库。有时候开发者会倾向于在本地使用轻量级的数据库而在正式部署时使用重量级的数据库。&lt;/p&gt;

&lt;p&gt;twelve-factor app的开发者拒绝在开发环境和生产环境之间使用不同的后台服务。&lt;/p&gt;

&lt;p&gt;对不同后台服务的适配仍然是有用的，例如在改变后台服务时。但app的所有部署(开发环境，模拟环境和生产环境)都应当具有相同版本的后台服务&lt;/p&gt;

&lt;h2 id=&quot;十一日志&quot;&gt;十一、日志&lt;/h2&gt;
&lt;p&gt;将日志当做事件流对待&lt;/p&gt;

&lt;p&gt;日志提供了运行app的行为事件。它是从所有的进程和后台服务中得到的聚合的、按时间顺序排列的流。&lt;/p&gt;

&lt;p&gt;一个twelve factor app从不关心输出流的路由或是存储。它不应当写日志文件或者管理它们。每个运行的进程都只是将事件流写入&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;在开发环境中，开发者通过终端的流观察app的行为。在模拟或生产环境中，每个进程的流将被执行环境捕捉，并被路由到一个或多个最终目的地来作为长期文件。这些文件对于app是不可见并不可配置的，完全由执行环境来管理。&lt;/p&gt;

&lt;p&gt;app的事件流还可以被送到日志索引和分析系统，例如Splunk，或是一个通用目的的存储系统例如Hadoop/Hive。这些系统能提供更多的功能&lt;/p&gt;

&lt;h2 id=&quot;管理进程&quot;&gt;管理进程&lt;/h2&gt;
&lt;p&gt;将管理进程作为一次性的、不是经常开关的进程&lt;/p&gt;

&lt;p&gt;开发者经常希望有一个一次性的管理进程，例如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;运行数据库迁移&lt;/li&gt;
  &lt;li&gt;运行一个控制台&lt;/li&gt;
  &lt;li&gt;运行上传到app repo中的一次性脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一次性的管理进程应当和app的常规长时运行进程运行在同一个环境下，使用相同的代码库和配置，不需要进行同步措施。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Dev/prod parity Logs Admin processes</summary></entry><entry><title type="html">技术学习之路</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" rel="alternate" type="text/html" title="技术学习之路" /><published>2019-04-26T00:00:00+08:00</published><updated>2019-04-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">&lt;p&gt;这篇文章想讲讲对于学计算机技术应该怎么学，我自己的思考与观点。&lt;/p&gt;

&lt;p&gt;说起来，Share好像变成了一个分享自己观点的东西。本意上Share应该是分享技术相关内容的。这样可能有点违规，但我觉得，分享自己的观点也不差，甚至非技术的内容也可以，因为这样促使人真正的去整理观点，审视自己，而人生除了技术之外还有很多东西能从这么做获益。&lt;/p&gt;

&lt;p&gt;说回正题，计算机技术学习之路是一个很广泛的概念。目前计算机衍生出了这么多分支，肯定不可能每条都一样，因此这篇文章讲的是很宽泛的内容。此外，我是纯自学学的计算机，我想目前社会上像我这样的人不在少数，我的观点可能多多少少有点启发意义。&lt;/p&gt;

&lt;h2 id=&quot;深度和广度&quot;&gt;深度和广度&lt;/h2&gt;
&lt;p&gt;深度和广度是计算机技术中常常被人们谈及的领域，究竟是深度更重要还是广度更重要也常常被讨论。实际上，深度往往伴随着广度，深度到了一定地步，伴随着而来的就是涉及到的知识面更广。而广度——广度并不一定有深度，你可以从计算机工程到计算机理论各个领域全部涉及一遍。&lt;/p&gt;

&lt;p&gt;然而，对于初学者而言，我认为还是广度更重要。求深度是一件好事，尤其现在社会分工日益精细了。但我认为，先求广度可以让初学者对计算机技术涉及的各个领域有一个基本的概念。在这之后寻求深度，往往花费时间更少。举例来说，我个人最喜欢的读书方式就是先快速读一遍，再精读一遍，最后再快速读一遍。第一遍是对书的主题、叙述方式有一个大概的了解，并且判断是否有必要再读第二遍。第二遍则是把第一遍留下的问题或者感兴趣的地方重点去看。第三编则类似于快速复习，查漏补缺。我喜欢的技术学习路线也和读书很像，先广后深再广，最后的广度就是复习自己学到的东西并看是否还有不会的。&lt;/p&gt;

&lt;p&gt;另外，广度还有一个好处是能把知识点连起来。很多时候涉及的多了就会发现不同的问题都能有相同的方法解决，比如随处可见的缓存，算法里的分治等。对于这些东西有个初步的概念后，日后的学习就能知道重点——一般出现的越多说明它越重要，就能事半功倍。最重要的是，这些方法体现了计算机整个学科的精髓，而跨学科思考的思想也是很重要的。这些思想往往不局限于计算机，而是能解决各种问题。&lt;/p&gt;

&lt;h2 id=&quot;内功招式和武器&quot;&gt;内功、招式和武器&lt;/h2&gt;
&lt;p&gt;在提到计算机技术的基础时，有一个很常见的比喻，就是内功、招式和武器。内功就是基础，招式就是技术方法，武器就是工具。人们往往会强调基础的重要性，说如果没有内功，空有招式，打到敌人也不疼。如果没有招式，空有内功，至少浑厚的内功还能给你减伤。至于武器，则有锦上添花之效。&lt;/p&gt;

&lt;p&gt;对于上面的比喻，我想说，说的太有道理了。基础的重要性是怎么强调也不为过的。随着时间的流逝，基础好的人其个人能力是先慢后块，而基础差的人则是先快后慢，最后还是得回来补。&lt;/p&gt;

&lt;p&gt;但是对于基础怎么学，我有点想法。很多人一上来推荐书，推荐看视频。从编程语言到操作系统，各种基础类的资源推荐了个遍。然而这些东西学完恐怕要花个几年，而且又很枯燥，往往无法解决一些实际的问题。还是用上面那个比喻，学内功是很辛苦的，而且进度缓慢。而学招式还是挺好玩的，至少能摆个花架子唬人。&lt;/p&gt;

&lt;p&gt;我认为，可以先学招式无妨。在学招式的过程中伴随着内功的修炼，或者学完招式之后再学内功，也是可以的。举例来说，在学习网络的时候，可以先学着实现一个简单的qq。在实现的过程中，有些细枝末节可以仅仅了解，而涉及到网络的部分则重点学习，并且尝试不同的方法。在实现过程中遇到的问题可以知其然而不知其所以然，但要记录在案。在实现了这个项目后，翻看《TCP/IP详解卷一》，往往看到某个知识点会和之前的问题对上。在这样的情况下，记忆更深刻，也更有效。&lt;/p&gt;

&lt;h2 id=&quot;学习总结&quot;&gt;学习总结&lt;/h2&gt;
&lt;p&gt;我这里稍微更具体的总结一下学习的方法。&lt;/p&gt;

&lt;p&gt;对于任意一门科目，首先选取一种输入(视频、书甚至百度百科)，大概了解即可，不需要精通。这里所说的了解，是指知道它是什么，有什么用，怎么用。例如编程语言，知道类型是什么意思，怎么定义类型，函数是什么，几种循环结构即可。接下来去找一个实际的问题，去解决它。还是以C语言为例，你可以考虑怎么用C语言画画，用C语言写游戏等等。在解决的过程中你会发现各种问题，比如内存错误，编译错误等等。记下这些错误，并去搜解决它们的方法，但不一定要知道为什么这样可以解决它。最后，挑一本经典书籍或是其他类型的经典输入，仔细的读，并和问题对照。&lt;/p&gt;

&lt;p&gt;想要学的好，就得记住，学习是伴随着枯燥的。刻意练习的核心就是踏出舒适区。如果你感觉到学习过程很轻松，那说明你还没有尽全力，或者还在换一种形式啃自己已经了解的东西。警惕心流，处于心流状态时，有可能也是处于钻牛角尖的状态。&lt;/p&gt;

&lt;p&gt;最后，不要逼自己。实在学不下去的时候，let it go&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">这篇文章想讲讲对于学计算机技术应该怎么学，我自己的思考与观点。</summary></entry><entry><title type="html">Arts Weekthree Vim配置</title><link href="http://localhost:4000/ARTS-WeekThree-vim%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="Arts Weekthree Vim配置" /><published>2019-04-24T00:00:00+08:00</published><updated>2019-04-24T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekThree-vim%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekThree-vim%E9%85%8D%E7%BD%AE/">&lt;p&gt;vim中的配置是十分重要的内容，不同的用户可以根据自己的喜好将vim配置成自己喜爱的样式。本次就根据vim的帮助文档介绍以下vim配置方面的内容。&lt;/p&gt;

&lt;h2 id=&quot;vimrc文件&quot;&gt;vimrc文件&lt;/h2&gt;
&lt;p&gt;vimrc文件中包含了vim在启动时就会执行的命令。对于我们最喜欢的选项和按键映射，可以放到vimrc中&lt;/p&gt;

&lt;p&gt;vimrc文件的名字叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;，对于Unix操作系统和Macintosh操作系统来说，它的路径名一般是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vimrc&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;vimrc文件中可以包含所有能在vim中普通模式下”:”后面执行的命令，最简单的设置选项的指令，其一般格式是&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set &amp;lt;options&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;想要查看有哪些配置可以输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:options&lt;/code&gt;查看或是在帮助中查看。&lt;/p&gt;

&lt;p&gt;对于特定的配置，可以输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:help '&amp;lt;option name&amp;gt;'&lt;/code&gt;查看。另外，在设置某个选项时在后面加&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;即可恢复默认设置&lt;/p&gt;

&lt;p&gt;为了使vimrc文件起作用需要退出vim再重新启动&lt;/p&gt;

&lt;p&gt;下面列举一些设置作为例子说明&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set autoindent&lt;/code&gt;:自动缩进，使用前一行的缩进作为当前行缩进&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if has(&quot;vms&quot;)
  set nobackup
else
  set backup
endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使得vim在覆写一个文件时保存有该文件的备份，而在VMS系统上则不用，因为VMS系统自带有这个功能。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set history=50&lt;/code&gt;:在历史记录中保持50个命令和50种搜索模式&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set ruler&lt;/code&gt;:允许在右下角显示当前游标的位置&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set showcmd&lt;/code&gt;:显示普通模式下输入的命令&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set incsearch&lt;/code&gt;:在输入搜索模式下显示和其匹配的内容&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;map Q gq&lt;/code&gt;:这是一个按键映射，将&lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt;键映射到&lt;code class=&quot;highlighter-rouge&quot;&gt;gq&lt;/code&gt;按键上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;filetype plugin indent on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;文件类型检测：当开始编辑一个文件时，vim将会通过文件扩展名试图发现文件的类型。文件类型可被用于语法高亮等用途&lt;/li&gt;
  &lt;li&gt;使用文件类型插件文件(filetype plugin files):不同的文件类型有不同的设置。这些公共的有用选项在vim的文件类型插件中&lt;/li&gt;
  &lt;li&gt;使用缩进文件：不同类型的文件种类使用不同的缩进&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;简单的映射&quot;&gt;简单的映射&lt;/h2&gt;
&lt;p&gt;按键映射应该是所有编辑器必备的功能了。在vim中很简单，举例来说，在vimrc文件中添加&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:map &amp;lt;F5&amp;gt; i{&amp;lt;Esc&amp;gt;ea}&amp;lt;Esc&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的这个映射解析为&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&amp;lt;F5&amp;gt; 映射按键是F5键&lt;/li&gt;
  &lt;li&gt;i{ 转换为插入模式并输入{&lt;/li&gt;
  &lt;li&gt;&amp;lt;Esc&amp;gt; 退出为普通模式&lt;/li&gt;
  &lt;li&gt;ea}到单词结尾并输入}&lt;/li&gt;
  &lt;li&gt;&amp;lt;Esc&amp;gt;最后转化为普通模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，一般情况下输入一个单词，按F5键即可在其两端加上大括号&lt;/p&gt;

&lt;h2 id=&quot;添加插件&quot;&gt;添加插件&lt;/h2&gt;
&lt;p&gt;vim可通过添加插件来扩展自己的功能。插件其实就是vim在启动时自动加载的vim脚本文件。在&lt;code class=&quot;highlighter-rouge&quot;&gt;plugin&lt;/code&gt;文件夹中添加对应文件就可添加插件&lt;/p&gt;

&lt;p&gt;有两种插件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;全局插件：对所有文件都有效&lt;/li&gt;
  &lt;li&gt;文件类型插件：对特定文件类型才有效&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;全局插件&quot;&gt;全局插件&lt;/h3&gt;
&lt;p&gt;全局插件在启动时自动加载，它们提供了大部分通用的功能。&lt;/p&gt;

&lt;p&gt;添加全局插件只需要两步，获取全局插件，放入对应文件夹&lt;/p&gt;

&lt;p&gt;获取全局插件有许多地方，这里不再详述。若想要使用对应插件，则首先阅读该插件的说明文档看是否有需要注意的地方，然后将文件复制到插件文件夹下。对于Unix来说，位置一般是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vim/plugin&lt;/code&gt;。值得注意的是，不一定要直接放入&lt;code class=&quot;highlighter-rouge&quot;&gt;plugin&lt;/code&gt;目录下，也可以在其中创建子目录并放入其中&lt;/p&gt;

&lt;h3 id=&quot;文件类型插件&quot;&gt;文件类型插件&lt;/h3&gt;
&lt;p&gt;在使用文件类型插件时，需要使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;:filetype plugin on&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加文件类型插件需要将它放入特定的文件夹，在Unix环境下就是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vim/ftplugin&lt;/code&gt;.对于文件类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;filetype&lt;/code&gt;的插件，该插件名字可以为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;_&amp;lt;name&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;/&amp;lt;name&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;name&amp;gt;可以是任意的&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">vim中的配置是十分重要的内容，不同的用户可以根据自己的喜好将vim配置成自己喜爱的样式。本次就根据vim的帮助文档介绍以下vim配置方面的内容。</summary></entry></feed>