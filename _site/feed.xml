<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.7.4">Jekyll</generator>
<link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
<link href="http://localhost:4000/" rel="alternate" type="text/html" />
<updated>2019-07-06T16:11:17+08:00</updated>
<id>http://localhost:4000/</id>
<title>Tonfeiz</title>
<subtitle></subtitle>
<author>
<name>Tonfeiz</name>
</author>
<entry>
<title>ATS Week Thirteen ProGit(五)</title>
<link href="http://localhost:4000/ATS-WeekThirteen-ProGit(%E4%BA%94)/" rel="alternate" type="text/html" title="ATS Week Thirteen ProGit(五)" />
<published>2019-07-06T00:00:00+08:00</published>
<updated>2019-07-06T00:00:00+08:00</updated>
<id>http://localhost:4000/ATS-WeekThirteen-ProGit(五)</id>
<content type="html" xml:base="http://localhost:4000/ATS-WeekThirteen-ProGit(%E4%BA%94)/">&lt;p&gt;本周把有关分支的部分结束。&lt;/p&gt;

&lt;h2 id=&quot;branch-management&quot;&gt;Branch Management&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch -v&lt;/code&gt;可以显示所有分支以及所有分支的最后一次提交的信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch --merged&lt;/code&gt;可以显示当前分支和已经合并到当前分支的分支。已经合并到当前分支的分支则可以安全的删除。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch --no-merged&lt;/code&gt;会显示当前分支和还没合并的分支。删除还没合并的分支会报错，除非强制删除。&lt;/p&gt;

&lt;h2 id=&quot;branching-workflows&quot;&gt;Branching workflows&lt;/h2&gt;
&lt;h3 id=&quot;long-running-branches&quot;&gt;Long-Running Branches&lt;/h3&gt;
&lt;p&gt;一种工作流是维护一个稳定的master分支，开出其他分支用于开发或测试。当其他分支经测试稳定之后，再将该分支并入稳定的分支中。&lt;/p&gt;

&lt;p&gt;可以开出多个分支，每一个分支表示不同的稳定性。当一个分支的稳定性达到一定程度则将它并入另一分支即可。&lt;/p&gt;

&lt;h3 id=&quot;topic-branches&quot;&gt;Topic Branches&lt;/h3&gt;
&lt;p&gt;另一种很常见的工作流是主题相关工作流。当你工作在master上时，对于要修复的bug、要添加的特性等都可以新开一个分支，在该分支上进行与这些内容相关的工作，当工作完成后则合并入master分支即可。&lt;/p&gt;

&lt;h2 id=&quot;remote-branches&quot;&gt;Remote Branches&lt;/h2&gt;
&lt;p&gt;远程跟踪分支是指向远程分支状态的指针。它们是不能自主移动的本地指针。只有在你从远程分支中fetch或是pull（与远程分支取得联系）时，它们才会与远程分支进行同步。&lt;/p&gt;

&lt;p&gt;远程跟踪分支的名字是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt;,例如&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;origin&amp;gt;/&amp;lt;master&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;下面还是用例子来说明。例如在你的网络&lt;code class=&quot;highlighter-rouge&quot;&gt;git.ourcompany.com&lt;/code&gt;中有一个git server。你从它&lt;code class=&quot;highlighter-rouge&quot;&gt;clone&lt;/code&gt;后，Git会自动为你将该server取名为&lt;code class=&quot;highlighter-rouge&quot;&gt;origin&lt;/code&gt;，将它的数据拉下来，创造一个指向它的&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支的指针并将其命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt;。此外，Git还会给你本地的&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/figure30.png&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;

&lt;p&gt;假如你在本地做了一些工作，同时其他人远程提交了一些工作，则此时你们进程不同。但由于你没有与远程主机联系，因此你并不知情。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/figure31.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设你进行了fetch(&lt;code class=&quot;highlighter-rouge&quot;&gt;git fetch origin&lt;/code&gt;),则示意图如下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/figure32.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pushing&quot;&gt;Pushing&lt;/h3&gt;
&lt;p&gt;可以利用&lt;code class=&quot;highlighter-rouge&quot;&gt;git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;命令推送自己的代码。例如，你有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;serverfix&lt;/code&gt;分支要推送，则命令为&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin serverfix&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里Git将该命令进行了展开。它会把&lt;code class=&quot;highlighter-rouge&quot;&gt;serverfix&lt;/code&gt;分支名扩展为&lt;code class=&quot;highlighter-rouge&quot;&gt;refs/heads/serverfix:refs/heads/serverfix&lt;/code&gt;。它的意思是“推送我的本地serverfix分支以更新远程的serverfix分支”。在命令中也可以简写为&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin serverfix:serverfix&lt;/code&gt;。如果本地分支与远程分支不同也可以，命令为&lt;code class=&quot;highlighter-rouge&quot;&gt;git push origin &amp;lt;local_branch&amp;gt;:&amp;lt;remote_branch&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;要注意的是如果你&lt;code class=&quot;highlighter-rouge&quot;&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt;获得新的远程跟踪分支，你不能获得在本地获得可编辑的分支的拷贝，你只是有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt;的不可修改的指针而已。你可以利用&lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt;把该分支合并到自己的分支，也可以利用&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b &amp;lt;local_branch&amp;gt; &amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt;来获得本地的对应分支。&lt;/p&gt;

&lt;h3 id=&quot;tracking-branches&quot;&gt;Tracking Branches&lt;/h3&gt;
&lt;p&gt;从远程跟踪分支签出一个本地分支会自动创建一个“跟踪分支”（tracking branch）。跟踪分支是和远程分支有直接关系的本地分支。如果你在一个跟踪分支中并且输入&lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt;，Git会自动知道从哪个server fetch以及要合并到哪个分支。&lt;/p&gt;

&lt;p&gt;当你克隆一个库，它会自动创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支跟踪&lt;code class=&quot;highlighter-rouge&quot;&gt;origin/master&lt;/code&gt;。然而，你也可以设置其他的跟踪分支——跟踪其他remote的分支，或者不跟踪master的分支。一个简单的例子是刚刚看到的&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b &amp;lt;branch&amp;gt; &amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;-vv&lt;/code&gt;选项来看所有的分支分别跟踪的是哪个远程分支以及你的本地分支是落后还是超前。&lt;/p&gt;

&lt;p&gt;要注意的是，落后和超前的数字是从你上次从各个server处fetch时开始算起的。该命令不会与远程server取得联系。&lt;/p&gt;

&lt;h3 id=&quot;deleting-remote-branches&quot;&gt;Deleting Remote Branches&lt;/h3&gt;
&lt;p&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;--delete&lt;/code&gt;选项删除某个远程分支。这其实只是在远程删除了某个指针。真正的删除会在某个时候垃圾回收时进行。因此短时间内的恢复是很容易的。&lt;/p&gt;

&lt;h2 id=&quot;rebasing&quot;&gt;Rebasing&lt;/h2&gt;
&lt;h3 id=&quot;the-basic-rebase&quot;&gt;The Basic Rebase&lt;/h3&gt;
&lt;p&gt;Rebase是Git中另一种将变化从一个分支集成到另一个分支的方法（还有一个是merge）。&lt;/p&gt;

&lt;p&gt;例如你有两个分支&lt;code class=&quot;highlighter-rouge&quot;&gt;experiment&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;，你想将&lt;code class=&quot;highlighter-rouge&quot;&gt;experiment&lt;/code&gt;分支合并到&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;中去。你可以输入以下命令。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout experiment
$ git rebase master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该操作两个分支的公共祖先，得到你所在分支的每个commit引入的变化，将这些变化保存到临时文件中，将当前分支重置为你rebase到的分支的相同的commit，最后依次应用这些变化。&lt;/p&gt;

&lt;p&gt;此时，你就可以回到&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支并进行fast-forward merge。&lt;/p&gt;

&lt;p&gt;两种集成方式的结果是一样的，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;能提供更干净的历史。即便是并行的工作，使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;rebase&lt;/code&gt;之后看上去也是串行的。&lt;/p&gt;

&lt;h3 id=&quot;the-perils-of-rebasing&quot;&gt;The Perils of Rebasing&lt;/h3&gt;
&lt;p&gt;Rebase的使用原则是：&lt;br /&gt;
&lt;strong&gt;不要rebase在你的仓库之外的、人们也许会基于它做工作的commit&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当你rebase时，你在抛弃已经存在的commits并创建新的但不同的commits。如果你push了一些commits，其他人pull了这些东西并基于它们开展了一些工作，然后你用&lt;code class=&quot;highlighter-rouge&quot;&gt;git rebase&lt;/code&gt;重写了这些commits然后重新push了它们，那么你的协同者不得不重写merge他们的工作，而当你又将他们的工作拉下时，事情会变得更复杂。&lt;/p&gt;

&lt;p&gt;我的理解是，如果你把commit push了，那么就不要再rebase这些commit了。本地的commit则可以rebase。&lt;/p&gt;

&lt;h3 id=&quot;rebase-vs-merge&quot;&gt;Rebase vs. Merge&lt;/h3&gt;
&lt;p&gt;Rebase和Merge的使用要根据对历史的不同解读来。&lt;/p&gt;

&lt;p&gt;一种对历史的解读认为历史就是对于发生的事情的记录，改变历史则记录它就没有意义了。&lt;/p&gt;

&lt;p&gt;还有一种对历史的解读则认为历史是你的工程是如何构建的过程的故事。为了其他人或者后来者能更清楚的看到工程的发展流程，需要对历史进行一定的改进。&lt;/p&gt;

&lt;p&gt;不管哪一种都有各自的道理。Git支持两种观点，具体实行则要看具体的人、具体的工程。&lt;/p&gt;

</content>
<summary>本周把有关分支的部分结束。</summary>
</entry>
<entry>
<title>ARTS Week Thirteen Leetcode868 BinaryGap</title>
<link href="http://localhost:4000/ARTS-WeekThriteen-Leetcode868-BinaryGap/" rel="alternate" type="text/html" title="ARTS Week Thirteen Leetcode868 BinaryGap" />
<published>2019-07-06T00:00:00+08:00</published>
<updated>2019-07-06T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekThriteen-Leetcode868-BinaryGap</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekThriteen-Leetcode868-BinaryGap/">&lt;p&gt;Given a positive integer N, find and return the longest distance between two consecutive 1’s in the binary representation of N.&lt;/p&gt;

&lt;p&gt;If there aren’t two consecutive 1’s, return 0.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 22
Output: 2
Explanation: 
22 in binary is 0b10110.
In the binary representation of 22, there are three ones, and two consecutive pairs of 1's.
The first consecutive pair of 1's have distance 2.
The second consecutive pair of 1's have distance 1.
The answer is the largest of these two distances, which is 2.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;这题的意思是找出十进制数的二进制表示中两个连续的1之间最远的距离。思路也非常简单，在将十进制数转换为二进制时记录上一个1和当前的1的位置，然后相减即得到距离。在转换同时记录距离的最大值即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    int binaryGap(int N) {
        int last_pos = -1, cur_pos = -1;
        
        int mod;
        int max_dis = 0;
        int cur_iter = 0;
        while(N &amp;gt; 0) {
            mod = N % 2;
            if(mod == 1) {
                last_pos = cur_pos;
                cur_pos = cur_iter;
                if(last_pos &amp;gt; -1 &amp;amp;&amp;amp; cur_pos - last_pos &amp;gt; max_dis) {
                    max_dis = cur_pos - last_pos;
                }
            }
            N /= 2;
            cur_iter++;
        }
        
        return max_dis;
        
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>Given a positive integer N, find and return the longest distance between two consecutive 1’s in the binary representation of N.</summary>
</entry>
<entry>
<title>Envoy学习之旅(五)</title>
<link href="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%BA%94)/" rel="alternate" type="text/html" title="Envoy学习之旅(五)" />
<published>2019-06-28T00:00:00+08:00</published>
<updated>2019-06-28T00:00:00+08:00</updated>
<id>http://localhost:4000/envoy学习之旅(五)</id>
<content type="html" xml:base="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E4%BA%94)/">&lt;p&gt;本次继续阅读Envoy的文档。&lt;/p&gt;

&lt;h3 id=&quot;health-checking&quot;&gt;Health checking&lt;/h3&gt;
&lt;p&gt;主动健康检查可以在每个上游cluster上配置。Envoy支持三种不同类型的健康检查：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;HTTP&lt;/strong&gt;: Envoy会发送HTTP请求给上游host。默认情况下，如果host是健康的，它会期待收到一个200回应。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;L3/L4&lt;/strong&gt;: Envoy会发送可配置的字节缓冲给上游host。它期待在回应中该字节缓冲被回射(echo)。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Redis&lt;/strong&gt;: Envoy会发送Redis的PING命令并期待收到PONG回应。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;http-health-checking-filter&quot;&gt;HTTP health checking filter&lt;/h4&gt;
&lt;p&gt;Envoy包括了一个可被安装在配置好的HTTP监听器上的健康检查过滤器。该过滤器有几种操作模式：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;No pass through&lt;/strong&gt;: 该模式下，健康检查请求不会传送给本地服务。Envoy会根据当前服务器的状态(draining state)发回200或503响应&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;No pass through, computed from upstream cluster health&lt;/strong&gt;: 在该模式下，Envoy会根据上游的一个或多个cluster中是否存在指定比例的服务器可用来返回200或503响应。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pass through&lt;/strong&gt;: 该模式下，健康检查请求会传送给本地服务。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pass through with caching&lt;/strong&gt;: 该模式下，Envoy会传送健康检查请求给本地服务，然后会缓存结果一段时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;connection-pooling&quot;&gt;Connection pooling&lt;/h3&gt;
&lt;p&gt;对于HTTP流量来说，Envoy支持在底层线协议(HTTP/1.1或HTTP/2)之上一层的抽象连接池。使用的过滤器代码不需要知道底层协议是否支持真正的复用。底层实现实际上有下面的高层属性。&lt;/p&gt;

&lt;h4 id=&quot;http11&quot;&gt;HTTP/1.1&lt;/h4&gt;
&lt;p&gt;HTTP/1.1连接池在需要时就像上游host获取连接(最大不超过熔断限制)。请求在连接可用时与其绑定。连接可用有几种原因，例如一个连接已经处理完了之前的请求，一个新的连接已经准备好接收请求。&lt;/p&gt;

&lt;h4 id=&quot;http2&quot;&gt;HTTP/2&lt;/h4&gt;
&lt;p&gt;HTTP/2连接池对每个上游host获取一个连接。所有的请求都通过该连接复用。如果收到了GOAWAY帧或者连接数达到了最大流限制，连接池会创建一个新的连接并且排空已经存在的连接。&lt;/p&gt;

&lt;h3 id=&quot;load-balancing&quot;&gt;Load balancing&lt;/h3&gt;
&lt;h4 id=&quot;what-is-load-balancing&quot;&gt;What is Load Balancing?&lt;/h4&gt;
&lt;p&gt;负载均衡指的是将流量分给一个cluster中的不同host的方法。Envoy提供了不同的负载均衡策略。从高层看，可以把这些策略分为两种：全局负载均衡和分布式负载均衡。&lt;/p&gt;

&lt;h5 id=&quot;distributed-load-balancing&quot;&gt;Distributed Load Balancing&lt;/h5&gt;
&lt;p&gt;分布式负载均衡指的是让Envoy自己基于上游hosts的位置决定负载如何分给端点。&lt;/p&gt;
&lt;h5 id=&quot;global-load-balancing&quot;&gt;Global Load Balancing&lt;/h5&gt;
&lt;p&gt;全局负载均衡指的是有一个全局的authority决定负载应该怎样在hosts之间分布。对Envoy来说，这可以通过控制面完成。控制面可以通过指定不同的参数(例如优先级、本地权重、端点权重和端点健康等)来分发负载。&lt;/p&gt;

&lt;p&gt;一个简单的例子是控制面基于网络拓扑给hosts设置不同的优先级来确保需要更少的网络跳数的hosts优先被选择。&lt;/p&gt;

&lt;h5 id=&quot;both-distributed-and-global&quot;&gt;Both Distributed and Global&lt;/h5&gt;
&lt;p&gt;大部分复杂的部署会同时使用两种方法。例如，全局负载均衡可以被用来定义高级路由优先级和权重，而分布式负载均衡可以被用来对系统变化做出反应。&lt;/p&gt;

&lt;h4 id=&quot;supported-load-balancers&quot;&gt;Supported load balancers&lt;/h4&gt;
&lt;p&gt;当过滤器需要获取到上游cluster中的某个host的连接，cluster manager会使用负载均衡策略来决定选择哪个host。&lt;/p&gt;

&lt;h5 id=&quot;weight-round-robin&quot;&gt;Weight round robin&lt;/h5&gt;
&lt;p&gt;每个有效的上游host以循环方式被选择。如果&lt;code class=&quot;highlighter-rouge&quot;&gt;weights&lt;/code&gt;被分配给本地的端点，则&lt;code class=&quot;highlighter-rouge&quot;&gt;weighted round robin&lt;/code&gt;策略会被使用。较高权重的端点在循环中出现的次数会更多。&lt;/p&gt;

&lt;h5 id=&quot;weighted-least-request&quot;&gt;Weighted least request&lt;/h5&gt;
&lt;p&gt;最少请求负载均衡依据是否有host的权重大于1来使用不同的算法。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;都是权重1：一种O(1)算法。该算法随机选择N个可用的hosts，然后选择活跃请求最少的host。&lt;/li&gt;
  &lt;li&gt;不都是权重1：如果cluster中的某个host权重大于1(即便这些host权重都相等)，负载均衡器会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;weighted round robin&lt;/code&gt;方式，且每个host的权重会根据host的请求负载动态的变化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;ring-hash&quot;&gt;Ring hash&lt;/h5&gt;
&lt;p&gt;环形哈希负载均衡器对上游的hosts采用一致性哈希算法。每个host通过对它的地址哈希被映射到一个环上；每个请求通过对它的某些性质进行哈希然后找到环上最近的host被路由到某个host上。&lt;/p&gt;

&lt;p&gt;每个host被哈希和放在环上的次数和它的权重成正比。例如，如果host A权重为1而host B权重为2，则环上可能有1个A和2个B。然而这不会提供我们所希望的2:1分割环，因为可能它们被计算出来的哈希值很接近导致环上它们也很近。所以每个host的数量需要同时乘以某个数，例如100个A和200个B。&lt;/p&gt;

&lt;p&gt;当基于优先级的负载均衡被使用，优先级级别也是通过哈希被选择的。&lt;/p&gt;

&lt;h4 id=&quot;priority-levels&quot;&gt;Priority levels&lt;/h4&gt;
&lt;p&gt;在负载均衡期间，Envoy通常只考虑设置在最高优先级的hosts。当最高优先级的端点是健康的，所有的流量都会流往在该优先级的端点。当该优先级的端点变得不健康之后，流量才会流到优先级低一级的端点。&lt;/p&gt;

&lt;p&gt;总体系统可以通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;overprovisioning factor&lt;/code&gt;(默认是1.4))过载。如果80%的某优先级的端点是健康的，则该级别仍然被认为是健康的因为80*1.4 &amp;gt; 100.&lt;/p&gt;

&lt;p&gt;优先级逻辑和整数健康分数一同工作。某个级别的健康分数是(该级别的健康host百分比)*(过载系数)，最大100%.P=0的端点接收(级别0的健康分数)百分比的流量，其余的流向P=1.例如，当50%的P=0的端点是健康时，它们将收到50*1.4=70%的流量。&lt;/p&gt;

&lt;p&gt;健康分数代表了一个级别现在处理流量的能力。因此，如果所有级别的健康分数总和小于100，则Envoy认为现在没有足够的健康端点来处理所有的流量。该总和叫做归一化健康总分(normalized total health)。当归一化健康总分比100低时，流量会依据按照该小于100的总量归一化来分布。&lt;/p&gt;

&lt;h4 id=&quot;degraded-endpoints&quot;&gt;Degraded endpoints&lt;/h4&gt;
&lt;p&gt;Envoy支持将特定的端点标记为降级的，意味着它们能接收流量，但只有在没有足够的健康hosts时才可以。&lt;/p&gt;

&lt;p&gt;路由到降级的hosts可以被认为是路由到低优先级的hosts。在高优先级的hosts变为非健康之后，流量被分给低优先级的hosts。在健康hosts的数量不能处理100%的负载时，流量会分给降级的hosts。&lt;/p&gt;

&lt;h3 id=&quot;outlier-detection&quot;&gt;Outlier detection&lt;/h3&gt;
&lt;p&gt;Outlier检测和驱逐是动态决定一个上游cluster中的hosts是否与其他不同并将该host从健康的负载均衡集中移除的过程。性能可能通过不同的方式衡量，例如连续失败数，短时成功率，短时延迟等。Outlier检测是被动健康检测的一种。Outlier检测是集群配置(cluster configuration)的一部分，需要过滤器来报告错误，超时和重置。目前http router,tcp proxy和redis proxy这三种过来器支持outlier检测。&lt;/p&gt;

&lt;p&gt;检测到的错误分为两类：外部的和本地的。外部产生的错误发生在上游服务器回应收到的请求之时。例如，HTTP服务器返回错误码500或者redis服务器返回无法解码的负载。这些错误发生在Envoy成功连接到host之后。本地错误发生在Envoy与上游host的连接发生问题之时，例如超时、TCP重置、不能连接到特定的端口等。&lt;/p&gt;

&lt;p&gt;检测到的错误类型依赖于过滤器种类。http router过滤器既能检测本地错误也能检测外部错误。tcp proxy过滤器由于不了解高层协议，因此只能检测本地错误。&lt;br /&gt;
默认情况下本地错误和外部错误不分开，也就是它们会一起累加。能通过配置&lt;code class=&quot;highlighter-rouge&quot;&gt;outlier_detection.split_external_local_origin_errors&lt;/code&gt;选项把它们分开。&lt;/p&gt;

&lt;h4 id=&quot;ejection-algorithm&quot;&gt;Ejection algorithm&lt;/h4&gt;
&lt;p&gt;根据outlier检测的种类，驱逐outlier的过程可以是内联的(例如连续5xx)，也可以是有指定的间隔的(例如周期性的成功率)。驱逐算法按照下面的步骤工作：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;一个host被决定为outlier&lt;/li&gt;
  &lt;li&gt;如果没有host被驱逐，Envoy会马上驱逐该host。否则的话，它会检查以确定驱逐的hosts数量在允许的阈值之下。如果已经驱逐的hosts数量在该阈值之上，则该host不会被驱逐&lt;/li&gt;
  &lt;li&gt;该host会被驱逐一段微秒级别的时间。驱逐意味着该host被标记为不健康并且在负载均衡期间不会被使用(除非负载均衡器处于panic状态)。等待时间由配置&lt;code class=&quot;highlighter-rouge&quot;&gt;outlier_detection.base_ejection_time_ms&lt;/code&gt;和该host被拒绝的次数相乘决定——因此该host被拒绝的次数越多，它就越不易被加入集群。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;detection-types&quot;&gt;Detection types&lt;/h4&gt;
&lt;p&gt;Envoy支持下面的几种检测类型。&lt;/p&gt;

&lt;h5 id=&quot;consecutive-5xx&quot;&gt;Consecutive 5xx&lt;/h5&gt;
&lt;p&gt;默认情况下该检测类型将所有生成的错误都纳入考虑。非HTTP过滤器检测到的错误都会被映射到HTTP 5xx。&lt;/p&gt;

&lt;p&gt;在分离模式下，该检测模式只会考虑外部错误而忽视内部错误。&lt;/p&gt;

&lt;h5 id=&quot;consecutive-gateway-failure&quot;&gt;Consecutive Gateway Failure&lt;/h5&gt;
&lt;p&gt;该检测类型是5xx错误的子集，叫做网关错误(502, 503或者504)，并且只被http router支持。&lt;/p&gt;

&lt;h5 id=&quot;consecutive-local-origin-failure&quot;&gt;Consecutive Local Origin Failure&lt;/h5&gt;
&lt;p&gt;该类型只有当配置&lt;code class=&quot;highlighter-rouge&quot;&gt;outlier_detection.split_external_local_origin_errors&lt;/code&gt;为真时才有效。它只会考虑本地错误。如果Envoy重复性地不能连接到一个上游host或与该上游host的通信重复得被中断，该host将被驱逐。&lt;/p&gt;

&lt;h5 id=&quot;success-rate&quot;&gt;Success Rate&lt;/h5&gt;
&lt;p&gt;基于成功率的outlier驱逐模式从cluster中的每个host中合计出成功率，然后基于统计上的outlier检测以一定间隔驱逐hosts。&lt;/p&gt;

&lt;h3 id=&quot;circuit-breaking&quot;&gt;Circuit breaking&lt;/h3&gt;
&lt;p&gt;熔断是分布式系统中的关键成分。快速的失败和尽快对下流背压几乎总是好的。Envoy mesh的一个主要好处是Envoy在网络层实施熔断限制而不是必须对每个应用单独配置和编码。Envoy支持各种类型的分布式的熔断：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Cluster maximum connections&lt;/strong&gt;: Envoy将和上游cluster的所有hosts建立的最大连接数。实际中只对HTTP/1.1集群有用因为HTTP/2对每个host建立单个连接。如果该熔断器溢出则&lt;code class=&quot;highlighter-rouge&quot;&gt;upstream_cx_overflow&lt;/code&gt;计数器会增加。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cluster maximum pending requests&lt;/strong&gt;: 等待一个准备好的连接池连接时最大的将被列入队列中的请求数。由于HTTP/2的请求通过单个连接发送，该熔断器只在初始连接创建时有效，因为马上请求就会被复用了。对于HTTP/1.1，当没有足够的上游连接处理请求时该请求就会被加入等待队列，所以该熔断器在进程的生命期都会起作用。如果该熔断器溢出则&lt;code class=&quot;highlighter-rouge&quot;&gt;upstream_rq_pending_overflow&lt;/code&gt;会增长。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Cluster maximum requests&lt;/strong&gt;: 给定时间时能给所有hosts的最大请求数量。实际中只对HTTP/2集群有效因为HTTP/1.1集群通过最大连接数限制了。如果该熔断器溢出则&lt;code class=&quot;highlighter-rouge&quot;&gt;upstream_rq_pending_overflow&lt;/code&gt;会增长。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cluster maximum active retries&lt;/strong&gt;:&lt;/li&gt;
&lt;/ul&gt;
</content>
<summary>本次继续阅读Envoy的文档。</summary>
</entry>
<entry>
<title>Data Plane &amp;amp; Control Plane</title>
<link href="http://localhost:4000/ARTS-WeekTwelve-DataPlane-ControlPlane/" rel="alternate" type="text/html" title="Data Plane &amp; Control Plane" />
<published>2019-06-26T00:00:00+08:00</published>
<updated>2019-06-26T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekTwelve-DataPlane-ControlPlane</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekTwelve-DataPlane-ControlPlane/">&lt;p&gt;这篇文章介绍了数据面和控制面之间的差别。原文是&lt;a href=&quot;https://blog.envoyproxy.io/service-mesh-data-plane-vs-control-plane-2774e720f7fc&quot;&gt;Service mesh data plane vs. control plane&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先，作者简单介绍了service mesh。在Service mesh中，每个服务有一个sidecar代理。所有的网络流量都通过该代理流到特定地点。服务本身不会知道网络分布，而只知道代理。也就是说，分布式系统网络对服务编写人员来说是不用知道的。&lt;/p&gt;

&lt;h2 id=&quot;数据面data-plane&quot;&gt;数据面(data plane)&lt;/h2&gt;
&lt;p&gt;接下来，作者介绍了数据面(data plane)。数据面其实就是sidecar代理。sidecar代理通常要完成的工作包括：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;服务发现：有哪些上游服务实例是可用的？&lt;/li&gt;
  &lt;li&gt;健康检查：通过服务发现找到的上游服务实例是健康的吗？它们准备好接收网络流量了吗？这可能包括主动(例如，带外ping某个端点)和被动(例如，连续3个5xx回应表示不健康状态)健康检查。&lt;/li&gt;
  &lt;li&gt;路由：本地服务给出了一个REST请求，该把这个请求送到哪个上游服务实例？&lt;/li&gt;
  &lt;li&gt;负载均衡：当上游服务实例被选定后，请求该送到哪个服务实例？超时时间是多少？熔断设置怎么样？&lt;/li&gt;
  &lt;li&gt;认证：对于到来的请求，调用者能通过mTLS或其他机制被秘密的认证吗？&lt;/li&gt;
  &lt;li&gt;观测性：对于每个请求，统计数据，日志和分布式跟踪数据应当被生成。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数据面被用于有条件的翻译、转发和观察每个流入和流出的网络包。&lt;/p&gt;

&lt;h2 id=&quot;控制面control-plane&quot;&gt;控制面(control plane)&lt;/h2&gt;
&lt;p&gt;作者指出，控制面将一些独立的无状态sidecar代理整合起来并将它们变为分布式系统。&lt;/p&gt;

&lt;p&gt;大部分人自身就是控制面。人们自己手动写出静态的配置，并将它们部署到所有的代理上。代理使用这些配置并用数据面处理。&lt;/p&gt;

&lt;p&gt;目前出现了高级的控制面。高级的控制面可以包括控制面UI、工作调度器(例如Kubernetes)、服务发现系统(当调度器启动或停止实例则向该系统汇报)和sidecar代理配置API等。&lt;/p&gt;

&lt;p&gt;最终，控制面的目的还是设置将要被数据面执行的政策。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;数据面：与系统中的每个包/请求接触。对服务发现、健康检查、路由、负载均衡、认证和观测性负责&lt;/li&gt;
  &lt;li&gt;控制面：为运行着的数据面提供政策和配置。不接触系统中的请求/包。控制面将所有的数据面转化为分布式系统。&lt;/li&gt;
&lt;/ul&gt;
</content>
<summary>这篇文章介绍了数据面和控制面之间的差别。原文是Service mesh data plane vs. control plane</summary>
</entry>
<entry>
<title>ARTS Week Twelve ProGit(四)</title>
<link href="http://localhost:4000/ARTS-WeekTwelve-ProGit(%E5%9B%9B)/" rel="alternate" type="text/html" title="ARTS Week Twelve ProGit(四)" />
<published>2019-06-25T00:00:00+08:00</published>
<updated>2019-06-25T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekTwelve-ProGit(四)</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekTwelve-ProGit(%E5%9B%9B)/">&lt;p&gt;本章介绍Git关于分支的知识，包括基本的分支切换合并。&lt;/p&gt;

&lt;h2 id=&quot;git-branching&quot;&gt;Git Branching&lt;/h2&gt;
&lt;h3 id=&quot;branches-in-a-nutshell&quot;&gt;Branches in a Nutshell&lt;/h3&gt;
&lt;p&gt;当你进行&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;时，Git存储了一个包含指向你快照的指针的&lt;em&gt;提交&lt;/em&gt;对象。该对象还包含作者的名字，邮箱地址，你输入的信息，以及指向提交(&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;)或是在该提交之前的提交(它的父亲)的指针。对于初始提交来说，没有父亲，对于普通提交来说，只有一个父亲，对于从两个或多个分支合并的提交来说，则有多个父亲。&lt;/p&gt;

&lt;p&gt;假设你有三个文件放在一个目录中，你暂存并提交了它们。暂存文件会为每个文件计算一个checksum，在该Git库中保存该版本的文件(Git将它们叫做&lt;em&gt;blobs&lt;/em&gt;),并将checksum赋值给暂存区。&lt;/p&gt;

&lt;p&gt;当你提交(&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;)时，Git对每个子目录(在这个例子中，只有根工程目录)进行checksum并且将它们作为树形对象存放在Git库中。然后Git创建一个&lt;em&gt;commit&lt;/em&gt;对象，该对象有元数据和指向根工程树的指针，所以需要时它可以重新创建快照。&lt;/p&gt;

&lt;p&gt;因此，现在你的Git库中包含了五个对象：三个&lt;em&gt;blob&lt;/em&gt;(每个分别表示三个文件中的一个的内容)，一个&lt;em&gt;tree&lt;/em&gt;包含了目录的内容并且指定了哪个文件名作为哪个&lt;em&gt;blob&lt;/em&gt;保存，以及一个&lt;em&gt;commit&lt;/em&gt;包含了指向该树的指针以及所有的元数据。&lt;/p&gt;

&lt;p&gt;如果你进行了修改并且再次提交，则此次提交会包含指向之前一次提交(&lt;em&gt;commit&lt;/em&gt;的指针。&lt;/p&gt;

&lt;p&gt;在Git中的一个分支(&lt;strong&gt;branch&lt;/strong&gt;)就是指向这些&lt;em&gt;commit&lt;/em&gt;其中之一的指针。默认的分支是master。&lt;/p&gt;

&lt;h4 id=&quot;creating-a-new-branch&quot;&gt;Creating a New Branch&lt;/h4&gt;
&lt;p&gt;创建一个新的分支其实就是创建了一个新的指针供你移动。&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch &amp;lt;branch_name&amp;gt;&lt;/code&gt;即创建了一个新分支，该分支指向当前的&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Git通过一个特殊的&lt;strong&gt;HEAD&lt;/strong&gt;指针知晓当前你在哪个分支上。&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;指针指向某一个&lt;code class=&quot;highlighter-rouge&quot;&gt;branch&lt;/code&gt;指针。默认情况下该指针指向master。注意：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt;只是创建分支，而不会切换到该分支，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt;不会改变&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;指针的指向。&lt;/p&gt;

&lt;h4 id=&quot;switching-branches&quot;&gt;Switching Branches&lt;/h4&gt;
&lt;p&gt;切换分支可用下面的指令：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout &amp;lt;branch_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该指令把&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;指针指向&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;branch_name&amp;gt;&lt;/code&gt;代表的分支指针。&lt;/p&gt;

&lt;p&gt;如果在该情况下进行&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，则原来的&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支指针仍指向原来的位置，而切换到的分支指针和&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;指针则向前移动了。&lt;/p&gt;

&lt;p&gt;如果在此之后，将分支切换回&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout master&lt;/code&gt;)，则&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;指针会指向&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;，并且目录中的文件会切换回&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;指向的快照中的文件。&lt;/p&gt;

&lt;p&gt;接下来，如果你进行了改动并再次&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，则你的工程历史就分叉了。你创建了一个分支，切换到该分支然而完成了一些工作。然后你切换回原分支，又完成了一些工作。接下去你可以在分支间自由切换并在必要时合并这些分支。&lt;/p&gt;

&lt;p&gt;一个Git中的分支其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;的40字节SHA-1校验和，因此分支的创建和销毁都很简单。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout -b &amp;lt;branch_name&amp;gt;&lt;/code&gt;可以创建并切换到该分支。&lt;/p&gt;

&lt;h3 id=&quot;basic-branching-and-merging&quot;&gt;Basic Branching and Merging&lt;/h3&gt;
&lt;h4 id=&quot;basic-branching&quot;&gt;Basic Branching&lt;/h4&gt;
&lt;p&gt;假设你在完成工作，之前已经有几个&lt;code class=&quot;highlighter-rouge&quot;&gt;commits&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支上了。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          master
            |
c0 &amp;lt;- c1 &amp;lt;- c2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你决定在#53号事务上工作。你使用了下面的命令&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout -b iss53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;于是现在情况变成了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          master
            |
c0 &amp;lt;- c1 &amp;lt;- c2
            |
          iss53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;你完成了一些工作，进行了提交。则&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt;分支前进了，如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          master
            |
c0 &amp;lt;- c1 &amp;lt;- c2 &amp;lt;- c3
                  |
                iss53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，假设你接到信息，需要紧急修复一个bug，则此时可以先从&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt;分支切换到&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git checkout master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注意：如果工作目录或者暂存区中有未提交的改变和正在签出的分支冲突，则Git不会让你切换分支。&lt;/p&gt;

&lt;p&gt;然后，需要创造一个&lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt;分支，并且修改bug、提交，则此时如下所示&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;          master hotfix
            |     |
c0 &amp;lt;- c1 &amp;lt;- c2 &amp;lt;- c4
             | &amp;lt;- c3               
                  |
                iss53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下去，你可以切换回&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支，然后进行分支合并。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout master
$ git merge hotfix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里有个&lt;code class=&quot;highlighter-rouge&quot;&gt;fast-forward&lt;/code&gt;模式。在上面的例子中，&lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt;就在&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;之后，因此直接将&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;指针往后移一步则完成了分支合并。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                master
                  ||
                hotfix
                  |
c0 &amp;lt;- c1 &amp;lt;- c2 &amp;lt;- c4
             | &amp;lt;- c3               
                  |
                iss53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，由于&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt;一样都指向同样的&lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;，则可以删除&lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git branch -d hotfix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接着你可以切换回&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt;分支继续工作并提交。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                master
                  |
c0 &amp;lt;- c1 &amp;lt;- c2 &amp;lt;- c4
             | &amp;lt;- c3 &amp;lt;- c5
                        |
                      iss53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：你在&lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt;中完成的工作不会包含在&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt;中。你可以把&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支的内容和当前内容合并，也可以在完成&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt;的工作中将其合并到主分支中。&lt;/p&gt;

&lt;h4 id=&quot;basic-merging&quot;&gt;Basic Merging&lt;/h4&gt;
&lt;p&gt;假设你想把&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt;分支合并到&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;分支，则和之前一样，先&lt;code class=&quot;highlighter-rouge&quot;&gt;checkout&lt;/code&gt;再&lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt;即可&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git checkout master
$ git merge iss53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;和之前的合并不同的是，这是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;recursive&lt;/code&gt;的模式。这是因为当前分支的提交不是正在合并进来的提交的直接祖先。在这样的情况下，Git进行一个简单的三路合并，使用两个分支指针指向的快照以及两者的共同祖先。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;         common master(merge into)
            |     |
c0 &amp;lt;- c1 &amp;lt;- c2 &amp;lt;- c4
             | &amp;lt;- c3 &amp;lt;- c5
                        |
                      iss53(merge in)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Git会创建一个新的快照，并自动创建一个指向它的提交(&lt;em&gt;commit&lt;/em&gt;)。这被称为一个合并提交(&lt;em&gt;merge commit&lt;/em&gt;)，并且有两个父亲(因此是特殊的)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                           master
                             |
c0 &amp;lt;- c1 &amp;lt;- c2 &amp;lt;- c4 &amp;lt;------ c6
             | &amp;lt;- c3 &amp;lt;- c5 &amp;lt;-|
                        |
                      iss53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在你就可以删除&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt;分支了。&lt;/p&gt;

&lt;h4 id=&quot;basic-merge-conflicts&quot;&gt;Basic Merge Conflicts&lt;/h4&gt;
&lt;p&gt;如果你正在合并的两个分支中的相同文件的相同部分并不一样，则Git不会完整干净的合并它们，而是会发生合并冲突。&lt;/p&gt;

&lt;p&gt;Git不会自动创建新的合并提交，而是会暂停过程。可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt;查看在发生合并冲突后哪些文件是&lt;code class=&quot;highlighter-rouge&quot;&gt;unmerged&lt;/code&gt;状态的。&lt;/p&gt;

&lt;p&gt;Git会在文件中发生冲突的地方加上标志。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:index.html
&amp;lt;div id=&quot;footer&quot;&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;
=======
&amp;lt;div id=&quot;footer&quot;&amp;gt;
please contact us at support@github.com
&amp;lt;/div&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; iss53:index.html
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;它的意思是&lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;版本的内容在&lt;code class=&quot;highlighter-rouge&quot;&gt;===&lt;/code&gt;符号的上方和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;符号的下方，&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt;版本的内容在&lt;code class=&quot;highlighter-rouge&quot;&gt;===&lt;/code&gt;的下方而在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;的上方。&lt;/p&gt;

&lt;p&gt;你可以通过自己手动修改冲突，再运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt;将它们标记为&lt;code class=&quot;highlighter-rouge&quot;&gt;merged&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还有一种选择是通过合并工具进行合并。命令是&lt;code class=&quot;highlighter-rouge&quot;&gt;git mergetool&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最后，可以通过运行&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;提交此次合并。默认的消息感觉比较好，也可以自行写消息介绍你合并的过程。&lt;/p&gt;
</content>
<summary>本章介绍Git关于分支的知识，包括基本的分支切换合并。</summary>
</entry>
<entry>
<title>Arts Weektwelve Leetcode670 Maximum Swap</title>
<link href="http://localhost:4000/ARTS-WeekTwelve-Leetcode670-Maximum-Swap/" rel="alternate" type="text/html" title="Arts Weektwelve Leetcode670 Maximum Swap" />
<published>2019-06-25T00:00:00+08:00</published>
<updated>2019-06-25T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekTwelve-Leetcode670-Maximum-Swap</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekTwelve-Leetcode670-Maximum-Swap/">&lt;p&gt;Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 2736  
Output: 7236  
Explanation: Swap the number 2 and the number 7.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Example 2:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 9973  
Output: 9973  
Explanation: No swap.  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;这题的意思是对给定数字，只能交换一次不同位置的数字，则能得到的最大数字是多少。&lt;/p&gt;

&lt;p&gt;我自己的想法比较复杂。对于一个多位数字，显然把较大的数字放在前面更好。为了找到拿来交换的较大的数字的位置，遍历数组，并且找到递增的最大位置，该位置即为可以拿来交换的最大位置。当然，这样的位置可能有多个，则需要从这些位置中找到最大的、最靠后的位置。&lt;/p&gt;

&lt;p&gt;接下去找可拿来交换的最小位置，该位置一定在0到我们找到的第一个递增的最大位置之间，因此在这两个位置之间再找到比我们之前找到的最大位置数字小的位置，则该位置为能交换的小位置。最后，交换这两个位置的数字即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    int maximumSwap(int num) {
        string s = to_string(num);
        vector&amp;lt;int&amp;gt; vi;
        
        for(int i = 0; i &amp;lt; s.size() - 1; ++i) {
            if(s[i] &amp;lt; s[i + 1]) {
                while(s[i] &amp;lt;= s[i + 1] &amp;amp;&amp;amp; i &amp;lt; s.size() - 1) {
                    ++i;
                }
                vi.push_back(i);
            }
        }
        
        if(vi.empty()) {
            return num;
        }
        
        int max_num_index = vi[0];
        char max_num = s[max_num_index];
        for(int i = 0; i &amp;lt; vi.size(); ++i) {
            if(s[vi[i]] &amp;gt;= max_num) {
                max_num = s[vi[i]];
                max_num_index = vi[i];
            }
        }
        
        for(int i = 0; i &amp;lt; vi[0]; ++i) {
            if(max_num &amp;gt; s[i]) {
                char c = s[i];
                s[i] = max_num;
                s[max_num_index] = c;
                break;
            }
        }
        
        return stoi(s);
        
    }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.</summary>
</entry>
<entry>
<title>ARTS Week Eleven Pattern Service Mesh.md</title>
<link href="http://localhost:4000/ARTS-WeekEleven-Pattern-ServiceMesh/" rel="alternate" type="text/html" title="ARTS Week Eleven Pattern Service Mesh.md" />
<published>2019-06-22T00:00:00+08:00</published>
<updated>2019-06-22T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekEleven-Pattern-ServiceMesh</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekEleven-Pattern-ServiceMesh/">&lt;p&gt;原文是&lt;a href=&quot;https://philcalcado.com/2017/08/03/pattern_service_mesh.html&quot;&gt;Pattern: Service Mesh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文的主要思想是，Service Mesh的诞生其实和TCP/IP网络栈的诞生很相似，都遵循下面的过程：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;发现问题 -&amp;gt; 将解决方案纳入代码 -&amp;gt; 抽取共通问题 -&amp;gt; 将解决方案抽出代码放在外部共同具备的区域&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;作者举了TCP/IP中流控的例子来说明这一问题。最开始电脑和电脑之间的通讯没有流控，这时人们发现如果不进行流控，接收消息的机器有可能会收到过量的信息(可能由于该机器在处理其他事务没空接收信息，而另一侧机器不知道这一点一直发送，还有很多情况会导致该现象)。&lt;/p&gt;

&lt;p&gt;为了解决该问题，人们把处理流控的代码和业务代码放在一起。然而很快人们发现，处理流控的代码其实是共通的，所有的机器都需要处理这一点，因此最后，处理流控的代码就被放入网络栈中，而网络栈是所有网络通信的机器必须经过的一层。&lt;/p&gt;

&lt;p&gt;接下来作者引出了分布式架构中的例子。作者举了服务发现和熔断的例子。最开始，为了解决这两个问题，相关代码也被放入业务逻辑中。后来，人们将代码抽取出来，用库的形式调用。然而，用库处理有下面的问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;需要花时间将库和生态中的组件胶合起来&lt;/li&gt;
  &lt;li&gt;库通常是在特定的平台下编写的(例如JVM、某种特定语言等)&lt;/li&gt;
  &lt;li&gt;对库的管理、维护很困难，例如不同版本的库兼容性不同等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，诞生了sidecar模式。sidecar模式其实就是对于每个服务，都有一个代理(称作sidecar)和它共同启动。该sidecar就负责处理一些共通的问题，例如上面的服务发现。服务之间均通过sidecar进行互相通信——当然，它们不知道sidecar的存在。&lt;/p&gt;

&lt;p&gt;对所有的服务都启动sidecar，则所有的服务及其sidecar就构成了Service Mesh。这里引用William Morgan的一段话说明Service Mesh：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A service mesh is a dedicated infrastructure layer for handling service-to-service communication. It’s responsible for the reliable delivery of requests through the complex topology of services that comprise a modern, cloud native application. In practice, the service mesh is typically implemented as an array of lightweight network proxies that are deployed alongside application code, without the application needing to be aware.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Service Mesh中有一个控制面(Control plane)。控制面知道每个代理实例，并能控制代理实例的功能。&lt;/p&gt;
</content>
<summary>原文是Pattern: Service Mesh</summary>
</entry>
<entry>
<title>ARTS WeekEleven ProGit(三)</title>
<link href="http://localhost:4000/ARTS-WeekEleven-ProGit(%E4%B8%89)/" rel="alternate" type="text/html" title="ARTS WeekEleven ProGit(三)" />
<published>2019-06-19T00:00:00+08:00</published>
<updated>2019-06-19T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekEleven-ProGit(三)</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekEleven-ProGit(%E4%B8%89)/">&lt;p&gt;由于之前已经写过了，然而不小心丢失了，因此这里就列一下Git基础中剩余的各个命令及其作用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git commit --amend: 覆盖上一次的`commit`，主要用于微小的改动的提交  
git reset HEAD &amp;lt;file&amp;gt;: 将staged状态的文件改为unstaged
git checkout -- &amp;lt;file&amp;gt;: 将modified状态的文件改为上一次快照中的样子，可能丢失东西！  
git remote: 展示远程库  
git remote -v: 展示远程库及其URL  
git remote add &amp;lt;remote&amp;gt; URL: 添加远程库并指定本地用名字  
git fetch &amp;lt;remote&amp;gt;: 从远程库中获取内容但不合并  
git pull &amp;lt;remote&amp;gt;: 从远程库中获取内容并合并  
git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;: 推送内容到远程库  
git remote show &amp;lt;remote&amp;gt;: 展示远程库的相关内容
git remote rename &amp;lt;oldname&amp;gt; &amp;lt;newname&amp;gt;: 重命名远程库
git remote remove &amp;lt;remote&amp;gt;: 删除远程库
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>由于之前已经写过了，然而不小心丢失了，因此这里就列一下Git基础中剩余的各个命令及其作用。</summary>
</entry>
<entry>
<title>Arts Weekeleven Leetcode915 Disjoint Intervals</title>
<link href="http://localhost:4000/ARTS-WeekEleven-Leetcode915-Disjoint-Intervals/" rel="alternate" type="text/html" title="Arts Weekeleven Leetcode915 Disjoint Intervals" />
<published>2019-06-19T00:00:00+08:00</published>
<updated>2019-06-19T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekEleven-Leetcode915-Disjoint-Intervals</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekEleven-Leetcode915-Disjoint-Intervals/">&lt;p&gt;Given an array A, partition it into two (contiguous) subarrays left and right so that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Every element in left is less than or equal to every element in right.&lt;/li&gt;
  &lt;li&gt;left and right are non-empty.&lt;/li&gt;
  &lt;li&gt;left has the smallest possible size.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;p&gt;Input: [5,0,3,8,6]
Output: 3
Explanation: left = [5,0,3], right = [8,6]&lt;/p&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;p&gt;Input: [1,1,1,0,6,12]
Output: 4
Explanation: left = [1,1,1,0], right = [6,12]&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题的意思是将数组划分成两个区间，左边的每一个元素都小于右边的每一个元素。如此一来，思路就很清晰了——找到数组中每个位置左边最大元素和右边最小元素，使得该位置上左边最大元素小于右边最小元素，同时该位置应当尽量靠近左边。&lt;/p&gt;

&lt;p&gt;为了找到每个位置的左边最大元素和右边最小元素，需遍历数组两次。第一次从左往右，并与当前的最大值做比较，同时记录。第二次从右往左，并与当前的最小值作比较，同时记录。最后根据左边最大、右边最小两个数组上对应位置的大小关系即可确认划分位置。这里要注意的是，存在一些细节问题，但只要仔细思考，这些细节问题很容易解决。&lt;/p&gt;

&lt;p&gt;代码如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Solution {
public:
    int partitionDisjoint(vector&amp;lt;int&amp;gt;&amp;amp; A) {
        vector&amp;lt;int&amp;gt; left_max(A.size()), right_min(A.size());
        
        int current_max = INT_MIN;
        for(int i = 0; i &amp;lt; A.size(); ++i) {
            if(A[i] &amp;gt; current_max) {
                current_max = A[i];
            }
            left_max[i] = current_max;
        }
        
        int current_min = INT_MAX;
        for(int i = A.size() - 1; i &amp;gt;= 0; --i) {
            right_min[i] = current_min;
            if(A[i] &amp;lt; current_min) {
                current_min = A[i];
            }
        }
    
        int res = 0;
        for(int i = 0; i &amp;lt; A.size() - 1; ++i) {
            if(left_max[i] &amp;lt;= right_min[i]) {
                res = i + 1;
                break;
            }
        }
        return res;
    }
    
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>Given an array A, partition it into two (contiguous) subarrays left and right so that:</summary>
</entry>
<entry>
<title>Envoy学习之旅(四)</title>
<link href="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E5%9B%9B)/" rel="alternate" type="text/html" title="Envoy学习之旅(四)" />
<published>2019-06-17T00:00:00+08:00</published>
<updated>2019-06-17T00:00:00+08:00</updated>
<id>http://localhost:4000/envoy学习之旅(四)</id>
<content type="html" xml:base="http://localhost:4000/envoy%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85(%E5%9B%9B)/">&lt;p&gt;本周对envoy的介绍文档仔细的阅读了一遍(还没有读完)。在此将笔记记录如下。&lt;/p&gt;

&lt;h2 id=&quot;what-is-envoy&quot;&gt;What is Envoy&lt;/h2&gt;
&lt;p&gt;Envoy是一个L7的代理以及通讯总线，被用于大规模现代SOA架构。&lt;/p&gt;

&lt;p&gt;Envoy认为:&lt;br /&gt;
&lt;strong&gt;网络对应用应当是透明的。当网络和应用发生了问题，应该可以很简单就定位到问题的源头&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Envoy有下列特性：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Out of process architecture&lt;/strong&gt;：Envoy是一个自包含进程，与应用服务一同启动。这有两大好处：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;与任意应用语言都能工作&lt;/li&gt;
  &lt;li&gt;由于不是库的形式，Envoy可以快速部署和升级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;现代C++11代码&lt;/strong&gt;: 既有速度又有生产力&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;L3/L4过滤架构&lt;/strong&gt;: Envoy在其核心是一个L3/L4的网络代理。可插入的&lt;code class=&quot;highlighter-rouge&quot;&gt;filter chain&lt;/code&gt;机制使过滤器能被写出来用于完成不同的TCP代理任务并插入到主服务器中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP过滤架构&lt;/strong&gt;：Envoy提供一层额外的HTPP过滤层。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP L7 路由&lt;/strong&gt;: 在HTTP模式下，Envoy支持一个路由子系统。该系统能基于路径、内容和运行时值等路由和重定向请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多种支持&lt;/strong&gt;： gRPC,MongDB L7, Dynamo DB L7等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;服务发现和动态配置&lt;/strong&gt;： Envoy可选的提供了动态配置API层。该层允许Envoy动态的更新：后端&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;,后端&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;,HTTP 路由，监听 sockets等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;健康检查&lt;/strong&gt;： 构建Envoy网格的建议方式是将服务发现作为最终一致的过程。Envoy包含一个健康检查子系统，能可选的主动检查上游服务cluster的健康情况。&lt;br /&gt;
&lt;strong&gt;高级负载均衡&lt;/strong&gt;:&lt;/p&gt;

&lt;h2 id=&quot;architecture-overview&quot;&gt;Architecture overview&lt;/h2&gt;
&lt;h3 id=&quot;terminoogy&quot;&gt;Terminoogy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt;: 能进行网络通信的一个实体(移动手机上的应用，服务器等)。一台硬件上可能有多个Host&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Downstream&lt;/strong&gt;: 一个下游host连接到Envoy，发送请求并接收回应&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Upstream&lt;/strong&gt;: 一个上游host从Envoy接收连接和请求并作出回应&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Listener&lt;/strong&gt;: 一个Listener是一个命名了的网络位置(例如端口，Unix域socket等)，该位置可以被下游客户端连接。Envoy会暴露一个或多个listener供下游host连接&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cluster&lt;/strong&gt;: 一个cluster是逻辑上相似的一组上游host，Envoy连接到这些host。Envoy通过服务发现找到cluster中的成员，通过健康检查判断该成员是否健康，通过负载均衡策略路由请求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mesh&lt;/strong&gt;: 一组协调起来提供一致的网络拓扑的host。在本文档中，”Envoy mesh”是指一组分布式系统中组成了消息传递基础的Envoy代理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime configuration&lt;/strong&gt;: 带外实时配置系统，与Envoy一同部署&lt;/p&gt;

&lt;h3 id=&quot;thread-model&quot;&gt;Thread model&lt;/h3&gt;
&lt;p&gt;Envoy使用单进程多线程架构。单个&lt;em&gt;master&lt;/em&gt;线程控制偶尔发生的协调任务，一些&lt;em&gt;worker&lt;/em&gt;线程处理监听、过滤和转发任务。一旦一个连接被一个listener接受，该连接的剩余生命就和该worker线程绑定了。这使得Envoy大部分是单线程的(&lt;code class=&quot;highlighter-rouge&quot;&gt;embarrassingly parallel&lt;/code&gt;),一小部分更复杂的代码处理worker线程之间的协调。通常Envoy是完全非阻塞的，大部分情况下建议工作线程的数量和硬件线程的数量一致。&lt;/p&gt;

&lt;h3 id=&quot;listeners&quot;&gt;Listeners&lt;/h3&gt;
&lt;p&gt;Envoy配置支持在一个进程中设置任意数量的listener。通常我们建议不管设置的listener有多少，每个机器都设置一个Envoy。&lt;/p&gt;

&lt;p&gt;每个listener都通过一些网络层(L3/L4)过滤器独立的配置。当listener接收到了一个新的连接，配置好的本地连接过滤器堆栈将会被实例化并开始处理一系列的事件。&lt;/p&gt;

&lt;p&gt;Listener也可以配置一些listener过滤器。该过滤器在网络层过滤器之前被使用，可以操纵连接的元数据。通常这是为了影响连接后续怎么被过滤器或者cluster处理。&lt;/p&gt;

&lt;p&gt;Listener也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;listener discovery service&lt;/code&gt;(LDS)动态的获取。&lt;/p&gt;

&lt;h3 id=&quot;listener-filters&quot;&gt;Listener filters&lt;/h3&gt;
&lt;p&gt;Listener filters的主要目的是使得以后增加系统集成函数更简单(通过不改变Envoy的核心功能)。&lt;/p&gt;

&lt;p&gt;Listener filters的API相对简单因为最终是对新接受的sockets进行操作。&lt;/p&gt;

&lt;h3 id=&quot;networkl3l4-filters&quot;&gt;Network(L3/L4) filters&lt;/h3&gt;
&lt;p&gt;网络层过滤器是Envoy连接处理的核心。有三种不同种类的网络过滤器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读：当Envoy从下游连接收到信息时，读过滤器被调用&lt;/li&gt;
  &lt;li&gt;写：当Envoy要发送数据给下游连接时，写过滤器被调用&lt;/li&gt;
  &lt;li&gt;读/写：不管Envoy收到数据还是发送数据，读/写过滤器都会被调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;网络层过滤器的API相对简单，因为最终过滤器对原始字节和一小部分的连接事件(例如TLS握手，连接断开等)进行操作。&lt;/p&gt;

&lt;h3 id=&quot;http-connection-management&quot;&gt;HTTP connection management&lt;/h3&gt;
&lt;p&gt;Envoy有一个内置的网络层过滤器&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;。该过滤器将原始字节转化为HTTP层的信息和事件。它也处理所有HTTP连接和请求共同的功能。&lt;/p&gt;

&lt;h4 id=&quot;http-protocols&quot;&gt;HTTP protocols&lt;/h4&gt;
&lt;p&gt;Envoy的&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;原生支持HTTP/1.1,WebSockets和HTTP/2。Envoy设计为最先支持HTTP/2复用代理。HTTP/2的术语被用来描述系统组件。例如，HTTP请求和响应在流上发生。一个&lt;code class=&quot;highlighter-rouge&quot;&gt;codec&lt;/code&gt;API被使用来转化协议。以HTTP/1.1为例，&lt;code class=&quot;highlighter-rouge&quot;&gt;codec&lt;/code&gt;将协议的序列/管道能力转化为像HTTP/2一样(对更高层来说)。&lt;/p&gt;

&lt;h4 id=&quot;http-header-sanitizing&quot;&gt;HTTP header sanitizing&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;出于安全考虑提供许多不同的首部净化措施。&lt;/p&gt;

&lt;h4 id=&quot;route-table-configuration&quot;&gt;Route table configuration&lt;/h4&gt;
&lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;过滤器有一个关联的路由表。路由表可以是静态的，也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;RDS&lt;/code&gt;API动态指定。&lt;/p&gt;

&lt;h3 id=&quot;http-filters&quot;&gt;HTTP filters&lt;/h3&gt;
&lt;p&gt;Envoy在&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;内支持HTTP级别的过滤器。过滤器不需要知道底层的物理协议(HTTP/1.1,HTTP/2等)。有三种HTTP级别的过滤器：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Decoder&lt;/strong&gt;: 当manager解码部分请求流(首部、实体等)时，该过滤器被调用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Encoder&lt;/strong&gt;: 当manager编码部分响应流(首部、实体等)时，该过滤器被调用&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Decoer/Encoder&lt;/strong&gt;: 上述两种情况均会调用该过滤器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-routing&quot;&gt;HTTP routing&lt;/h3&gt;
&lt;p&gt;Envoy包含一个HTTP路由过滤器。这对处理边缘流量和构建服务对服务Envoy网格十分有用。Envoy也有配置为前向代理的能力。在前向代理配置中，网格客户端可以通过适当的配置它们的http代理为Envoy来加入。在一个较高的层次上看，路由器接受一个到来的HTTP请求，将它和上游的cluster匹配，获取一个到上游cluster中的host的连接池，然而转发请求。路由过滤器有如下特性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;将域名映射到一系列路由规则集合的虚拟主机&lt;/li&gt;
  &lt;li&gt;前缀和完整的路径匹配规则&lt;/li&gt;
  &lt;li&gt;虚拟主机层次的TLS重定向&lt;/li&gt;
  &lt;li&gt;路由层次的路径/主机重定向&lt;/li&gt;
  &lt;li&gt;路由层次的直接(非代理的)HTTP响应&lt;/li&gt;
  &lt;li&gt;显式主机重写&lt;/li&gt;
  &lt;li&gt;前缀重写&lt;/li&gt;
  &lt;li&gt;通过HTTP首部或者路由配置的请求重试&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;route-table&quot;&gt;Route table&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP connection manager&lt;/code&gt;的配置中有被所有配置好的HTTP过滤器使用的路由表。虽然路由过滤器是路由表的主要使用者，其他过滤器也能访问该路由表&lt;/p&gt;

&lt;h3 id=&quot;upstream-clusters&quot;&gt;Upstream clusters&lt;/h3&gt;
&lt;h4 id=&quot;cluster-manager&quot;&gt;Cluster manager&lt;/h4&gt;
&lt;p&gt;Envoy的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster manager&lt;/code&gt;管理所有的上游&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;的数量是任意的。&lt;/p&gt;

&lt;p&gt;上游的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;从网络/HTTP过滤器栈中抽象出来。&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster manager&lt;/code&gt;给过滤器栈暴露API以允许过滤器获取到一个上游&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;的L3/L4连接，或是到上游&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;的抽象HTTP连接池的句柄。过滤器决定是否需要L3/L4连接或是新的HTTP流，&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster manager&lt;/code&gt;则管理负载均衡、线程本地存储、上游连接类型、知道哪些&lt;code class=&quot;highlighter-rouge&quot;&gt;hosts&lt;/code&gt;是可用并且健康的这些功能。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster manager&lt;/code&gt;知道的&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;可通过静态配置或是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster discovery service&lt;/code&gt;(CDS) API动态配置。&lt;/p&gt;

&lt;h5 id=&quot;cluster-warming&quot;&gt;Cluster warming&lt;/h5&gt;
&lt;p&gt;当cluster通过服务器引导或是CDS初始化时，它们被”预热”了。这意味着&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;不可用直到下面的操作发生：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;初始化服务发现负载(DNS解析，EDS更新等)&lt;/li&gt;
  &lt;li&gt;初始主动健康检查通过(如果主动健康检查被配置)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前面的举措确保了Envoy在用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;进行服务时对该&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;有准确的映像。&lt;/p&gt;

&lt;p&gt;当谈论&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster warming&lt;/code&gt;时，&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;变得可用意味着：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于新加入的&lt;code class=&quot;highlighter-rouge&quot;&gt;clusters&lt;/code&gt;，在它被预热之前对于Envoy看上去是不存在的，如果HTTP路由到该&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;则会引发404或503&lt;/li&gt;
  &lt;li&gt;对于更新&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;，老的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;会继续存在并提供服务。当新的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;被预热了，它会原子的和老的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;互换这样就不会发生流量中断的情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;service-discovery&quot;&gt;Service discovery&lt;/h3&gt;
&lt;p&gt;当上游的&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;在配置中定义了，Envoy需要知道如何解析&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中的成员。这被称为服务发现。&lt;/p&gt;
&lt;h4 id=&quot;supported-service-discovery-types&quot;&gt;Supported service discovery types&lt;/h4&gt;
&lt;h5 id=&quot;static&quot;&gt;Static&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Static&lt;/code&gt;是最简单的服务发现种类。配置中显式的指定每个上游&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;的被解析的网络名字(IP地址/端口，unix域socket等)&lt;/p&gt;

&lt;h5 id=&quot;strict-dns&quot;&gt;Strict DNS&lt;/h5&gt;
&lt;p&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;strict DNS&lt;/code&gt;服务发现时，Envoy会持续异步的解析指定的DNS目标。每个返回的IP地址将被认为是上游&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中的一个显式&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;。这意味着如果查询返回了三个IP地址，Envoy会认为&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中有三个&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;，并且都可以被负载均衡到。&lt;/p&gt;

&lt;h5 id=&quot;logical-dns&quot;&gt;Logical DNS&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Logical DNS&lt;/code&gt;使用和&lt;code class=&quot;highlighter-rouge&quot;&gt;strict DNS&lt;/code&gt;相似的解析策略。然而，当一个新的连接需要被初始化时，一个&lt;code class=&quot;highlighter-rouge&quot;&gt;logical DNS cluster'&lt;/code&gt;只使用返回结果中的第一个IP地址。因此，一个逻辑连接池可能包含对不同上游&lt;code class=&quot;highlighter-rouge&quot;&gt;hosts&lt;/code&gt;的许多物理连接。&lt;/p&gt;

&lt;h5 id=&quot;endpoint-discovery-serviceeds&quot;&gt;Endpoint discovery service(EDS)&lt;/h5&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Cluster&lt;/code&gt;成员在Envoy术语中叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;endpoint&lt;/code&gt;。Envoy通过发现服务从每个&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;中获取&lt;code class=&quot;highlighter-rouge&quot;&gt;endpoints&lt;/code&gt;。EDS由于下面的原因是推荐的服务发现机制：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Envoy有显式的每个上游&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;的知识(和通过DNS解析负载均衡器相比)并能作出更智能的负载均衡决策&lt;/li&gt;
  &lt;li&gt;在每个&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;discovery API&lt;/code&gt;响应中携带的额外属性能告知Envoy&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;的负载均衡比，状态等。这些额外的属性可被Envoy网格使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;on-eventually-consistent-service-discovery&quot;&gt;On eventually consistent service discovery&lt;/h4&gt;
&lt;p&gt;Envoy从最开始的设计目标就是服务发现不需要全一致性，而是假设进出的&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;是最终一致的。我们建议在部署服务对服务的Envoy网格配置时，使用最终一致的服务发现(伴随主动健康检查)来决定&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;是否健康。这一范式有下列好处：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;所有的健康决策被完全分布了。因此，网络分区问题被优雅的解决了&lt;/li&gt;
  &lt;li&gt;当健康检查被一个上游&lt;code class=&quot;highlighter-rouge&quot;&gt;cluster&lt;/code&gt;配置，Envoy使用一个2×2矩阵来决定是否路由到该&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;strong&gt;Discovery Status&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Health Check OK&lt;/strong&gt;&lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;Healtch Check Failed&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Discovered&lt;/td&gt;
      &lt;td&gt;Route&lt;/td&gt;
      &lt;td&gt;Don’t Route&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Absent&lt;/td&gt;
      &lt;td&gt;Route&lt;/td&gt;
      &lt;td&gt;Don’t Route/Delete&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</content>
<summary>本周对envoy的介绍文档仔细的阅读了一遍(还没有读完)。在此将笔记记录如下。</summary>
</entry>
</feed>
