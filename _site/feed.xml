<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="http://jekyllrb.com" version="3.7.4">Jekyll</generator>
<link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" />
<link href="http://localhost:4000/" rel="alternate" type="text/html" />
<updated>2019-05-03T16:44:05+08:00</updated>
<id>http://localhost:4000/</id>
<title>Tonfeiz</title>
<subtitle></subtitle>
<author>
<name>Tonfeiz</name>
</author>
<entry>
<title>计算机技术历史 语言(一)</title>
<link href="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%80)/" rel="alternate" type="text/html" title="计算机技术历史 语言(一)" />
<published>2019-05-03T00:00:00+08:00</published>
<updated>2019-05-03T00:00:00+08:00</updated>
<id>http://localhost:4000/计算机技术历史-语言(一)</id>
<content type="html" xml:base="http://localhost:4000/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%8E%86%E5%8F%B2-%E8%AF%AD%E8%A8%80(%E4%B8%80)/">&lt;p&gt;前段时间想去了解一下计算机技术的发展历史，但是搜了一下没有发现很系统的讲述这方面内容的书或者博客，因此就想自己来调查了解一下，也挺有意思的。&lt;/p&gt;

&lt;p&gt;为什么要关注计算机技术的历史呢？除了兴趣之外，还有一个重要原因是想从历史获取计算机技术发展的主脉络。现在计算机技术发展日新月异，新技术曾出不穷，但不是所有的技术都能留下来，也有些技术是不必要学。想要判断这些东西，就必须得到以往的技术有所了解，找出其中的规律。&lt;/p&gt;

&lt;p&gt;由于计算机技术实在太多了，因此不可能全部涉及。此外，硬件方面的技术门槛较高，我可能也看不懂。基于此，主要还是关注软件技术。&lt;/p&gt;

&lt;p&gt;首先，先从编程语言开始。&lt;/p&gt;

&lt;h2 id=&quot;机器语言&quot;&gt;机器语言&lt;/h2&gt;
&lt;p&gt;机器语言是最早的编程语言，也可以叫做机器码。大约在第一台计算机诞生时，即20世纪50年代左右，机器语言是主要编程语言。&lt;/p&gt;

&lt;p&gt;我们普通人也常常听到计算机其实就是一连串0和1这样的话，0和1其实就是机器语言。计算机接收这些0和1，将0和1组成的串变成硬件上的高低电平，再由高低电平控制机器完成实际动作。由0和1组成的串的集合又叫做指令集，每个计算机厂家的硬件不同，其指令集也不同。&lt;/p&gt;

&lt;p&gt;机器语言的优点就是快，缺点就是不是写给人看的。写机器语言的人必须对于硬件厂家给出的指令集有深厚的了解，才能较好的驾驭机器语言。可是不同的厂家，甚至相同厂家下面的不同型号计算机，只要硬件架构有了一定改动，机器语言也可能随之发生变化，这就造成了其可移植性和重用性都很差的后果。&lt;/p&gt;

&lt;p&gt;如今，已经没有人再用机器语言进行实际编程了。&lt;/p&gt;

&lt;h2 id=&quot;汇编语言&quot;&gt;汇编语言&lt;/h2&gt;
&lt;p&gt;汇编语言在机器语言之后出现，但也是在20世界50年代。汇编语言直到今天还在被使用，主要被用于一些对速度要求高的场合，例如嵌入式系统、驱动程序等。&lt;/p&gt;

&lt;p&gt;汇编语言的出现主要是为了解决机器语言看不懂的缺点。机器语言的一连串0和1简直就是天书，而汇编语言已经开始有自己的语法。汇编语言的使用者对于计算机的体系结构，各个寄存器的作用，程序计数器等要有基本的了解。由于引入了语法，汇编语言需要经过编译器转化为机器语言再交由计算机执行。从这里就可以看出，计算机中引入中间层的观点是很早就有了的。此外，汇编语言的诞生也表明了程序是写给程序员看的，而不是写给机器看的。&lt;/p&gt;

&lt;p&gt;汇编语言的优点是目标代码简短，占用内存少，执行速度快，且比起机器语言来便于记忆。但汇编语言没有解决机器语言无法移植的特点。在不同的机器之间，汇编语言的语法也不相同。另一方面，由于汇编语言直接对寄存器等进行操作，程序的真实意图也被掩盖在细节之中，并且常常需要大量的代码完成简单的工作。最后，汇编语言也很容易产生bug并且难于调试。&lt;/p&gt;
</content>
<summary>前段时间想去了解一下计算机技术的发展历史，但是搜了一下没有发现很系统的讲述这方面内容的书或者博客，因此就想自己来调查了解一下，也挺有意思的。</summary>
</entry>
<entry>
<title>Arts Weekfour Vim插件管理 Vundle</title>
<link href="http://localhost:4000/ARTS-WeekFour-vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-Vundle/" rel="alternate" type="text/html" title="Arts Weekfour Vim插件管理 Vundle" />
<published>2019-05-01T00:00:00+08:00</published>
<updated>2019-05-01T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekFour-vim插件管理-Vundle</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekFour-vim%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86-Vundle/">&lt;p&gt;vim有非常之多的插件，因此需要一个插件管理器来管理这些插件。而Vundle就是这一利器。&lt;/p&gt;

&lt;p&gt;Vundle是vim bundle的缩写。它能自动跟踪&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中的插件，安装、更新、卸载插件。Vundle自动管理插件的运行时目录并会在安装和更新后自动重新生成帮助tag。&lt;/p&gt;

&lt;h2 id=&quot;vundle的安装设置&quot;&gt;Vundle的安装设置&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;首先输入&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone https://github.com/VundleVim/Vundle.vim.git ~/vim/bundle/Vundle.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;将下列内容保存到~/.vimrc中&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set nocompatible              &quot; be iMproved, required
filetype off                  &quot; required

&quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&quot; alternatively, pass a path where Vundle should install plugins
&quot;call vundle#begin('~/some/path/here')

&quot; let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'

&quot; The following are examples of different formats supported.
&quot; Keep Plugin commands between vundle#begin/end.
&quot; plugin on GitHub repo
Plugin 'tpope/vim-fugitive'
&quot; plugin from http://vim-scripts.org/vim/scripts.html
Plugin 'L9'
&quot; Git plugin not hosted on GitHub
Plugin 'git://git.wincent.com/command-t.git'
&quot; git repos on your local machine (i.e. when working on your own plugin)
Plugin 'file:///home/gmarik/path/to/plugin'
&quot; The sparkup vim script is in a subdirectory of this repo called vim.
&quot; Pass the path to set the runtimepath properly.
Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
&quot; Avoid a name conflict with L9
Plugin 'user/L9', {'name': 'newL9'}

&quot; All of your Plugins must be added before the following line
call vundle#end()            &quot; required
filetype plugin indent on    &quot; required
&quot; To ignore plugin indent changes, instead use:
&quot;filetype plugin on
&quot;
&quot; Brief help
&quot; :PluginList          - list configured plugins
&quot; :PluginInstall(!)    - install (update) plugins
&quot; :PluginSearch(!) foo - search (or refresh cache first) for foo
&quot; :PluginClean(!)      - confirm (or auto-approve) removal of unused plugins
&quot;
&quot; see :h vundle for more details or wiki for FAQ
&quot; Put your non-Plugin stuff after this line
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.安装配置好的bundle:打开vim并输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginInstall&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;插件&quot;&gt;插件&lt;/h2&gt;
&lt;h3 id=&quot;配置插件&quot;&gt;配置插件&lt;/h3&gt;
&lt;p&gt;Vundle跟踪&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令。每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令让Vundle使能脚本并将其加入|runtimepath|中。&lt;/p&gt;

&lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;命令有一个指向脚本的URI。在URI后面可选择接受第二个参数。这个参数必须是一个目录。每个键值对都是一个配置选项。&lt;/p&gt;

&lt;p&gt;下面是一些配置选项&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;‘rtp’:设置repo中的一个目录为vim插件所在目录。该目录将被加入|runtimepath|中&lt;/li&gt;
  &lt;li&gt;‘name’:将放置配置脚本的本地拷贝的目录名字&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;支持的uri&quot;&gt;支持的URI&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Github:当user/repo被传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin&lt;/code&gt;时Github被使用,例如&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'VundleVim/Vundle.vim' =&amp;gt; https://github.com/VundleVim/Vundle.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Vim Scripts:没有’/’的单词都被认为从Vim Scripts中获取&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'ctrlp.vim' =&amp;gt; https://github.com/vim-scripts/ctrlp.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;本地插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Plugin 'file:///path/from/root/to/plugin'&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;基本使用方式&quot;&gt;基本使用方式&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginInstall&lt;/code&gt; 安装&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;中配置的所有插件，也可以在后面跟上插件名特定安装&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginUpdate&lt;/code&gt; 更新插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginSearch&lt;/code&gt; 需要有&lt;code class=&quot;highlighter-rouge&quot;&gt;curl&lt;/code&gt;,搜索指定插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginList&lt;/code&gt; 列举已经安装的插件列表&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;:PluginClean&lt;/code&gt; 清除不在&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;而在安装目录下的插件&lt;/p&gt;

</content>
<summary>vim有非常之多的插件，因此需要一个插件管理器来管理这些插件。而Vundle就是这一利器。</summary>
</entry>
<entry>
<title>Arts Weekfour Twelve Factor(四)</title>
<link href="http://localhost:4000/ARTS-WeekFour-Twelve-Factor(%E5%9B%9B)/" rel="alternate" type="text/html" title="Arts Weekfour Twelve Factor(四)" />
<published>2019-04-30T00:00:00+08:00</published>
<updated>2019-04-30T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekFour-Twelve-Factor(四)</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekFour-Twelve-Factor(%E5%9B%9B)/">&lt;p&gt;Dev/prod parity&lt;br /&gt;
Logs&lt;br /&gt;
Admin processes&lt;/p&gt;

&lt;h2 id=&quot;十开发环境生产环境相同&quot;&gt;十、开发环境/生产环境相同&lt;/h2&gt;
&lt;p&gt;保持开发环境、模拟环境和生产环境尽可能相似&lt;/p&gt;

&lt;p&gt;历史上，在开发环境和生产环境之间有三道鸿沟，分别位：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;时间：开发者可能在需要花费几天甚至几个月才运行的代码上工作&lt;/li&gt;
  &lt;li&gt;人事：开发者写代码，运维工程师部署它&lt;/li&gt;
  &lt;li&gt;工具：开发者使用Nginx，SQLite和OSX而实际生产环境可能是Apache，MySQL和Linux&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;twelve-factor app需要使上面三者尽可能小来便于持续部署。&lt;/p&gt;

&lt;p&gt;以后台服务(backing services)为例，很多语言提供库来简化与其的通信，例如使用适配器使其能适配不同的数据库。有时候开发者会倾向于在本地使用轻量级的数据库而在正式部署时使用重量级的数据库。&lt;/p&gt;

&lt;p&gt;twelve-factor app的开发者拒绝在开发环境和生产环境之间使用不同的后台服务。&lt;/p&gt;

&lt;p&gt;对不同后台服务的适配仍然是有用的，例如在改变后台服务时。但app的所有部署(开发环境，模拟环境和生产环境)都应当具有相同版本的后台服务&lt;/p&gt;

&lt;h2 id=&quot;十一日志&quot;&gt;十一、日志&lt;/h2&gt;
&lt;p&gt;将日志当做事件流对待&lt;/p&gt;

&lt;p&gt;日志提供了运行app的行为事件。它是从所有的进程和后台服务中得到的聚合的、按时间顺序排列的流。&lt;/p&gt;

&lt;p&gt;一个twelve factor app从不关心输出流的路由或是存储。它不应当写日志文件或者管理它们。每个运行的进程都只是将事件流写入&lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;在开发环境中，开发者通过终端的流观察app的行为。在模拟或生产环境中，每个进程的流将被执行环境捕捉，并被路由到一个或多个最终目的地来作为长期文件。这些文件对于app是不可见并不可配置的，完全由执行环境来管理。&lt;/p&gt;

&lt;p&gt;app的事件流还可以被送到日志索引和分析系统，例如Splunk，或是一个通用目的的存储系统例如Hadoop/Hive。这些系统能提供更多的功能&lt;/p&gt;

&lt;h2 id=&quot;管理进程&quot;&gt;管理进程&lt;/h2&gt;
&lt;p&gt;将管理进程作为一次性的、不是经常开关的进程&lt;/p&gt;

&lt;p&gt;开发者经常希望有一个一次性的管理进程，例如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;运行数据库迁移&lt;/li&gt;
  &lt;li&gt;运行一个控制台&lt;/li&gt;
  &lt;li&gt;运行上传到app repo中的一次性脚本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一次性的管理进程应当和app的常规长时运行进程运行在同一个环境下，使用相同的代码库和配置，不需要进行同步措施。&lt;/p&gt;

</content>
<summary>Dev/prod parityLogsAdmin processes</summary>
</entry>
<entry>
<title>Arts Weekfour Leetcode703 Kthinstream</title>
<link href="http://localhost:4000/ARTS-WeekFour-Leetcode703-kthInStream/" rel="alternate" type="text/html" title="Arts Weekfour Leetcode703 Kthinstream" />
<published>2019-04-30T00:00:00+08:00</published>
<updated>2019-04-30T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekFour-Leetcode703-kthInStream</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekFour-Leetcode703-kthInStream/">&lt;p&gt;Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;

&lt;p&gt;Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这题其实的意思是在一段流里找第k大的数，也就是说对于连续的流，每次调用函数都能获取当前第k大的数。&lt;/p&gt;

&lt;p&gt;这也是一道很经典的题了，但是最开始想着要保留所有的数，于是就超时了。实际上很容易想到，既然是求第k大的数，那么只需要保留前k个数即可。每新来一个数都将它与前k个数中最小的数比较，如果小于它就丢弃，如果大于它就将它插入合适位置。这里最开始我想的是排序，利用插入排序的方式。可是后来想到显然小顶堆是最合适的数据结构。另外，go语言很久没用了，这里编译错误好几次，还需要复习go语言的用法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type KthLargest struct {
    h *IntHeap
    num int
}

// An IntHeap is a min-heap of ints.
type IntHeap []int

func (h IntHeap) Len() int           { return len(h) }
func (h IntHeap) Less(i, j int) bool { return h[i] &amp;lt; h[j] }
func (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntHeap) Push(x interface{}) {
    // Push and Pop use pointer receivers because they modify the slice's length,
    // not just its contents.
    *h = append(*h, x.(int))
}

func (h *IntHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func Constructor(k int, nums []int) KthLargest {
    h := IntHeap(nums)
    heap.Init(&amp;amp;h)
    return KthLargest{&amp;amp;h, k}
}


func (this *KthLargest) Add(val int) int {
    heap.Push(this.h, val)
    for len(*(this.h)) &amp;gt; this.num {
        heap.Pop(this.h)
    } 
    res := (*this.h)[0]
    return res
}


/**
 * Your KthLargest object will be instantiated and called as such:
 * obj := Constructor(k, nums);
 * param_1 := obj.Add(val);
 */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</summary>
</entry>
<entry>
<title>技术学习之路</title>
<link href="http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" rel="alternate" type="text/html" title="技术学习之路" />
<published>2019-04-26T00:00:00+08:00</published>
<updated>2019-04-26T00:00:00+08:00</updated>
<id>http://localhost:4000/技术学习之路</id>
<content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">&lt;p&gt;这篇文章想讲讲对于学计算机技术应该怎么学，我自己的思考与观点。&lt;/p&gt;

&lt;p&gt;说起来，Share好像变成了一个分享自己观点的东西。本意上Share应该是分享技术相关内容的。这样可能有点违规，但我觉得，分享自己的观点也不差，甚至非技术的内容也可以，因为这样促使人真正的去整理观点，审视自己，而人生除了技术之外还有很多东西能从这么做获益。&lt;/p&gt;

&lt;p&gt;说回正题，计算机技术学习之路是一个很广泛的概念。目前计算机衍生出了这么多分支，肯定不可能每条都一样，因此这篇文章讲的是很宽泛的内容。此外，我是纯自学学的计算机，我想目前社会上像我这样的人不在少数，我的观点可能多多少少有点启发意义。&lt;/p&gt;

&lt;h2 id=&quot;深度和广度&quot;&gt;深度和广度&lt;/h2&gt;
&lt;p&gt;深度和广度是计算机技术中常常被人们谈及的领域，究竟是深度更重要还是广度更重要也常常被讨论。实际上，深度往往伴随着广度，深度到了一定地步，伴随着而来的就是涉及到的知识面更广。而广度——广度并不一定有深度，你可以从计算机工程到计算机理论各个领域全部涉及一遍。&lt;/p&gt;

&lt;p&gt;然而，对于初学者而言，我认为还是广度更重要。求深度是一件好事，尤其现在社会分工日益精细了。但我认为，先求广度可以让初学者对计算机技术涉及的各个领域有一个基本的概念。在这之后寻求深度，往往花费时间更少。举例来说，我个人最喜欢的读书方式就是先快速读一遍，再精读一遍，最后再快速读一遍。第一遍是对书的主题、叙述方式有一个大概的了解，并且判断是否有必要再读第二遍。第二遍则是把第一遍留下的问题或者感兴趣的地方重点去看。第三编则类似于快速复习，查漏补缺。我喜欢的技术学习路线也和读书很像，先广后深再广，最后的广度就是复习自己学到的东西并看是否还有不会的。&lt;/p&gt;

&lt;p&gt;另外，广度还有一个好处是能把知识点连起来。很多时候涉及的多了就会发现不同的问题都能有相同的方法解决，比如随处可见的缓存，算法里的分治等。对于这些东西有个初步的概念后，日后的学习就能知道重点——一般出现的越多说明它越重要，就能事半功倍。最重要的是，这些方法体现了计算机整个学科的精髓，而跨学科思考的思想也是很重要的。这些思想往往不局限于计算机，而是能解决各种问题。&lt;/p&gt;

&lt;h2 id=&quot;内功招式和武器&quot;&gt;内功、招式和武器&lt;/h2&gt;
&lt;p&gt;在提到计算机技术的基础时，有一个很常见的比喻，就是内功、招式和武器。内功就是基础，招式就是技术方法，武器就是工具。人们往往会强调基础的重要性，说如果没有内功，空有招式，打到敌人也不疼。如果没有招式，空有内功，至少浑厚的内功还能给你减伤。至于武器，则有锦上添花之效。&lt;/p&gt;

&lt;p&gt;对于上面的比喻，我想说，说的太有道理了。基础的重要性是怎么强调也不为过的。随着时间的流逝，基础好的人其个人能力是先慢后块，而基础差的人则是先快后慢，最后还是得回来补。&lt;/p&gt;

&lt;p&gt;但是对于基础怎么学，我有点想法。很多人一上来推荐书，推荐看视频。从编程语言到操作系统，各种基础类的资源推荐了个遍。然而这些东西学完恐怕要花个几年，而且又很枯燥，往往无法解决一些实际的问题。还是用上面那个比喻，学内功是很辛苦的，而且进度缓慢。而学招式还是挺好玩的，至少能摆个花架子唬人。&lt;/p&gt;

&lt;p&gt;我认为，可以先学招式无妨。在学招式的过程中伴随着内功的修炼，或者学完招式之后再学内功，也是可以的。举例来说，在学习网络的时候，可以先学着实现一个简单的qq。在实现的过程中，有些细枝末节可以仅仅了解，而涉及到网络的部分则重点学习，并且尝试不同的方法。在实现过程中遇到的问题可以知其然而不知其所以然，但要记录在案。在实现了这个项目后，翻看《TCP/IP详解卷一》，往往看到某个知识点会和之前的问题对上。在这样的情况下，记忆更深刻，也更有效。&lt;/p&gt;

&lt;h2 id=&quot;学习总结&quot;&gt;学习总结&lt;/h2&gt;
&lt;p&gt;我这里稍微更具体的总结一下学习的方法。&lt;/p&gt;

&lt;p&gt;对于任意一门科目，首先选取一种输入(视频、书甚至百度百科)，大概了解即可，不需要精通。这里所说的了解，是指知道它是什么，有什么用，怎么用。例如编程语言，知道类型是什么意思，怎么定义类型，函数是什么，几种循环结构即可。接下来去找一个实际的问题，去解决它。还是以C语言为例，你可以考虑怎么用C语言画画，用C语言写游戏等等。在解决的过程中你会发现各种问题，比如内存错误，编译错误等等。记下这些错误，并去搜解决它们的方法，但不一定要知道为什么这样可以解决它。最后，挑一本经典书籍或是其他类型的经典输入，仔细的读，并和问题对照。&lt;/p&gt;

&lt;p&gt;想要学的好，就得记住，学习是伴随着枯燥的。刻意练习的核心就是踏出舒适区。如果你感觉到学习过程很轻松，那说明你还没有尽全力，或者还在换一种形式啃自己已经了解的东西。警惕心流，处于心流状态时，有可能也是处于钻牛角尖的状态。&lt;/p&gt;

&lt;p&gt;最后，不要逼自己。实在学不下去的时候，let it go&lt;/p&gt;
</content>
<summary>这篇文章想讲讲对于学计算机技术应该怎么学，我自己的思考与观点。</summary>
</entry>
<entry>
<title>Arts Weekthree Vim配置</title>
<link href="http://localhost:4000/ARTS-WeekThree-vim%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="Arts Weekthree Vim配置" />
<published>2019-04-24T00:00:00+08:00</published>
<updated>2019-04-24T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekThree-vim配置</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekThree-vim%E9%85%8D%E7%BD%AE/">&lt;p&gt;vim中的配置是十分重要的内容，不同的用户可以根据自己的喜好将vim配置成自己喜爱的样式。本次就根据vim的帮助文档介绍以下vim配置方面的内容。&lt;/p&gt;

&lt;h2 id=&quot;vimrc文件&quot;&gt;vimrc文件&lt;/h2&gt;
&lt;p&gt;vimrc文件中包含了vim在启动时就会执行的命令。对于我们最喜欢的选项和按键映射，可以放到vimrc中&lt;/p&gt;

&lt;p&gt;vimrc文件的名字叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;，对于Unix操作系统和Macintosh操作系统来说，它的路径名一般是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vimrc&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;vimrc文件中可以包含所有能在vim中普通模式下”:”后面执行的命令，最简单的设置选项的指令，其一般格式是&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set &amp;lt;options&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;想要查看有哪些配置可以输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:options&lt;/code&gt;查看或是在帮助中查看。&lt;/p&gt;

&lt;p&gt;对于特定的配置，可以输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:help '&amp;lt;option name&amp;gt;'&lt;/code&gt;查看。另外，在设置某个选项时在后面加&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;即可恢复默认设置&lt;/p&gt;

&lt;p&gt;为了使vimrc文件起作用需要退出vim再重新启动&lt;/p&gt;

&lt;p&gt;下面列举一些设置作为例子说明&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set autoindent&lt;/code&gt;:自动缩进，使用前一行的缩进作为当前行缩进&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if has(&quot;vms&quot;)
  set nobackup
else
  set backup
endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使得vim在覆写一个文件时保存有该文件的备份，而在VMS系统上则不用，因为VMS系统自带有这个功能。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set history=50&lt;/code&gt;:在历史记录中保持50个命令和50种搜索模式&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set ruler&lt;/code&gt;:允许在右下角显示当前游标的位置&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set showcmd&lt;/code&gt;:显示普通模式下输入的命令&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set incsearch&lt;/code&gt;:在输入搜索模式下显示和其匹配的内容&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;map Q gq&lt;/code&gt;:这是一个按键映射，将&lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt;键映射到&lt;code class=&quot;highlighter-rouge&quot;&gt;gq&lt;/code&gt;按键上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;filetype plugin indent on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;文件类型检测：当开始编辑一个文件时，vim将会通过文件扩展名试图发现文件的类型。文件类型可被用于语法高亮等用途&lt;/li&gt;
  &lt;li&gt;使用文件类型插件文件(filetype plugin files):不同的文件类型有不同的设置。这些公共的有用选项在vim的文件类型插件中&lt;/li&gt;
  &lt;li&gt;使用缩进文件：不同类型的文件种类使用不同的缩进&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;简单的映射&quot;&gt;简单的映射&lt;/h2&gt;
&lt;p&gt;按键映射应该是所有编辑器必备的功能了。在vim中很简单，举例来说，在vimrc文件中添加&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:map &amp;lt;F5&amp;gt; i{&amp;lt;Esc&amp;gt;ea}&amp;lt;Esc&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的这个映射解析为&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&amp;lt;F5&amp;gt; 映射按键是F5键&lt;/li&gt;
  &lt;li&gt;i{ 转换为插入模式并输入{&lt;/li&gt;
  &lt;li&gt;&amp;lt;Esc&amp;gt; 退出为普通模式&lt;/li&gt;
  &lt;li&gt;ea}到单词结尾并输入}&lt;/li&gt;
  &lt;li&gt;&amp;lt;Esc&amp;gt;最后转化为普通模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，一般情况下输入一个单词，按F5键即可在其两端加上大括号&lt;/p&gt;

&lt;h2 id=&quot;添加插件&quot;&gt;添加插件&lt;/h2&gt;
&lt;p&gt;vim可通过添加插件来扩展自己的功能。插件其实就是vim在启动时自动加载的vim脚本文件。在&lt;code class=&quot;highlighter-rouge&quot;&gt;plugin&lt;/code&gt;文件夹中添加对应文件就可添加插件&lt;/p&gt;

&lt;p&gt;有两种插件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;全局插件：对所有文件都有效&lt;/li&gt;
  &lt;li&gt;文件类型插件：对特定文件类型才有效&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;全局插件&quot;&gt;全局插件&lt;/h3&gt;
&lt;p&gt;全局插件在启动时自动加载，它们提供了大部分通用的功能。&lt;/p&gt;

&lt;p&gt;添加全局插件只需要两步，获取全局插件，放入对应文件夹&lt;/p&gt;

&lt;p&gt;获取全局插件有许多地方，这里不再详述。若想要使用对应插件，则首先阅读该插件的说明文档看是否有需要注意的地方，然后将文件复制到插件文件夹下。对于Unix来说，位置一般是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vim/plugin&lt;/code&gt;。值得注意的是，不一定要直接放入&lt;code class=&quot;highlighter-rouge&quot;&gt;plugin&lt;/code&gt;目录下，也可以在其中创建子目录并放入其中&lt;/p&gt;

&lt;h3 id=&quot;文件类型插件&quot;&gt;文件类型插件&lt;/h3&gt;
&lt;p&gt;在使用文件类型插件时，需要使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;:filetype plugin on&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加文件类型插件需要将它放入特定的文件夹，在Unix环境下就是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vim/ftplugin&lt;/code&gt;.对于文件类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;filetype&lt;/code&gt;的插件，该插件名字可以为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;_&amp;lt;name&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;/&amp;lt;name&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;name&amp;gt;可以是任意的&lt;/p&gt;
</content>
<summary>vim中的配置是十分重要的内容，不同的用户可以根据自己的喜好将vim配置成自己喜爱的样式。本次就根据vim的帮助文档介绍以下vim配置方面的内容。</summary>
</entry>
<entry>
<title>Arts Weekthree Twelve Factor(三)</title>
<link href="http://localhost:4000/ARTS-WeekThree-Twelve-Factor(%E4%B8%89)/" rel="alternate" type="text/html" title="Arts Weekthree Twelve Factor(三)" />
<published>2019-04-23T00:00:00+08:00</published>
<updated>2019-04-23T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekThree-Twelve-Factor(三)</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekThree-Twelve-Factor(%E4%B8%89)/">&lt;p&gt;Twelve Factor Part Three&lt;br /&gt;
Port binding&lt;br /&gt;
Concurrency&lt;br /&gt;
Disposability&lt;/p&gt;

&lt;h2 id=&quot;七端口号绑定&quot;&gt;七、端口号绑定&lt;/h2&gt;
&lt;p&gt;通过绑定端口号导出服务&lt;/p&gt;

&lt;p&gt;应用程序应当是自包含(self-contained)的，并且它不应当依赖运行时服务器的注入。web app通过将HTTP绑定到一个端口号上来将其导出作为服务。&lt;/p&gt;

&lt;p&gt;在本地的开发环境，开发者通过像&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:5000/&lt;/code&gt;这样的URL访问自己开发的服务。在部署环境中，则通过公共域名和端口访问。&lt;/p&gt;

&lt;p&gt;通常这通过使用依赖声明将一个web服务器库添加到app中完成，例如Python的Tornado，Java的Jetty。&lt;/p&gt;

&lt;p&gt;注意绑定端口的服务意味着它也可以成为其他app的&lt;code class=&quot;highlighter-rouge&quot;&gt;backing service&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;八并发&quot;&gt;八、并发&lt;/h2&gt;
&lt;p&gt;通过进程模型达成横向扩展&lt;/p&gt;

&lt;p&gt;任何计算机程序都表示为一个或多个计算机程序。Web应用使用了许多不同类型的进程执行形式，例如PHP进程作为Apache的子进程存在，Java由JVM提供一个维护大块系统资源的进程，而并发就由线程内在的管理。不管哪种形式，运行着的进程对于app的开发者来说都只具有最小的可见性。&lt;/p&gt;

&lt;p&gt;在twelve-factor app中，进程是一等公民。twelve-factor中的进程从运行守护服务的UNIX进程模型获得强烈的启发。在这种模型下，开发者可通过将每种类型的工作分发一个进程类型来架构自己的app以使它们能处理形色各异的工作负载。&lt;/p&gt;

&lt;p&gt;twelve-factor app无共享、水平可分的特性意味着增强并发是一个简单可信任的操作。进程类型和每种类型的进程数量组成的矩阵则是进程信息。&lt;/p&gt;

&lt;p&gt;twelve-factor app不能被配置为守护进程也不能写PID文件，而应当依赖操作系统的进程管理器来管理输出流，对崩溃进程作出反应或是处理用户的重启和关闭&lt;/p&gt;

&lt;h2 id=&quot;九可弃性disposability&quot;&gt;九、可弃性(Disposability)&lt;/h2&gt;
&lt;p&gt;通过快速启动和优雅的关闭来最大化鲁棒性&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;disposability&lt;/code&gt;意味着app可以被一瞬间开启或关闭。这对于伸缩性、代码或配置改变时的快速部署以及生产环境部署的鲁棒性都很重要。&lt;/p&gt;

&lt;p&gt;进程应当尽量最小化启动时间，最好只需几秒钟。短暂的启动时间意味着更灵活，更鲁棒(进程管理器可以更快的把进程移动到新的物理机上)&lt;/p&gt;

&lt;p&gt;当进程从进程管理器处收到&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTERM&lt;/code&gt;信号时应当优雅的关闭。对于web进程来说，这意味着停止监听端口，让当前的请求结束然后退出。&lt;/p&gt;

&lt;p&gt;对于工作进程来说，这意味着把当前的工作返回到工作队列中。&lt;/p&gt;

&lt;p&gt;进程应当对由底层硬件导致的突然死亡也鲁棒。一个建议的方法是使用鲁棒的后端队列，例如Beanstalked&lt;/p&gt;
</content>
<summary>Twelve Factor Part ThreePort bindingConcurrencyDisposability</summary>
</entry>
<entry>
<title>Arts Weekthree Leetcode1022 Sumroottoleaf</title>
<link href="http://localhost:4000/ARTS-WeekThree-Leetcode1022-sumRootToLeaf/" rel="alternate" type="text/html" title="Arts Weekthree Leetcode1022 Sumroottoleaf" />
<published>2019-04-23T00:00:00+08:00</published>
<updated>2019-04-23T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekThree-Leetcode1022-sumRootToLeaf</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekThree-Leetcode1022-sumRootToLeaf/">&lt;p&gt;Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.&lt;/p&gt;

&lt;p&gt;For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.&lt;/p&gt;

&lt;p&gt;Return the sum of these numbers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br /&gt;
    1. The number of nodes in the tree is between 1 and 1000.&lt;br /&gt;
    2. node.val is 0 or 1.&lt;br /&gt;
    3. The answer will not exceed 2^31 - 1.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这道题的意思就是对一棵二叉树，每个结点可能是0或者1,则从根节点到叶节点就构成了一个二进制数。求所有这样的二进制数的和。&lt;/p&gt;

&lt;p&gt;二叉树的题目一般都是涉及到递归的。递归的方法主要就是回溯，因此一开始就往回溯那方面去想了。这题用回溯也可以做，但没那么复杂。&lt;/p&gt;

&lt;p&gt;递归的题目中，我觉得函数代表的意义是很重要的。对这题来说，假设有一个递归函数的输入是一个节点&lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt;和一个数&lt;code class=&quot;highlighter-rouge&quot;&gt;num&lt;/code&gt;(表示到当前节点为止形成的二进制数，不包括当前节点)，输出是该节点到叶节点的二进制数的和，那么：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;假设函数输入的节点不是空节点，那么肯定要将该节点中的数加入&lt;code class=&quot;highlighter-rouge&quot;&gt;num&lt;/code&gt;中。接着，如果该节点是叶子节点，那么返回&lt;code class=&quot;highlighter-rouge&quot;&gt;num&lt;/code&gt;即可。而如果该节点不是叶子节点，则是该节点左子节点到叶子节点形成的数和该节点右子节点形成的数的和&lt;/li&gt;
  &lt;li&gt;若函数输入的节点是空节点，则无法形成数，返回0即可&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func sumRootToLeaf(root *TreeNode) int {   
    number := 0
    
    res := sumRootToLeafHelper(root, number)
    return res
}

func sumRootToLeafHelper(root *TreeNode, number int) int {
    if root == nil {
        return 0
    }
    
    number = number * 2 + root.Val
    
    if root.Left == nil &amp;amp;&amp;amp; root.Right == nil {
        return number
    }
    
    return sumRootToLeafHelper(root.Left, number) + sumRootToLeafHelper(root.Right, number)
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</content>
<summary>Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.</summary>
</entry>
<entry>
<title>关于996工作制的一些思考</title>
<link href="http://localhost:4000/%E5%85%B3%E4%BA%8E996%E5%B7%A5%E4%BD%9C%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/" rel="alternate" type="text/html" title="关于996工作制的一些思考" />
<published>2019-04-19T00:00:00+08:00</published>
<updated>2019-04-19T00:00:00+08:00</updated>
<id>http://localhost:4000/关于996工作制的一些思考</id>
<content type="html" xml:base="http://localhost:4000/%E5%85%B3%E4%BA%8E996%E5%B7%A5%E4%BD%9C%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">&lt;p&gt;本来“Share”应该是分享技术观点的文章，但最近的996工作制闹的沸沸扬扬的，我也想对这个东西讲一点自己的思考。&lt;/p&gt;

&lt;p&gt;其实，作为一个学生，谈论996工作制似乎为时过早。另一方面，目前很快就毕业了，稍微等几个月说不定在实际工作中就能体会到，到时候再来发表观点也不晚。但转念一想，如果未来能打自己的脸，似乎也挺不错的，这样想到这件事就能提醒自己——没经历过的事情想的再合理也不一定符合实际。&lt;/p&gt;

&lt;p&gt;996工作制最开始是在github上火起来的，由许多国内的程序员创建的&lt;a href=&quot;https://github.com/996icu/996.ICU&quot;&gt;996.icu&lt;/a&gt;在github上的star数一直飙升，很快就引起了注意。媒体、公司领导人和国外的一些知名程序员都关于996发表了自己的看法，甚至还有微博上的共青团中央加入。事情发展到后来，慢慢就好像变成了资本家和工人阶级的对抗。&lt;/p&gt;

&lt;p&gt;这里姑且还是做个介绍，996指的是上班时间从早9点到晚9点，一周工作6天。ICU指的是重症加强护理病房。996.icu的意思是工作996,生病icu。&lt;/p&gt;

&lt;p&gt;广大民众的基本角度是平常工作996实在过于辛苦，人和机器没什么两样了。隐形996也就算了，还有很多公司，像京东、有赞都开始强制996了，这样下去还得了？而领导层的基本角度就千奇百怪了，为了奋斗的，为了情怀的，为了理想的层出不穷。&lt;/p&gt;

&lt;p&gt;然而，不管怎么说，首先有一件事是毋庸置疑的，大部分996的公司都违反了法律。既然《劳动法》规定了一周的最长规定时间，那么企业就不应该违反。要加班，就得拿工资，而且还得本人愿意，否则就是违反了法律。而在文明社会里，明目张胆的违反法律如果被允许，后果不堪设想。&lt;/p&gt;

&lt;p&gt;接下去先反驳一下领导层的观点，996是为了理想或者为了社会或者奋斗者等等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;996是为了理想&lt;/strong&gt; 这句话本身就不对，并不是每个人的理想都是赚大钱或者成为技术大牛，抑或是成为什么了不起的人。很多领导层的人往往会批判这样的人说没有理想，可是理想本来就是很私人的东西。假设A的理想是成为技术大牛，B的理想是娶老婆。然后大家就会觉得A了不起，B就是个笑话。But，假设A出生在一个技术大国，B出生在一个男女比例100：1的国家，那B的理想难道真那么可笑吗？显然不是&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;996是为了社会&lt;/strong&gt; 也有人说，996是为了创造更多的价值，造福我们的社会。这其实是本末倒置，996的一个问题在于引发了工作人员的不幸，还怎么造福社会？也许有人会说，996的是少部分人，造福了大部分社会群体。严重点来说，这就好比杀一人救百人的问题，我个人认为，还得看别人是否愿意。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;996是体现了奋斗者精神&lt;/strong&gt; 我不否认，如果一个人做到了996,他确实很拼。我也相信，很多领导层的人确实不只996,忙起来12127都有可能。然而，如果要说996体现了奋斗者精神，我觉得不对——奋斗者精神并不是看时间的，而是看品质的。有996的人可能其实在磨洋工，也有很多955的人工作时候全神贯注，重点还是工作时候的状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;996能加快工作进度&lt;/strong&gt; 996真的能使工作效率提升吗？短时确实可以，但我相信，长时间996根本就做不到——假设996的时候都是在全神贯注的思考问题，完成工作的话。人的精力毕竟有限，段时间内刺激一下，长时间的产出反而会降低工作效率，尤其是技术类的工作。确实有少部分人可能精力异乎常人，再抱持着对工作的热爱，也许几年都不成问题，但这其实是用健康在交换。即便一直做自己喜欢的事情，也需要休息，更何况现在又有多少人是在做着自己喜欢的工作？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;企业家知道上面这些吗？当然知道，连我都能想通，他们怎么可能不知道？但他们仍然找出一些真假混合的借口来试图使996合理化，这是为什么？我也想不明白，除非他们认为996真的能提升工作效率——那就是把人当成了机器，无论运行多长时间都能保持一致的效率。&lt;/p&gt;

&lt;p&gt;另一方面，在广大群众之中，肯定存在着这么一种人——拿着够用的工资，干着996的活，不肯辞职却还要抱怨。确实有些人接受996是因为养家糊口——生活不易嘛。但是，也有部分人并不是——如果国内真的像媒体宣传的那么好的话，应该大部分都不是。很多人说，房价高啊，买房啊。然而房价真正高的地方主要是一线，这些地方聚集着的都是精英。他们的目的是为了以后的小孩和自己的前途，我认为，这种人就应该接受996——一方面，竞争者多，另一方面，一线城市的价值也在那放着。如果他们真的梦想过上安逸的生活，去一个差点的城市找个不用996的工作就可以，何必抱怨？既想要安逸、舒服的生活，又想要拿高工资，享受最好的教育和医疗，如果真实现了，指不定又会有更高要求，毕竟人的贪欲是无穷的。&lt;/p&gt;

&lt;p&gt;综上，我认为，企业不应该强制实施996,可以鼓励短期996,但对于长期工作者反而应该劝告。而对于在一线享受资源还要抱怨的人——出于我的小人心理，希望他们还是应该受点罪的&lt;/p&gt;
</content>
<summary>本来“Share”应该是分享技术观点的文章，但最近的996工作制闹的沸沸扬扬的，我也想对这个东西讲一点自己的思考。</summary>
</entry>
<entry>
<title>Arts Weektwo Vim进阶</title>
<link href="http://localhost:4000/ARTS-WeekTwo-vim%E8%BF%9B%E9%98%B6/" rel="alternate" type="text/html" title="Arts Weektwo Vim进阶" />
<published>2019-04-16T00:00:00+08:00</published>
<updated>2019-04-16T00:00:00+08:00</updated>
<id>http://localhost:4000/ARTS-WeekTwo-vim进阶</id>
<content type="html" xml:base="http://localhost:4000/ARTS-WeekTwo-vim%E8%BF%9B%E9%98%B6/">&lt;p&gt;上周开了vim的坑，因此决心干脆尽量把vim的大部分常用内容都记录下来，便于以后翻阅。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;^ -&amp;gt; 到本行第一个不是blank字符的位置&lt;/li&gt;
  &lt;li&gt;g_ -&amp;gt; 到本行最后一个不是blank字符的位置&lt;/li&gt;
  &lt;li&gt;:e &amp;lt;path/to/file&amp;gt; -&amp;gt; 打开一个文件&lt;/li&gt;
  &lt;li&gt;:saveas &amp;lt;path/to/file&amp;gt; -&amp;gt; 另存为&amp;lt;path/to/file&amp;gt;&lt;/li&gt;
  &lt;li&gt;:bn和:bp -&amp;gt; 同时打开多个文件时，使用这两个命令切换上一个和下一个文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; -&amp;gt; 可以重复上一次的命令&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;N&amp;lt;command&amp;gt;&lt;/code&gt; -&amp;gt; 重复某个命令N次&lt;/li&gt;
  &lt;li&gt;*和# -&amp;gt; 匹配光标当前所在的单词，移动光标到下一个或上一个匹配单词&lt;/li&gt;
  &lt;li&gt;很多命令可以以下面的形式来干&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;start position&amp;gt;&amp;lt;command&amp;gt;&amp;lt;end position&amp;gt;&lt;/code&gt;&lt;br /&gt;
例如&lt;code class=&quot;highlighter-rouge&quot;&gt;0y$&lt;/code&gt;意味着：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; -&amp;gt; 到行头&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; -&amp;gt; 拷贝&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; -&amp;gt; 到本行最后一个字符&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gU&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;gu&lt;/code&gt;后跟位置(例如w，e，$等)变换大小写&lt;/li&gt;
  &lt;li&gt;在当前行上，&lt;code class=&quot;highlighter-rouge&quot;&gt;fa&lt;/code&gt;可以到下一个字符为a的位置处，a可变。ta可以到a前的第一个字符，a可变。这两者前可加数字&lt;/li&gt;
  &lt;li&gt;区域选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;action&amp;gt;a&amp;lt;object&amp;gt;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;action&amp;gt;i&amp;lt;object&amp;gt;&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt;可以是任何命令，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;等&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;可以是&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;(单词),&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;(句子),&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;(段落)，或者是特别字符:&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;&lt;br /&gt;
举例来说，字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;(haha (-) (&quot;tfz&quot;))&lt;/code&gt;.光标在f位置
        &lt;blockquote&gt;
          &lt;ul&gt;
            &lt;li&gt;vi” -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;tfz&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;va” -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;tfz&quot;&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;vi) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;tfz&quot;&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;va) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;(&quot;tfz&quot;)&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;v2i) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;haha (-) (&quot;tfz&quot;)&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;v2a) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;(haha (-) (&quot;tfz&quot;))&lt;/code&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;块操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-v&amp;gt; &amp;lt;move&amp;gt; &amp;lt;motion&amp;gt; [ESC]&lt;/code&gt;&lt;br /&gt;
一般都用于插入，举例来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-v&amp;gt; 向下移动 I-- [ESC]&lt;/code&gt;为在同一位置前方插入&lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;字符&lt;/li&gt;
  &lt;li&gt;Insert模式下按&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;或是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;可以自动补全&lt;/li&gt;
  &lt;li&gt;宏录制
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;qa&lt;/code&gt;把操作记录在寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@a&lt;/code&gt;会replay被录制的宏&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@@&lt;/code&gt;会replay最新录制的宏&lt;br /&gt;
例如：在一行只有”1”的文本中，键入下面的命令:&lt;/li&gt;
      &lt;li&gt;qayyp&lt;C-a&gt;q -&amp;gt;&lt;/C-a&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;qa开始录制&lt;/li&gt;
      &lt;li&gt;yyp复制并粘贴当前行&lt;/li&gt;
      &lt;li&gt;
        &lt;C-a&gt;增加1  
&lt;/C-a&gt;
      &lt;/li&gt;
      &lt;li&gt;q停止录制&lt;br /&gt;
      * @a -&amp;gt; 在1下面写下2&lt;br /&gt;
      * @@ -&amp;gt; 在2下面写下3&lt;br /&gt;
      * 100@@ -&amp;gt; 创建新的100行，并把数据增加到103&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;块操作，当目标块被选中后，可以有如下操作：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt; -&amp;gt; 把所有的行连接起来变成一行&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; -&amp;gt; 左右缩进&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; -&amp;gt; 自动缩进&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分屏，&lt;code class=&quot;highlighter-rouge&quot;&gt;:split&lt;/code&gt;水平分屏，&lt;code class=&quot;highlighter-rouge&quot;&gt;vsplit&lt;/code&gt;垂直分屏, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-w&amp;gt;&amp;lt;direction(可以是hjkl)&amp;gt;&lt;/code&gt;切换分屏&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;资料来源&quot;&gt;资料来源&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/5426.html&quot;&gt;简明vim练级攻略&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
<summary>上周开了vim的坑，因此决心干脆尽量把vim的大部分常用内容都记录下来，便于以后翻阅。</summary>
</entry>
</feed>
