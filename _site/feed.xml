<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-04-26T16:57:52+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Tonfeiz’s Blog</title><subtitle></subtitle><author><name>Tonfeiz</name></author><entry><title type="html">技术学习之路</title><link href="http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" rel="alternate" type="text/html" title="技术学习之路" /><published>2019-04-26T00:00:00+08:00</published><updated>2019-04-26T00:00:00+08:00</updated><id>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF</id><content type="html" xml:base="http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">&lt;p&gt;这篇文章想讲讲对于学计算机技术应该怎么学，我自己的思考与观点。&lt;/p&gt;

&lt;p&gt;说起来，Share好像变成了一个分享自己观点的东西。本意上Share应该是分享技术相关内容的。这样可能有点违规，但我觉得，分享自己的观点也不差，甚至非技术的内容也可以，因为这样促使人真正的去整理观点，审视自己，而人生除了技术之外还有很多东西能从这么做获益。&lt;/p&gt;

&lt;p&gt;说回正题，计算机技术学习之路是一个很广泛的概念。目前计算机衍生出了这么多分支，肯定不可能每条都一样，因此这篇文章讲的是很宽泛的内容。此外，我是纯自学学的计算机，我想目前社会上像我这样的人不在少数，我的观点可能多多少少有点启发意义。&lt;/p&gt;

&lt;h2 id=&quot;深度和广度&quot;&gt;深度和广度&lt;/h2&gt;
&lt;p&gt;深度和广度是计算机技术中常常被人们谈及的领域，究竟是深度更重要还是广度更重要也常常被讨论。实际上，深度往往伴随着广度，深度到了一定地步，伴随着而来的就是涉及到的知识面更广。而广度——广度并不一定有深度，你可以从计算机工程到计算机理论各个领域全部涉及一遍。&lt;/p&gt;

&lt;p&gt;然而，对于初学者而言，我认为还是广度更重要。求深度是一件好事，尤其现在社会分工日益精细了。但我认为，先求广度可以让初学者对计算机技术涉及的各个领域有一个基本的概念。在这之后寻求深度，往往花费时间更少。举例来说，我个人最喜欢的读书方式就是先快速读一遍，再精读一遍，最后再快速读一遍。第一遍是对书的主题、叙述方式有一个大概的了解，并且判断是否有必要再读第二遍。第二遍则是把第一遍留下的问题或者感兴趣的地方重点去看。第三编则类似于快速复习，查漏补缺。我喜欢的技术学习路线也和读书很像，先广后深再广，最后的广度就是复习自己学到的东西并看是否还有不会的。&lt;/p&gt;

&lt;p&gt;另外，广度还有一个好处是能把知识点连起来。很多时候涉及的多了就会发现不同的问题都能有相同的方法解决，比如随处可见的缓存，算法里的分治等。对于这些东西有个初步的概念后，日后的学习就能知道重点——一般出现的越多说明它越重要，就能事半功倍。最重要的是，这些方法体现了计算机整个学科的精髓，而跨学科思考的思想也是很重要的。这些思想往往不局限于计算机，而是能解决各种问题。&lt;/p&gt;

&lt;h2 id=&quot;内功招式和武器&quot;&gt;内功、招式和武器&lt;/h2&gt;
&lt;p&gt;在提到计算机技术的基础时，有一个很常见的比喻，就是内功、招式和武器。内功就是基础，招式就是技术方法，武器就是工具。人们往往会强调基础的重要性，说如果没有内功，空有招式，打到敌人也不疼。如果没有招式，空有内功，至少浑厚的内功还能给你减伤。至于武器，则有锦上添花之效。&lt;/p&gt;

&lt;p&gt;对于上面的比喻，我想说，说的太有道理了。基础的重要性是怎么强调也不为过的。随着时间的流逝，基础好的人其个人能力是先慢后块，而基础差的人则是先快后慢，最后还是得回来补。&lt;/p&gt;

&lt;p&gt;但是对于基础怎么学，我有点想法。很多人一上来推荐书，推荐看视频。从编程语言到操作系统，各种基础类的资源推荐了个遍。然而这些东西学完恐怕要花个几年，而且又很枯燥，往往无法解决一些实际的问题。还是用上面那个比喻，学内功是很辛苦的，而且进度缓慢。而学招式还是挺好玩的，至少能摆个花架子唬人。&lt;/p&gt;

&lt;p&gt;我认为，可以先学招式无妨。在学招式的过程中伴随着内功的修炼，或者学完招式之后再学内功，也是可以的。举例来说，在学习网络的时候，可以先学着实现一个简单的qq。在实现的过程中，有些细枝末节可以仅仅了解，而涉及到网络的部分则重点学习，并且尝试不同的方法。在实现过程中遇到的问题可以知其然而不知其所以然，但要记录在案。在实现了这个项目后，翻看《TCP/IP详解卷一》，往往看到某个知识点会和之前的问题对上。在这样的情况下，记忆更深刻，也更有效。&lt;/p&gt;

&lt;h2 id=&quot;学习总结&quot;&gt;学习总结&lt;/h2&gt;
&lt;p&gt;我这里稍微更具体的总结一下学习的方法。&lt;/p&gt;

&lt;p&gt;对于任意一门科目，首先选取一种输入(视频、书甚至百度百科)，大概了解即可，不需要精通。这里所说的了解，是指知道它是什么，有什么用，怎么用。例如编程语言，知道类型是什么意思，怎么定义类型，函数是什么，几种循环结构即可。接下来去找一个实际的问题，去解决它。还是以C语言为例，你可以考虑怎么用C语言画画，用C语言写游戏等等。在解决的过程中你会发现各种问题，比如内存错误，编译错误等等。记下这些错误，并去搜解决它们的方法，但不一定要知道为什么这样可以解决它。最后，挑一本经典书籍或是其他类型的经典输入，仔细的读，并和问题对照。&lt;/p&gt;

&lt;p&gt;想要学的好，就得记住，学习是伴随着枯燥的。刻意练习的核心就是踏出舒适区。如果你感觉到学习过程很轻松，那说明你还没有尽全力，或者还在换一种形式啃自己已经了解的东西。警惕心流，处于心流状态时，有可能也是处于钻牛角尖的状态。&lt;/p&gt;

&lt;p&gt;最后，不要逼自己。实在学不下去的时候，let it go&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">这篇文章想讲讲对于学计算机技术应该怎么学，我自己的思考与观点。</summary></entry><entry><title type="html">Arts Weekthree Vim配置</title><link href="http://localhost:4000/ARTS-WeekThree-vim%E9%85%8D%E7%BD%AE/" rel="alternate" type="text/html" title="Arts Weekthree Vim配置" /><published>2019-04-24T00:00:00+08:00</published><updated>2019-04-24T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekThree-vim%E9%85%8D%E7%BD%AE</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekThree-vim%E9%85%8D%E7%BD%AE/">&lt;p&gt;vim中的配置是十分重要的内容，不同的用户可以根据自己的喜好将vim配置成自己喜爱的样式。本次就根据vim的帮助文档介绍以下vim配置方面的内容。&lt;/p&gt;

&lt;h2 id=&quot;vimrc文件&quot;&gt;vimrc文件&lt;/h2&gt;
&lt;p&gt;vimrc文件中包含了vim在启动时就会执行的命令。对于我们最喜欢的选项和按键映射，可以放到vimrc中&lt;/p&gt;

&lt;p&gt;vimrc文件的名字叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;.vimrc&lt;/code&gt;，对于Unix操作系统和Macintosh操作系统来说，它的路径名一般是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vimrc&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;vimrc文件中可以包含所有能在vim中普通模式下”:”后面执行的命令，最简单的设置选项的指令，其一般格式是&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set &amp;lt;options&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;想要查看有哪些配置可以输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:options&lt;/code&gt;查看或是在帮助中查看。&lt;/p&gt;

&lt;p&gt;对于特定的配置，可以输入&lt;code class=&quot;highlighter-rouge&quot;&gt;:help '&amp;lt;option name&amp;gt;'&lt;/code&gt;查看。另外，在设置某个选项时在后面加&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;即可恢复默认设置&lt;/p&gt;

&lt;p&gt;为了使vimrc文件起作用需要退出vim再重新启动&lt;/p&gt;

&lt;p&gt;下面列举一些设置作为例子说明&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set autoindent&lt;/code&gt;:自动缩进，使用前一行的缩进作为当前行缩进&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if has(&quot;vms&quot;)
  set nobackup
else
  set backup
endif
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使得vim在覆写一个文件时保存有该文件的备份，而在VMS系统上则不用，因为VMS系统自带有这个功能。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;set history=50&lt;/code&gt;:在历史记录中保持50个命令和50种搜索模式&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set ruler&lt;/code&gt;:允许在右下角显示当前游标的位置&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set showcmd&lt;/code&gt;:显示普通模式下输入的命令&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;set incsearch&lt;/code&gt;:在输入搜索模式下显示和其匹配的内容&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;map Q gq&lt;/code&gt;:这是一个按键映射，将&lt;code class=&quot;highlighter-rouge&quot;&gt;Q&lt;/code&gt;键映射到&lt;code class=&quot;highlighter-rouge&quot;&gt;gq&lt;/code&gt;按键上&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;filetype plugin indent on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;文件类型检测：当开始编辑一个文件时，vim将会通过文件扩展名试图发现文件的类型。文件类型可被用于语法高亮等用途&lt;/li&gt;
  &lt;li&gt;使用文件类型插件文件(filetype plugin files):不同的文件类型有不同的设置。这些公共的有用选项在vim的文件类型插件中&lt;/li&gt;
  &lt;li&gt;使用缩进文件：不同类型的文件种类使用不同的缩进&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;简单的映射&quot;&gt;简单的映射&lt;/h2&gt;
&lt;p&gt;按键映射应该是所有编辑器必备的功能了。在vim中很简单，举例来说，在vimrc文件中添加&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:map &amp;lt;F5&amp;gt; i{&amp;lt;Esc&amp;gt;ea}&amp;lt;Esc&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面的这个映射解析为&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&amp;lt;F5&amp;gt; 映射按键是F5键&lt;/li&gt;
  &lt;li&gt;i{ 转换为插入模式并输入{&lt;/li&gt;
  &lt;li&gt;&amp;lt;Esc&amp;gt; 退出为普通模式&lt;/li&gt;
  &lt;li&gt;ea}到单词结尾并输入}&lt;/li&gt;
  &lt;li&gt;&amp;lt;Esc&amp;gt;最后转化为普通模式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，一般情况下输入一个单词，按F5键即可在其两端加上大括号&lt;/p&gt;

&lt;h2 id=&quot;添加插件&quot;&gt;添加插件&lt;/h2&gt;
&lt;p&gt;vim可通过添加插件来扩展自己的功能。插件其实就是vim在启动时自动加载的vim脚本文件。在&lt;code class=&quot;highlighter-rouge&quot;&gt;plugin&lt;/code&gt;文件夹中添加对应文件就可添加插件&lt;/p&gt;

&lt;p&gt;有两种插件：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;全局插件：对所有文件都有效&lt;/li&gt;
  &lt;li&gt;文件类型插件：对特定文件类型才有效&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;全局插件&quot;&gt;全局插件&lt;/h3&gt;
&lt;p&gt;全局插件在启动时自动加载，它们提供了大部分通用的功能。&lt;/p&gt;

&lt;p&gt;添加全局插件只需要两步，获取全局插件，放入对应文件夹&lt;/p&gt;

&lt;p&gt;获取全局插件有许多地方，这里不再详述。若想要使用对应插件，则首先阅读该插件的说明文档看是否有需要注意的地方，然后将文件复制到插件文件夹下。对于Unix来说，位置一般是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vim/plugin&lt;/code&gt;。值得注意的是，不一定要直接放入&lt;code class=&quot;highlighter-rouge&quot;&gt;plugin&lt;/code&gt;目录下，也可以在其中创建子目录并放入其中&lt;/p&gt;

&lt;h3 id=&quot;文件类型插件&quot;&gt;文件类型插件&lt;/h3&gt;
&lt;p&gt;在使用文件类型插件时，需要使用命令&lt;code class=&quot;highlighter-rouge&quot;&gt;:filetype plugin on&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加文件类型插件需要将它放入特定的文件夹，在Unix环境下就是&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.vim/ftplugin&lt;/code&gt;.对于文件类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;filetype&lt;/code&gt;的插件，该插件名字可以为&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;_&amp;lt;name&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;filetype&amp;gt;/&amp;lt;name&amp;gt;.vim&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;name&amp;gt;可以是任意的&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">vim中的配置是十分重要的内容，不同的用户可以根据自己的喜好将vim配置成自己喜爱的样式。本次就根据vim的帮助文档介绍以下vim配置方面的内容。</summary></entry><entry><title type="html">Arts Weekthree Leetcode1022 Sumroottoleaf</title><link href="http://localhost:4000/ARTS-WeekThree-Leetcode1022-sumRootToLeaf/" rel="alternate" type="text/html" title="Arts Weekthree Leetcode1022 Sumroottoleaf" /><published>2019-04-23T00:00:00+08:00</published><updated>2019-04-23T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekThree-Leetcode1022-sumRootToLeaf</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekThree-Leetcode1022-sumRootToLeaf/">&lt;p&gt;Given a binary tree, each node has value 0 or 1.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.&lt;/p&gt;

&lt;p&gt;For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.&lt;/p&gt;

&lt;p&gt;Return the sum of these numbers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br /&gt;
    1. The number of nodes in the tree is between 1 and 1000.&lt;br /&gt;
    2. node.val is 0 or 1.&lt;br /&gt;
    3. The answer will not exceed 2^31 - 1.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这道题的意思就是对一棵二叉树，每个结点可能是0或者1,则从根节点到叶节点就构成了一个二进制数。求所有这样的二进制数的和。&lt;/p&gt;

&lt;p&gt;二叉树的题目一般都是涉及到递归的。递归的方法主要就是回溯，因此一开始就往回溯那方面去想了。这题用回溯也可以做，但没那么复杂。&lt;/p&gt;

&lt;p&gt;递归的题目中，我觉得函数代表的意义是很重要的。对这题来说，假设有一个递归函数的输入是一个节点&lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt;和一个数&lt;code class=&quot;highlighter-rouge&quot;&gt;num&lt;/code&gt;(表示到当前节点为止形成的二进制数，不包括当前节点)，输出是该节点到叶节点的二进制数的和，那么：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;假设函数输入的节点不是空节点，那么肯定要将该节点中的数加入&lt;code class=&quot;highlighter-rouge&quot;&gt;num&lt;/code&gt;中。接着，如果该节点是叶子节点，那么返回&lt;code class=&quot;highlighter-rouge&quot;&gt;num&lt;/code&gt;即可。而如果该节点不是叶子节点，则是该节点左子节点到叶子节点形成的数和该节点右子节点形成的数的和&lt;/li&gt;
  &lt;li&gt;若函数输入的节点是空节点，则无法形成数，返回0即可&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func sumRootToLeaf(root *TreeNode) int {   
    number := 0
    
    res := sumRootToLeafHelper(root, number)
    return res
}

func sumRootToLeafHelper(root *TreeNode, number int) int {
    if root == nil {
        return 0
    }
    
    number = number * 2 + root.Val
    
    if root.Left == nil &amp;amp;&amp;amp; root.Right == nil {
        return number
    }
    
    return sumRootToLeafHelper(root.Left, number) + sumRootToLeafHelper(root.Right, number)
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given a binary tree, each node has value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.</summary></entry><entry><title type="html">Arts Weekthree Twelve Factor(三)</title><link href="http://localhost:4000/ARTS-WeekThree-Twelve-Factor(%E4%B8%89)/" rel="alternate" type="text/html" title="Arts Weekthree Twelve Factor(三)" /><published>2019-04-23T00:00:00+08:00</published><updated>2019-04-23T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekThree-Twelve-Factor(%E4%B8%89)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekThree-Twelve-Factor(%E4%B8%89)/">&lt;p&gt;Twelve Factor Part Three&lt;br /&gt;
Port binding&lt;br /&gt;
Concurrency&lt;br /&gt;
Disposability&lt;/p&gt;

&lt;h2 id=&quot;七端口号绑定&quot;&gt;七、端口号绑定&lt;/h2&gt;
&lt;p&gt;通过绑定端口号导出服务&lt;/p&gt;

&lt;p&gt;应用程序应当是自包含(self-contained)的，并且它不应当依赖运行时服务器的注入。web app通过将HTTP绑定到一个端口号上来将其导出作为服务。&lt;/p&gt;

&lt;p&gt;在本地的开发环境，开发者通过像&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:5000/&lt;/code&gt;这样的URL访问自己开发的服务。在部署环境中，则通过公共域名和端口访问。&lt;/p&gt;

&lt;p&gt;通常这通过使用依赖声明将一个web服务器库添加到app中完成，例如Python的Tornado，Java的Jetty。&lt;/p&gt;

&lt;p&gt;注意绑定端口的服务意味着它也可以成为其他app的&lt;code class=&quot;highlighter-rouge&quot;&gt;backing service&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;八并发&quot;&gt;八、并发&lt;/h2&gt;
&lt;p&gt;通过进程模型达成横向扩展&lt;/p&gt;

&lt;p&gt;任何计算机程序都表示为一个或多个计算机程序。Web应用使用了许多不同类型的进程执行形式，例如PHP进程作为Apache的子进程存在，Java由JVM提供一个维护大块系统资源的进程，而并发就由线程内在的管理。不管哪种形式，运行着的进程对于app的开发者来说都只具有最小的可见性。&lt;/p&gt;

&lt;p&gt;在twelve-factor app中，进程是一等公民。twelve-factor中的进程从运行守护服务的UNIX进程模型获得强烈的启发。在这种模型下，开发者可通过将每种类型的工作分发一个进程类型来架构自己的app以使它们能处理形色各异的工作负载。&lt;/p&gt;

&lt;p&gt;twelve-factor app无共享、水平可分的特性意味着增强并发是一个简单可信任的操作。进程类型和每种类型的进程数量组成的矩阵则是进程信息。&lt;/p&gt;

&lt;p&gt;twelve-factor app不能被配置为守护进程也不能写PID文件，而应当依赖操作系统的进程管理器来管理输出流，对崩溃进程作出反应或是处理用户的重启和关闭&lt;/p&gt;

&lt;h2 id=&quot;九可弃性disposability&quot;&gt;九、可弃性(Disposability)&lt;/h2&gt;
&lt;p&gt;通过快速启动和优雅的关闭来最大化鲁棒性&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;disposability&lt;/code&gt;意味着app可以被一瞬间开启或关闭。这对于伸缩性、代码或配置改变时的快速部署以及生产环境部署的鲁棒性都很重要。&lt;/p&gt;

&lt;p&gt;进程应当尽量最小化启动时间，最好只需几秒钟。短暂的启动时间意味着更灵活，更鲁棒(进程管理器可以更快的把进程移动到新的物理机上)&lt;/p&gt;

&lt;p&gt;当进程从进程管理器处收到&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGTERM&lt;/code&gt;信号时应当优雅的关闭。对于web进程来说，这意味着停止监听端口，让当前的请求结束然后退出。&lt;/p&gt;

&lt;p&gt;对于工作进程来说，这意味着把当前的工作返回到工作队列中。&lt;/p&gt;

&lt;p&gt;进程应当对由底层硬件导致的突然死亡也鲁棒。一个建议的方法是使用鲁棒的后端队列，例如Beanstalked&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Twelve Factor Part Three Port binding Concurrency Disposability</summary></entry><entry><title type="html">关于996工作制的一些思考</title><link href="http://localhost:4000/%E5%85%B3%E4%BA%8E996%E5%B7%A5%E4%BD%9C%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/" rel="alternate" type="text/html" title="关于996工作制的一些思考" /><published>2019-04-19T00:00:00+08:00</published><updated>2019-04-19T00:00:00+08:00</updated><id>http://localhost:4000/%E5%85%B3%E4%BA%8E996%E5%B7%A5%E4%BD%9C%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83</id><content type="html" xml:base="http://localhost:4000/%E5%85%B3%E4%BA%8E996%E5%B7%A5%E4%BD%9C%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">&lt;p&gt;本来“Share”应该是分享技术观点的文章，但最近的996工作制闹的沸沸扬扬的，我也想对这个东西讲一点自己的思考。&lt;/p&gt;

&lt;p&gt;其实，作为一个学生，谈论996工作制似乎为时过早。另一方面，目前很快就毕业了，稍微等几个月说不定在实际工作中就能体会到，到时候再来发表观点也不晚。但转念一想，如果未来能打自己的脸，似乎也挺不错的，这样想到这件事就能提醒自己——没经历过的事情想的再合理也不一定符合实际。&lt;/p&gt;

&lt;p&gt;996工作制最开始是在github上火起来的，由许多国内的程序员创建的&lt;a href=&quot;https://github.com/996icu/996.ICU&quot;&gt;996.icu&lt;/a&gt;在github上的star数一直飙升，很快就引起了注意。媒体、公司领导人和国外的一些知名程序员都关于996发表了自己的看法，甚至还有微博上的共青团中央加入。事情发展到后来，慢慢就好像变成了资本家和工人阶级的对抗。&lt;/p&gt;

&lt;p&gt;这里姑且还是做个介绍，996指的是上班时间从早9点到晚9点，一周工作6天。ICU指的是重症加强护理病房。996.icu的意思是工作996,生病icu。&lt;/p&gt;

&lt;p&gt;广大民众的基本角度是平常工作996实在过于辛苦，人和机器没什么两样了。隐形996也就算了，还有很多公司，像京东、有赞都开始强制996了，这样下去还得了？而领导层的基本角度就千奇百怪了，为了奋斗的，为了情怀的，为了理想的层出不穷。&lt;/p&gt;

&lt;p&gt;然而，不管怎么说，首先有一件事是毋庸置疑的，大部分996的公司都违反了法律。既然《劳动法》规定了一周的最长规定时间，那么企业就不应该违反。要加班，就得拿工资，而且还得本人愿意，否则就是违反了法律。而在文明社会里，明目张胆的违反法律如果被允许，后果不堪设想。&lt;/p&gt;

&lt;p&gt;接下去先反驳一下领导层的观点，996是为了理想或者为了社会或者奋斗者等等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;996是为了理想&lt;/strong&gt; 这句话本身就不对，并不是每个人的理想都是赚大钱或者成为技术大牛，抑或是成为什么了不起的人。很多领导层的人往往会批判这样的人说没有理想，可是理想本来就是很私人的东西。假设A的理想是成为技术大牛，B的理想是娶老婆。然后大家就会觉得A了不起，B就是个笑话。But，假设A出生在一个技术大国，B出生在一个男女比例100：1的国家，那B的理想难道真那么可笑吗？显然不是&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;996是为了社会&lt;/strong&gt; 也有人说，996是为了创造更多的价值，造福我们的社会。这其实是本末倒置，996的一个问题在于引发了工作人员的不幸，还怎么造福社会？也许有人会说，996的是少部分人，造福了大部分社会群体。严重点来说，这就好比杀一人救百人的问题，我个人认为，还得看别人是否愿意。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;996是体现了奋斗者精神&lt;/strong&gt; 我不否认，如果一个人做到了996,他确实很拼。我也相信，很多领导层的人确实不只996,忙起来12127都有可能。然而，如果要说996体现了奋斗者精神，我觉得不对——奋斗者精神并不是看时间的，而是看品质的。有996的人可能其实在磨洋工，也有很多955的人工作时候全神贯注，重点还是工作时候的状态。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;996能加快工作进度&lt;/strong&gt; 996真的能使工作效率提升吗？短时确实可以，但我相信，长时间996根本就做不到——假设996的时候都是在全神贯注的思考问题，完成工作的话。人的精力毕竟有限，段时间内刺激一下，长时间的产出反而会降低工作效率，尤其是技术类的工作。确实有少部分人可能精力异乎常人，再抱持着对工作的热爱，也许几年都不成问题，但这其实是用健康在交换。即便一直做自己喜欢的事情，也需要休息，更何况现在又有多少人是在做着自己喜欢的工作？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;企业家知道上面这些吗？当然知道，连我都能想通，他们怎么可能不知道？但他们仍然找出一些真假混合的借口来试图使996合理化，这是为什么？我也想不明白，除非他们认为996真的能提升工作效率——那就是把人当成了机器，无论运行多长时间都能保持一致的效率。&lt;/p&gt;

&lt;p&gt;另一方面，在广大群众之中，肯定存在着这么一种人——拿着够用的工资，干着996的活，不肯辞职却还要抱怨。确实有些人接受996是因为养家糊口——生活不易嘛。但是，也有部分人并不是——如果国内真的像媒体宣传的那么好的话，应该大部分都不是。很多人说，房价高啊，买房啊。然而房价真正高的地方主要是一线，这些地方聚集着的都是精英。他们的目的是为了以后的小孩和自己的前途，我认为，这种人就应该接受996——一方面，竞争者多，另一方面，一线城市的价值也在那放着。如果他们真的梦想过上安逸的生活，去一个差点的城市找个不用996的工作就可以，何必抱怨？既想要安逸、舒服的生活，又想要拿高工资，享受最好的教育和医疗，如果真实现了，指不定又会有更高要求，毕竟人的贪欲是无穷的。&lt;/p&gt;

&lt;p&gt;综上，我认为，企业不应该强制实施996,可以鼓励短期996,但对于长期工作者反而应该劝告。而对于在一线享受资源还要抱怨的人——出于我的小人心理，希望他们还是应该受点罪的&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">本来“Share”应该是分享技术观点的文章，但最近的996工作制闹的沸沸扬扬的，我也想对这个东西讲一点自己的思考。</summary></entry><entry><title type="html">Arts Weektwo Vim进阶</title><link href="http://localhost:4000/ARTS-WeekTwo-vim%E8%BF%9B%E9%98%B6/" rel="alternate" type="text/html" title="Arts Weektwo Vim进阶" /><published>2019-04-16T00:00:00+08:00</published><updated>2019-04-16T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekTwo-vim%E8%BF%9B%E9%98%B6</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekTwo-vim%E8%BF%9B%E9%98%B6/">&lt;p&gt;上周开了vim的坑，因此决心干脆尽量把vim的大部分常用内容都记录下来，便于以后翻阅。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;^ -&amp;gt; 到本行第一个不是blank字符的位置&lt;/li&gt;
  &lt;li&gt;g_ -&amp;gt; 到本行最后一个不是blank字符的位置&lt;/li&gt;
  &lt;li&gt;:e &amp;lt;path/to/file&amp;gt; -&amp;gt; 打开一个文件&lt;/li&gt;
  &lt;li&gt;:saveas &amp;lt;path/to/file&amp;gt; -&amp;gt; 另存为&amp;lt;path/to/file&amp;gt;&lt;/li&gt;
  &lt;li&gt;:bn和:bp -&amp;gt; 同时打开多个文件时，使用这两个命令切换上一个和下一个文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; -&amp;gt; 可以重复上一次的命令&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;N&amp;lt;command&amp;gt;&lt;/code&gt; -&amp;gt; 重复某个命令N次&lt;/li&gt;
  &lt;li&gt;*和# -&amp;gt; 匹配光标当前所在的单词，移动光标到下一个或上一个匹配单词&lt;/li&gt;
  &lt;li&gt;很多命令可以以下面的形式来干&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;start position&amp;gt;&amp;lt;command&amp;gt;&amp;lt;end position&amp;gt;&lt;/code&gt;&lt;br /&gt;
例如&lt;code class=&quot;highlighter-rouge&quot;&gt;0y$&lt;/code&gt;意味着：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; -&amp;gt; 到行头&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; -&amp;gt; 拷贝&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; -&amp;gt; 到本行最后一个字符&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gU&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;gu&lt;/code&gt;后跟位置(例如w，e，$等)变换大小写&lt;/li&gt;
  &lt;li&gt;在当前行上，&lt;code class=&quot;highlighter-rouge&quot;&gt;fa&lt;/code&gt;可以到下一个字符为a的位置处，a可变。ta可以到a前的第一个字符，a可变。这两者前可加数字&lt;/li&gt;
  &lt;li&gt;区域选择 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;action&amp;gt;a&amp;lt;object&amp;gt;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;action&amp;gt;i&amp;lt;object&amp;gt;&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt;可以是任何命令，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;等&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;可以是&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;(单词),&lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;(句子),&lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;(段落)，或者是特别字符:&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;}&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;&lt;br /&gt;
举例来说，字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;(haha (-) (&quot;tfz&quot;))&lt;/code&gt;.光标在f位置
        &lt;blockquote&gt;
          &lt;ul&gt;
            &lt;li&gt;vi” -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;tfz&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;va” -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;tfz&quot;&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;vi) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;tfz&quot;&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;va) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;(&quot;tfz&quot;)&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;v2i) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;haha (-) (&quot;tfz&quot;)&lt;/code&gt;&lt;/li&gt;
            &lt;li&gt;v2a) -&amp;gt; 选择&lt;code class=&quot;highlighter-rouge&quot;&gt;(haha (-) (&quot;tfz&quot;))&lt;/code&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;块操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-v&amp;gt; &amp;lt;move&amp;gt; &amp;lt;motion&amp;gt; [ESC]&lt;/code&gt;&lt;br /&gt;
一般都用于插入，举例来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-v&amp;gt; 向下移动 I-- [ESC]&lt;/code&gt;为在同一位置前方插入&lt;code class=&quot;highlighter-rouge&quot;&gt;--&lt;/code&gt;字符&lt;/li&gt;
  &lt;li&gt;Insert模式下按&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-p&amp;gt;&lt;/code&gt;或是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-n&amp;gt;&lt;/code&gt;可以自动补全&lt;/li&gt;
  &lt;li&gt;宏录制
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;qa&lt;/code&gt;把操作记录在寄存器&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@a&lt;/code&gt;会replay被录制的宏&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@@&lt;/code&gt;会replay最新录制的宏&lt;br /&gt;
例如：在一行只有”1”的文本中，键入下面的命令:&lt;/li&gt;
      &lt;li&gt;qayyp&lt;C-a&gt;q -&amp;gt;&lt;/C-a&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;qa开始录制&lt;/li&gt;
      &lt;li&gt;yyp复制并粘贴当前行&lt;/li&gt;
      &lt;li&gt;
        &lt;C-a&gt;增加1  
&lt;/C-a&gt;
      &lt;/li&gt;
      &lt;li&gt;q停止录制&lt;br /&gt;
      * @a -&amp;gt; 在1下面写下2&lt;br /&gt;
      * @@ -&amp;gt; 在2下面写下3&lt;br /&gt;
      * 100@@ -&amp;gt; 创建新的100行，并把数据增加到103&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;块操作，当目标块被选中后，可以有如下操作：
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;J&lt;/code&gt; -&amp;gt; 把所有的行连接起来变成一行&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; -&amp;gt; 左右缩进&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; -&amp;gt; 自动缩进&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;分屏，&lt;code class=&quot;highlighter-rouge&quot;&gt;:split&lt;/code&gt;水平分屏，&lt;code class=&quot;highlighter-rouge&quot;&gt;vsplit&lt;/code&gt;垂直分屏, &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;C-w&amp;gt;&amp;lt;direction(可以是hjkl)&amp;gt;&lt;/code&gt;切换分屏&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;资料来源&quot;&gt;资料来源&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/5426.html&quot;&gt;简明vim练级攻略&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Tonfeiz</name></author><summary type="html">上周开了vim的坑，因此决心干脆尽量把vim的大部分常用内容都记录下来，便于以后翻阅。</summary></entry><entry><title type="html">Arts Weektwo Leetcode704 Binarysearch</title><link href="http://localhost:4000/ARTS-WeekTwo-Leetcode704-BinarySearch/" rel="alternate" type="text/html" title="Arts Weektwo Leetcode704 Binarysearch" /><published>2019-04-15T00:00:00+08:00</published><updated>2019-04-15T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekTwo-Leetcode704-BinarySearch</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekTwo-Leetcode704-BinarySearch/">&lt;p&gt;Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.&lt;/p&gt;

&lt;p&gt;You may assume that all elements in nums are unique.
n will be in the range [1, 10000].
The value of each element in nums will be in the range [-9999, 9999].&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;这题其实就是一个简单的二分搜索，数组中的元素都是唯一的，且数值也不大，难怪会被分到简单题里&lt;/p&gt;

&lt;p&gt;二分搜索很有名，要实现一个完全正确的二分搜索是很困难的，但这题的要求并不高。基本思想就是每次寻找中间元素并根据中间元素与目标元素的大小判断下一个搜索范围应该在哪一侧&lt;/p&gt;

&lt;p&gt;二分搜索时，左侧和右侧的范围应当界定明确。在下面的代码中，采用的范围是C++中的通用范围，即[left, right)。因此，循环的推出条件就是两者相等。当缩小范围时，要根据上面的关系选择是中间元素还是中间元素的两侧元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func search(nums []int, target int) int {
    left := 0
    right := len(nums)
    
    res := -1;
    for left &amp;lt; right {
        middle := left + (right - left) / 2;
        if(nums[middle] &amp;gt; target) {
            right = middle;
        } else if(nums[middle] &amp;lt; target) {
            left = middle + 1;
        } else {
            return middle;
        }
    }
    
    return res;   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.</summary></entry><entry><title type="html">Arts Weektwo Twelve Factor(二)</title><link href="http://localhost:4000/ARTS-WeekTwo-Twelve-Factor(%E4%BA%8C)/" rel="alternate" type="text/html" title="Arts Weektwo Twelve Factor(二)" /><published>2019-04-15T00:00:00+08:00</published><updated>2019-04-15T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekTwo-Twelve-Factor(%E4%BA%8C)</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekTwo-Twelve-Factor(%E4%BA%8C)/">&lt;p&gt;Twelve Factor Part Two&lt;br /&gt;
Backing services&lt;br /&gt;
Build, release and run&lt;br /&gt;
processes&lt;/p&gt;

&lt;h2 id=&quot;四支持服务backing-services&quot;&gt;四、支持服务(Backing services)&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;backing services&lt;/em&gt;应当被视为附加资源&lt;/p&gt;

&lt;p&gt;&lt;em&gt;backing services&lt;/em&gt;是app通过网络使用的服务，并且这些服务被视为它基本操作的一部分。举例来说，数据存储服务(MySQL等)、消息队列系统(RabbitMQ)和缓存系统(Memcached)都属于这种服务。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;backing services&lt;/em&gt;包括本地管理的服务和第三方服务。本条的要点就在于，不管哪类服务对app来说都应当没有区别，都被看作附加资源，都可以通过URL或者配置中的locator/credential访问。&lt;/p&gt;

&lt;p&gt;对于app来说，一个&lt;em&gt;backing services&lt;/em&gt;应当和另一个同样功能的&lt;em&gt;backing services&lt;/em&gt;完成无缝替换——不需要更改任何代码。这就是因为把它们看作附加资源而使其变成松耦合带来的好处&lt;/p&gt;

&lt;h2 id=&quot;五构建发行和运行&quot;&gt;五、构建、发行和运行&lt;/h2&gt;
&lt;p&gt;严格的区分构建和运行阶段&lt;/p&gt;

&lt;p&gt;一个&lt;em&gt;codebase&lt;/em&gt;通过下面三个阶段被转换为一个部署：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;构建阶段将代码转换成一批可执行文件。构建阶段获取提供者的依赖并编译二进制文件和资源&lt;/li&gt;
  &lt;li&gt;发行阶段将构建完成的东西和部署当前的配置结合起来。发行阶段完成的东西随时可以在执行环境中运行&lt;/li&gt;
  &lt;li&gt;运行阶段在执行环境中运行，启动app的一些进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;twelve-factor app严格的区分上面这三个阶段，这样就不能对运行阶段的代码作任何修改，也可以方便的回滚到上一个发行版本。每个发行版本应该有一个独一无二的ID作为标识。任何发行版本都不应该被改动，想要改动则需要新的发行版本&lt;/p&gt;

&lt;p&gt;运行时可执行文件应当自动在任何场合(如服务器重启，进程崩溃后重启)自动执行。&lt;/p&gt;

&lt;h2 id=&quot;六进程&quot;&gt;六、进程&lt;/h2&gt;
&lt;p&gt;将app作为一个或多个无状态进程执行&lt;/p&gt;

&lt;p&gt;进程应当是无状态的，不共享任何东西。需要持久化的数据应当被存在一个有状态的&lt;em&gt;backing service&lt;/em&gt;中，通常是一个数据库&lt;/p&gt;

&lt;p&gt;进程的内存空间或者文件系统可以被作为一个简短的，单个的事务(transaction)缓存处理。twelve-factor app从不假设在内存或是磁盘上缓存的东西在未来的请求或是工作中会是有效的——有多种情况会导致它们是失效的或被清除。  、&lt;/p&gt;

&lt;p&gt;sticky session将用户的session数据保存在app的进程内存中并期望从相同的访问者来的请求被路由到同样的进程。这是对本准则的违反，不应当被使用。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">Twelve Factor Part Two Backing services Build, release and run processes</summary></entry><entry><title type="html">Arts Weekone Vimtutor总结</title><link href="http://localhost:4000/ARTS-WeekOne-vimtutor%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="Arts Weekone Vimtutor总结" /><published>2019-04-14T00:00:00+08:00</published><updated>2019-04-14T00:00:00+08:00</updated><id>http://localhost:4000/ARTS-WeekOne-vimtutor%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/ARTS-WeekOne-vimtutor%E6%80%BB%E7%BB%93/">&lt;p&gt;虽然一直在使用vim编辑器，但其实一直没有练习过。借着ARTS中T的名头，就稍微学习一下vimtutor并将其中的总结放在这。&lt;/p&gt;

&lt;h2 id=&quot;一&quot;&gt;一&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用h，j，k，l作为vim中光标的移动键(比上下左右要有效率的多)。&lt;/li&gt;
  &lt;li&gt;使用:q!(&lt;code class=&quot;highlighter-rouge&quot;&gt;quit!&lt;/code&gt;)强制退出当前正在编辑的文件&lt;/li&gt;
  &lt;li&gt;使用x删除当前光标停留处的文字&lt;/li&gt;
  &lt;li&gt;使用i(&lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;)在当前光标位置处插入内容&lt;/li&gt;
  &lt;li&gt;使用A(&lt;code class=&quot;highlighter-rouge&quot;&gt;Append&lt;/code&gt;)在当前最后一行处添加内容&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二&quot;&gt;二&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用dw(&lt;code class=&quot;highlighter-rouge&quot;&gt;delete word&lt;/code&gt;)来删除当前光标处的一个单词&lt;/li&gt;
  &lt;li&gt;使用d$删除当前位置到行末的所有内容&lt;/li&gt;
  &lt;li&gt;许多改变文本的命令都由一个&lt;code class=&quot;highlighter-rouge&quot;&gt;operator&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;组成，例如d代表删除&lt;code class=&quot;highlighter-rouge&quot;&gt;operator&lt;/code&gt;，而&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;可以有如下选择：
    &lt;ul&gt;
      &lt;li&gt;w：直到下一个单词的起始位置，不包括该起始位置&lt;/li&gt;
      &lt;li&gt;e: 直到当前单词的结束位置，包括该结束位置&lt;/li&gt;
      &lt;li&gt;$: 直到当前行的结尾，包括最后一个单词&lt;br /&gt;
 如果只按上述&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;则可以让光标按&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;移动&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;前面可以使用数字进行对多个&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;的操作&lt;/li&gt;
  &lt;li&gt;使用0到一行的起始位置处&lt;/li&gt;
  &lt;li&gt;使用dd删除一整行数据&lt;/li&gt;
  &lt;li&gt;使用u来撤销上一个操作，U来修复一整行的操作，CTRL-R来撤销撤销操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三&quot;&gt;三&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用p(&lt;code class=&quot;highlighter-rouge&quot;&gt;put&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;paste&lt;/code&gt;)来放置vim寄存器中的文本数据(可通过dd，d，yy等操作得到)&lt;/li&gt;
  &lt;li&gt;使用r(&lt;code class=&quot;highlighter-rouge&quot;&gt;replace&lt;/code&gt;)来替换当前光标处的文本&lt;/li&gt;
  &lt;li&gt;使用c(&lt;code class=&quot;highlighter-rouge&quot;&gt;change&lt;/code&gt;)+&lt;code class=&quot;highlighter-rouge&quot;&gt;motion&lt;/code&gt;来改变文版，注意按c之后会进入插入模式&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四&quot;&gt;四&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用CTRL-G命令显示当前文件名以及总行数、当前行数&lt;/li&gt;
  &lt;li&gt;使用G(&lt;code class=&quot;highlighter-rouge&quot;&gt;Go&lt;/code&gt;)到当前文件底端，gg到当前文件顶端,[number]G到[number]行&lt;/li&gt;
  &lt;li&gt;使用/[text]搜索和[text]一样的文本，n是前进，N是后退&lt;/li&gt;
  &lt;li&gt;使用%来匹配各种括号&lt;/li&gt;
  &lt;li&gt;使用:s(&lt;code class=&quot;highlighter-rouge&quot;&gt;substitute&lt;/code&gt;)来替进行各种替换&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五&quot;&gt;五&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用:!来执行外部的shell命令，例如:!ls就可以列举目录&lt;/li&gt;
  &lt;li&gt;使用:w(&lt;code class=&quot;highlighter-rouge&quot;&gt;write&lt;/code&gt;) FILENAME来将当前已经写完的内容写入某个文件&lt;/li&gt;
  &lt;li&gt;使用v(&lt;code class=&quot;highlighter-rouge&quot;&gt;visual&lt;/code&gt;)进入可视化模式，选择部分内容并利用:w来将这些内容写入某个文件&lt;/li&gt;
  &lt;li&gt;使用:r(&lt;code class=&quot;highlighter-rouge&quot;&gt;read&lt;/code&gt;) FILENAME来将目标文件的内容读入当前正在编辑的文件中(不一定是文件内容，某个命令的输出也可以，感觉和管道或是重定向很像)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;六&quot;&gt;六&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;使用o来在当前行下面插入一行，使用O来在当前行上面插入一行&lt;/li&gt;
  &lt;li&gt;使用a来在当前光标的下一个位置插入文本&lt;/li&gt;
  &lt;li&gt;使用R来批量替换文本&lt;/li&gt;
  &lt;li&gt;使用y来复制，p来粘贴。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;对我来说，这个教程比较有用的是2.3,4.4和5.5。以后还要多多练习，对这些基本操作更加熟练&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">虽然一直在使用vim编辑器，但其实一直没有练习过。借着ARTS中T的名头，就稍微学习一下vimtutor并将其中的总结放在这。</summary></entry><entry><title type="html">搭建个人博客</title><link href="http://localhost:4000/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="alternate" type="text/html" title="搭建个人博客" /><published>2019-04-12T00:00:00+08:00</published><updated>2019-04-12T00:00:00+08:00</updated><id>http://localhost:4000/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2</id><content type="html" xml:base="http://localhost:4000/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">&lt;p&gt;关于写博客，其实早就想写了。写博客的好处也从各种渠道都听说过，奈何实在是懒。现在由于看到了ARTS，觉得挺有用的，也想养成长期主动学习的习惯，因此就把博客搞起来，作为这个计划的集合地，当然其它想写的时候也会随便写一些文章。&lt;/p&gt;

&lt;p&gt;搭建博客的教程网上有很多，随便找一个基本上就能搭建完成。我也是拼拼凑凑搭出来的，现在也还只是个雏形。这里还是做个记录，毕竟别人的经验始终是别人的，自己写出来的才是自己的。&lt;/p&gt;

&lt;h2 id=&quot;一利用github-pages托管网站&quot;&gt;一、利用github pages托管网站&lt;/h2&gt;
&lt;p&gt;搭建自己的博客首先得有自己的网站，要有自己的网站首先得有服务器主机来维护它，作为非土豪人士，自己买服务器托管网站这种事是干不出来的。因此，可以使用github pages来托管自己的网站。&lt;/p&gt;

&lt;p&gt;github pages是一个静态站点服务，主要就用来直接从github repo生成网站。因为之前一直也用github，因此一些基本操作也是轻车熟路了，使用它也是基于这个考虑。&lt;/p&gt;

&lt;p&gt;github pages也有一些缺陷，这里简单的列举几点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;它是静态站点服务，不支持服务端代码，例如PHP，Ruby或者Python&lt;/li&gt;
  &lt;li&gt;github pages所在的repo最好不要超过1GB&lt;/li&gt;
  &lt;li&gt;发布的github pages网站不能超过1GB&lt;/li&gt;
  &lt;li&gt;github pages站点的软带宽每个月不超过100GB&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于一般的个人博客网站来说，这些限制应该问题不大。&lt;/p&gt;

&lt;p&gt;接下去说说具体的流程。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在github上创建一个repo，这个repo的名字必须是&lt;em&gt;username&lt;/em&gt;.github.io,其中&lt;em&gt;username&lt;/em&gt;就是你在github上的用户名&lt;/li&gt;
  &lt;li&gt;选择一个文件夹作为github repo的存放地，例如就在$HOME目录下，在终端下输入下面的命令：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone https://github.com/username/username.github.io&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;进入上面的文件夹，创建一个index.html文件。命令如下：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;cd username.github.io&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;echo &quot;Hello World&quot; &amp;gt; index.html&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;将改变上传到github端。命令如下：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git add -all&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &quot;Initial commit&quot;&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;git push -u origin master&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;至此，网站就可以查看了。可以在浏览器中输入&lt;br /&gt;
&lt;strong&gt;https://&lt;em&gt;username&lt;/em&gt;.github.io&lt;/strong&gt;&lt;br /&gt;
查看自己的网站&lt;/p&gt;
&lt;h2 id=&quot;二利用jkeyll编辑自己的博客&quot;&gt;二、利用jkeyll编辑自己的博客&lt;/h2&gt;
&lt;p&gt;有了github pages托管网站之后，接下去就是要将网站变成博客形式了。虽然之前稍微学过一点前端的知识，但要自己从头搭建还是有些困难。在github pages上发现大力推荐的一个静态网页和博客生成框架jekyll，可以直接把markdown格式的文件转化成网页，因此干脆就入坑jekyll了。&lt;/p&gt;

&lt;p&gt;目前我也只是过了两遍jekyll的教程，具体使用还需要摸索，这里就简单的讲一下基础的内容。如果想要详细了解，还是得去&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;jekyll官网&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;jekyll首先需要安装Ruby的运行环境，在Linux Ubuntu环境下是很简单的，输入下面的命令：
&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install ruby-full build-essential zlib1g-dev&lt;/code&gt;
接着设置一下环境变量&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;echo '# Install Ruby Gems to ~/gems' &amp;gt;&amp;gt; ~/.bashrc
echo 'export GEM_HOME=&quot;$HOME/gems&quot;' &amp;gt;&amp;gt; ~/.bashrc
echo 'export PATH=&quot;$HOME/gems/bin:$PATH&quot;' &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc`
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最后，安装jekyll以及bundler插件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll bundler&lt;/code&gt;&lt;br /&gt;
至此，jekyll的安装就完成了。&lt;/p&gt;

&lt;p&gt;jekyll的使用也很简单，如果不使用github pages，直接
&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new [foldername]&lt;/code&gt;
其中&lt;code class=&quot;highlighter-rouge&quot;&gt;foldername&lt;/code&gt;就是文件夹名字，jekyll就会在文件夹中生成一个网站的雏形。想要在本地浏览网页只需要&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;就可以在浏览器中输入&lt;a href=&quot;http://127.0.0.1:4000&quot;&gt;http://127.0.0.1:4000&lt;/a&gt;浏览网页的样子了。(注意，这里&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new&lt;/code&gt;可能花费较长时间，其实不用该命令也可以，自己手动建立目录就行了)&lt;/p&gt;

&lt;p&gt;如果使用github pages，也很简单，在之前的第一步生成的github repo里面创建对应目录结构也一样可以浏览。一般的目录结构如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.  
+-- _site  
+-- _layouts  
|   +--  default.html  
|   +--  post.html  
+-- _posts  
|   +-- 2019-11-11-new-post.md  
|   +-- 2019-1-1-old-post.md  
+-- _data  
+-- _includes  
+-- assets  
|   +-- css  
|   +-- images  
|   +-- js  
+-- _sass  
+-- _config.yml  
+-- index.html  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中,_layouts目录放置的是网页文件的布局样式，_posts目录放置的是博客文章(注意，文件名字必须是yyyy-mm-dd-&lt;em&gt;article_title&lt;/em&gt;样式的)，_includes目录放置的是导入文件，assets目录放置的是资源文件，包括css和js等。_config.yml是配置文件，index.html则是网页文件。&lt;/p&gt;

&lt;p&gt;在github pages上还可以直接使用jekyll的主题，虽然主题不多，但暂时可以将就着用，后期再自己改进。&lt;/p&gt;

&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;博客搭建的过程到这里算是暂时结束了，后期还需要对jekyll作进一步的深入了解以调整自己的博客。目前暂时就先这样吧。&lt;/p&gt;</content><author><name>Tonfeiz</name></author><summary type="html">关于写博客，其实早就想写了。写博客的好处也从各种渠道都听说过，奈何实在是懒。现在由于看到了ARTS，觉得挺有用的，也想养成长期主动学习的习惯，因此就把博客搞起来，作为这个计划的集合地，当然其它想写的时候也会随便写一些文章。</summary></entry></feed>