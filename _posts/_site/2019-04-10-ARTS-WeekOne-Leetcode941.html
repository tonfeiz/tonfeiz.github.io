<p>Given an array <code class="highlighter-rouge">A</code> of integers, return <code class="highlighter-rouge">true</code> if and only if it is a <em>valid mountain array</em>.</p>

<p>Recall that <code class="highlighter-rouge">A</code> is a mountain array if and only if:</p>
<ul>
  <li><code class="highlighter-rouge">A.length</code> &gt;= 3</li>
  <li>There exists some <code class="highlighter-rouge">i</code> with <code class="highlighter-rouge">0 &lt; i &lt; A.length - 1</code> such that:
    <ul>
      <li><code class="highlighter-rouge">A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
      <li><code class="highlighter-rouge">A[i] &gt; A[i+1] &gt; ... &gt; A[B.length - 1]</code></li>
    </ul>
  </li>
</ul>

<hr />
<p>这是一道简单题，题意就是判断一个数组是否存在且只存在一个山顶，其实就是判断是否数组是先升后降的，并且不存在相等元素。</p>

<p>思路很直白，设置一个变量<code class="highlighter-rouge">mountain_top</code>(需初始化为0)，遍历数组，当找到降序后将山顶位置赋值给它，然后继续遍历，若此后出现升序则直接返回false。最后，若遍历完成后该变量未被修改，说明不存在山顶(单纯升序则为0,单纯降序也为0)。最后，注意排除相等的情况。</p>

<p>代码是用go语言写的，如下所示</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func validMountainArray(A []int) bool {
    if len(A) &lt; 3 {
        return false
    }
    
    mountain_top := 0
    for i := 0; i &lt; len(A) - 1; i++ {
        if A[i] &gt; A[i + 1] {
            mountain_top = i
            break
        } else if A[i] == A[i + 1] {
            return false;
        }
    }
    for i := mountain_top; i &lt; len(A) - 1; i++ {
        if A[i] &lt;= A[i + 1] {
            return false
        } 
    }
    
    
    return mountain_top != 0
}
</code></pre></div></div>
